<!DOCTYPE HTML>
<html lang="en" class="sidebar-visible no-js light">
    <head>
        <!-- Book generated using mdBook -->
        <meta charset="UTF-8">
        <title>DynamoPrimer</title>
        <meta name="robots" content="noindex" />


        <!-- Custom HTML head -->
        
        <meta content="text/html; charset=utf-8" http-equiv="Content-Type">
        <meta name="description" content="">
        <meta name="viewport" content="width=device-width, initial-scale=1">
        <meta name="theme-color" content="#ffffff" />

        <link rel="icon" href="favicon.svg">
        <link rel="shortcut icon" href="favicon.png">
        <link rel="stylesheet" href="css/variables.css">
        <link rel="stylesheet" href="css/general.css">
        <link rel="stylesheet" href="css/chrome.css">
        <link rel="stylesheet" href="css/print.css" media="print">

        <!-- Fonts -->
        <link rel="stylesheet" href="FontAwesome/css/font-awesome.css">
        <link rel="stylesheet" href="fonts/fonts.css">

        <!-- Highlight.js Stylesheets -->
        <link rel="stylesheet" href="highlight.css">
        <link rel="stylesheet" href="tomorrow-night.css">
        <link rel="stylesheet" href="ayu-highlight.css">

        <!-- Custom theme stylesheets -->

    </head>
    <body>
        <!-- Provide site root to javascript -->
        <script type="text/javascript">
            var path_to_root = "";
            var default_theme = window.matchMedia("(prefers-color-scheme: dark)").matches ? "navy" : "light";
        </script>

        <!-- Work around some values being stored in localStorage wrapped in quotes -->
        <script type="text/javascript">
            try {
                var theme = localStorage.getItem('mdbook-theme');
                var sidebar = localStorage.getItem('mdbook-sidebar');

                if (theme.startsWith('"') && theme.endsWith('"')) {
                    localStorage.setItem('mdbook-theme', theme.slice(1, theme.length - 1));
                }

                if (sidebar.startsWith('"') && sidebar.endsWith('"')) {
                    localStorage.setItem('mdbook-sidebar', sidebar.slice(1, sidebar.length - 1));
                }
            } catch (e) { }
        </script>

        <!-- Set the theme before any content is loaded, prevents flash -->
        <script type="text/javascript">
            var theme;
            try { theme = localStorage.getItem('mdbook-theme'); } catch(e) { }
            if (theme === null || theme === undefined) { theme = default_theme; }
            var html = document.querySelector('html');
            html.classList.remove('no-js')
            html.classList.remove('light')
            html.classList.add(theme);
            html.classList.add('js');
        </script>

        <!-- Hide / unhide sidebar before it is displayed -->
        <script type="text/javascript">
            var html = document.querySelector('html');
            var sidebar = 'hidden';
            if (document.body.clientWidth >= 1080) {
                try { sidebar = localStorage.getItem('mdbook-sidebar'); } catch(e) { }
                sidebar = sidebar || 'visible';
            }
            html.classList.remove('sidebar-visible');
            html.classList.add("sidebar-" + sidebar);
        </script>

        <nav id="sidebar" class="sidebar" aria-label="Table of contents">
            <div class="sidebar-scrollbox">
                <ol class="chapter"><li class="chapter-item expanded "><a href="index.html"><strong aria-hidden="true">1.</strong> About</a></li><li class="chapter-item expanded "><a href="1_introduction/index.html"><strong aria-hidden="true">2.</strong> Introduction</a></li><li><ol class="section"><li class="chapter-item expanded "><a href="1_introduction/1-what-is-dynamo.html"><strong aria-hidden="true">2.1.</strong> What is Dynamo & How Does It Work?</a></li><li class="chapter-item expanded "><a href="1_introduction/2-primer-user-guide-dynamo-community-and-platform.html"><strong aria-hidden="true">2.2.</strong> Primer User Guide, Dynamo Community & Platform</a></li></ol></li><li class="chapter-item expanded "><a href="2_setup_for_dynamo/index.html"><strong aria-hidden="true">3.</strong> Setup for Dynamo</a></li><li class="chapter-item expanded "><a href="3_user_interface/index.html"><strong aria-hidden="true">4.</strong> User Interface</a></li><li><ol class="section"><li class="chapter-item expanded "><a href="3_user_interface/1-workspace.html"><strong aria-hidden="true">4.1.</strong> Workspace</a></li><li class="chapter-item expanded "><a href="3_user_interface/2-library.html"><strong aria-hidden="true">4.2.</strong> Library</a></li></ol></li><li class="chapter-item expanded "><a href="4_nodes_and_wires/index.html"><strong aria-hidden="true">5.</strong> Nodes and Wires</a></li><li class="chapter-item expanded "><a href="5_essential_nodes_and_concepts/index.html"><strong aria-hidden="true">6.</strong> Essential Nodes & Concepts</a></li><li><ol class="section"><li class="chapter-item expanded "><a href="5_essential_nodes_and_concepts/index-of-nodes.html"><strong aria-hidden="true">6.1.</strong> Index of Nodes</a></li><li class="chapter-item expanded "><a href="5_essential_nodes_and_concepts/5-2_geometry-for-computational-design/index.html"><strong aria-hidden="true">6.2.</strong> Geometry for Computational Design</a></li><li><ol class="section"><li class="chapter-item expanded "><a href="5_essential_nodes_and_concepts/5-2_geometry-for-computational-design/1-geometry-overview.html"><strong aria-hidden="true">6.2.1.</strong> Geometry Overview</a></li><li class="chapter-item expanded "><a href="5_essential_nodes_and_concepts/5-2_geometry-for-computational-design/2-vectors.html"><strong aria-hidden="true">6.2.2.</strong> Vector, Plane & Coordinate System</a></li><li class="chapter-item expanded "><a href="5_essential_nodes_and_concepts/5-2_geometry-for-computational-design/3-points.html"><strong aria-hidden="true">6.2.3.</strong> Points</a></li><li class="chapter-item expanded "><a href="5_essential_nodes_and_concepts/5-2_geometry-for-computational-design/4-curves.html"><strong aria-hidden="true">6.2.4.</strong> Curves</a></li><li class="chapter-item expanded "><a href="5_essential_nodes_and_concepts/5-2_geometry-for-computational-design/5-surfaces.html"><strong aria-hidden="true">6.2.5.</strong> Surfaces</a></li><li class="chapter-item expanded "><a href="5_essential_nodes_and_concepts/5-2_geometry-for-computational-design/6-solids.html"><strong aria-hidden="true">6.2.6.</strong> Solids</a></li><li class="chapter-item expanded "><a href="5_essential_nodes_and_concepts/5-2_geometry-for-computational-design/7-meshes.html"><strong aria-hidden="true">6.2.7.</strong> Meshes</a></li></ol></li><li class="chapter-item expanded "><a href="5_essential_nodes_and_concepts/5-3_the-building-blocks-of-programs/index.html"><strong aria-hidden="true">6.3.</strong> The Building Blocks of Programs</a></li><li><ol class="section"><li class="chapter-item expanded "><a href="5_essential_nodes_and_concepts/5-3_the-building-blocks-of-programs/1-data.html"><strong aria-hidden="true">6.3.1.</strong> Data</a></li><li class="chapter-item expanded "><a href="5_essential_nodes_and_concepts/5-3_the-building-blocks-of-programs/2-math.html"><strong aria-hidden="true">6.3.2.</strong> Math</a></li><li class="chapter-item expanded "><a href="5_essential_nodes_and_concepts/5-3_the-building-blocks-of-programs/3-logic.html"><strong aria-hidden="true">6.3.3.</strong> Logic</a></li><li class="chapter-item expanded "><a href="5_essential_nodes_and_concepts/5-3_the-building-blocks-of-programs/4-strings.html"><strong aria-hidden="true">6.3.4.</strong> Strings</a></li><li class="chapter-item expanded "><a href="5_essential_nodes_and_concepts/5-3_the-building-blocks-of-programs/5-color.html"><strong aria-hidden="true">6.3.5.</strong> Color</a></li></ol></li><li class="chapter-item expanded "><a href="5_essential_nodes_and_concepts/5-4_designing-with-lists/index.html"><strong aria-hidden="true">6.4.</strong> Designing with Lists</a></li><li><ol class="section"><li class="chapter-item expanded "><a href="5_essential_nodes_and_concepts/5-4_designing-with-lists/1-whats-a-list.html"><strong aria-hidden="true">6.4.1.</strong> What's a List</a></li><li class="chapter-item expanded "><a href="5_essential_nodes_and_concepts/5-4_designing-with-lists/2-working-with-lists.html"><strong aria-hidden="true">6.4.2.</strong> Working with Lists</a></li><li class="chapter-item expanded "><a href="5_essential_nodes_and_concepts/5-4_designing-with-lists/3-lists-of-lists.html"><strong aria-hidden="true">6.4.3.</strong> Lists of Lists</a></li><li class="chapter-item expanded "><a href="5_essential_nodes_and_concepts/5-4_designing-with-lists/4-n-dimensional-lists.html"><strong aria-hidden="true">6.4.4.</strong> n-Dimensional Lists</a></li></ol></li><li class="chapter-item expanded "><a href="5_essential_nodes_and_concepts/5-5_dictionaries-in-dynamo/index.html"><strong aria-hidden="true">6.5.</strong> Dictionaries in Dynamo</a></li><li><ol class="section"><li class="chapter-item expanded "><a href="5_essential_nodes_and_concepts/5-5_dictionaries-in-dynamo/1-what-is-a-dictionary.html"><strong aria-hidden="true">6.5.1.</strong> What is a Dictionary</a></li><li class="chapter-item expanded "><a href="5_essential_nodes_and_concepts/5-5_dictionaries-in-dynamo/2-node-uses.html"><strong aria-hidden="true">6.5.2.</strong> Dictionary Nodes</a></li><li class="chapter-item expanded "><a href="5_essential_nodes_and_concepts/5-5_dictionaries-in-dynamo/3-code-block-uses.html"><strong aria-hidden="true">6.5.3.</strong> Dictionaries in Code Blocks</a></li><li class="chapter-item expanded "><a href="5_essential_nodes_and_concepts/5-5_dictionaries-in-dynamo/4-dictionary-use-cases.html"><strong aria-hidden="true">6.5.4.</strong> Revit Use-Cases</a></li></ol></li></ol></li><li class="chapter-item expanded "><a href="6_custom_nodes_and_packages/index.html"><strong aria-hidden="true">7.</strong> Custom Nodes & Packages</a></li><li><ol class="section"><li class="chapter-item expanded "><a href="6_custom_nodes_and_packages/6-1_custom-nodes/index.html"><strong aria-hidden="true">7.1.</strong> Custom Nodes</a></li><li><ol class="section"><li class="chapter-item expanded "><a href="6_custom_nodes_and_packages/6-1_custom-nodes/1-introduction.html"><strong aria-hidden="true">7.1.1.</strong> Custom Node Introduction</a></li><li class="chapter-item expanded "><a href="6_custom_nodes_and_packages/6-1_custom-nodes/2-creating.html"><strong aria-hidden="true">7.1.2.</strong> Creating a Custom Node</a></li><li class="chapter-item expanded "><a href="6_custom_nodes_and_packages/6-1_custom-nodes/3-library.html"><strong aria-hidden="true">7.1.3.</strong> Publishing to Your Library</a></li></ol></li><li class="chapter-item expanded "><a href="6_custom_nodes_and_packages/6-2_packages/index.html"><strong aria-hidden="true">7.2.</strong> Packages</a></li><li><ol class="section"><li class="chapter-item expanded "><a href="6_custom_nodes_and_packages/6-2_packages/1-introduction.html"><strong aria-hidden="true">7.2.1.</strong> Package Introduction</a></li><li class="chapter-item expanded "><a href="6_custom_nodes_and_packages/6-2_packages/2-mesh-toolkit.html"><strong aria-hidden="true">7.2.2.</strong> Package Case Study - Mesh Toolkit</a></li><li class="chapter-item expanded "><a href="6_custom_nodes_and_packages/6-2_packages/3-developing.html"><strong aria-hidden="true">7.2.3.</strong> Developing a Package</a></li><li class="chapter-item expanded "><a href="6_custom_nodes_and_packages/6-2_packages/4-publishing.html"><strong aria-hidden="true">7.2.4.</strong> Publishing a Package</a></li><li class="chapter-item expanded "><a href="6_custom_nodes_and_packages/6-2_packages/5-zero-touch.html"><strong aria-hidden="true">7.2.5.</strong> Zero-Touch Importing</a></li></ol></li></ol></li><li class="chapter-item expanded "><a href="7_dynamo_for_revit/index.html"><strong aria-hidden="true">8.</strong> Dynamo for Revit</a></li><li><ol class="section"><li class="chapter-item expanded "><a href="7_dynamo_for_revit/1-the-revit-connection.html"><strong aria-hidden="true">8.1.</strong> The Revit Connection</a></li><li class="chapter-item expanded "><a href="7_dynamo_for_revit/2-selecting.html"><strong aria-hidden="true">8.2.</strong> Selecting</a></li><li class="chapter-item expanded "><a href="7_dynamo_for_revit/3-editing.html"><strong aria-hidden="true">8.3.</strong> Editing</a></li><li class="chapter-item expanded "><a href="7_dynamo_for_revit/4-creating.html"><strong aria-hidden="true">8.4.</strong> Creating</a></li><li class="chapter-item expanded "><a href="7_dynamo_for_revit/5-customizing.html"><strong aria-hidden="true">8.5.</strong> Customizing</a></li><li class="chapter-item expanded "><a href="7_dynamo_for_revit/6-documenting.html"><strong aria-hidden="true">8.6.</strong> Documenting</a></li></ol></li><li class="chapter-item expanded "><a href="8_coding_in_dynamo/index.html"><strong aria-hidden="true">9.</strong> Coding in Dynamo</a></li><li><ol class="section"><li class="chapter-item expanded "><a href="8_coding_in_dynamo/8-1_code-blocks-and-design-script/index.html"><strong aria-hidden="true">9.1.</strong> Code Blocks and DesignScript</a></li><li><ol class="section"><li class="chapter-item expanded "><a href="8_coding_in_dynamo/8-1_code-blocks-and-design-script/1-what-is-a-code-block.html"><strong aria-hidden="true">9.1.1.</strong> What's a Code Block</a></li><li class="chapter-item expanded "><a href="8_coding_in_dynamo/8-1_code-blocks-and-design-script/2-design-script-syntax.html"><strong aria-hidden="true">9.1.2.</strong> DesignScript Syntax</a></li><li class="chapter-item expanded "><a href="8_coding_in_dynamo/8-1_code-blocks-and-design-script/3-shorthand.html"><strong aria-hidden="true">9.1.3.</strong> Shorthand</a></li><li class="chapter-item expanded "><a href="8_coding_in_dynamo/8-1_code-blocks-and-design-script/4-functions.html"><strong aria-hidden="true">9.1.4.</strong> Functions</a></li></ol></li><li class="chapter-item expanded "><a href="8_coding_in_dynamo/8-2_geometry-with-design-script/index.html"><strong aria-hidden="true">9.2.</strong> Geometry with DesignScript</a></li><li><ol class="section"><li class="chapter-item expanded "><a href="8_coding_in_dynamo/8-2_geometry-with-design-script/1-designscript-geometry-basics.html"><strong aria-hidden="true">9.2.1.</strong> DesignScript Geometry Basics</a></li><li class="chapter-item expanded "><a href="8_coding_in_dynamo/8-2_geometry-with-design-script/2-geometric-primitives.html"><strong aria-hidden="true">9.2.2.</strong> Geometric Primitives</a></li><li class="chapter-item expanded "><a href="8_coding_in_dynamo/8-2_geometry-with-design-script/3-vector-math.html"><strong aria-hidden="true">9.2.3.</strong> Vector Math</a></li><li class="chapter-item expanded "><a href="8_coding_in_dynamo/8-2_geometry-with-design-script/4-curves.html"><strong aria-hidden="true">9.2.4.</strong> Curves: Interpolated and Control Points</a></li><li class="chapter-item expanded "><a href="8_coding_in_dynamo/8-2_geometry-with-design-script/5-translation-rotation-and-other-transformations.html"><strong aria-hidden="true">9.2.5.</strong> Translation, Rotation, and Other Transformations</a></li><li class="chapter-item expanded "><a href="8_coding_in_dynamo/8-2_geometry-with-design-script/6-surfaces.html"><strong aria-hidden="true">9.2.6.</strong> Surfaces: Interpolated, Control Points, Loft, Revolve</a></li><li class="chapter-item expanded "><a href="8_coding_in_dynamo/8-2_geometry-with-design-script/7-geometric-parameterization.html"><strong aria-hidden="true">9.2.7.</strong> Geometric Parameterization</a></li><li class="chapter-item expanded "><a href="8_coding_in_dynamo/8-2_geometry-with-design-script/8-intersection-and-trim.html"><strong aria-hidden="true">9.2.8.</strong> Intersection and Trim</a></li><li class="chapter-item expanded "><a href="8_coding_in_dynamo/8-2_geometry-with-design-script/9-geometric-booleans.html"><strong aria-hidden="true">9.2.9.</strong> Geometric Booleans</a></li><li class="chapter-item expanded "><a href="8_coding_in_dynamo/8-2_geometry-with-design-script/10-python-point-generators.html"><strong aria-hidden="true">9.2.10.</strong> Python Point Generators</a></li></ol></li><li class="chapter-item expanded "><a href="8_coding_in_dynamo/8-3_python/index.html"><strong aria-hidden="true">9.3.</strong> Python</a></li><li><ol class="section"><li class="chapter-item expanded "><a href="8_coding_in_dynamo/8-3_python/1-python.html"><strong aria-hidden="true">9.3.1.</strong> Python Nodes</a></li><li class="chapter-item expanded "><a href="8_coding_in_dynamo/8-3_python/2-python-revit.html"><strong aria-hidden="true">9.3.2.</strong> Python and Revit</a></li><li class="chapter-item expanded "><a href="8_coding_in_dynamo/8-3_python/3-python-templates.html"><strong aria-hidden="true">9.3.3.</strong> Setup Your Own Python Template</a></li></ol></li></ol></li><li class="chapter-item expanded "><a href="9_best_practices/index.html"><strong aria-hidden="true">10.</strong> Best Practices</a></li><li><ol class="section"><li class="chapter-item expanded "><a href="9_best_practices/1-graph-strategies.html"><strong aria-hidden="true">10.1.</strong> Graph Strategies</a></li><li class="chapter-item expanded "><a href="9_best_practices/2-scripting-strategies.html"><strong aria-hidden="true">10.2.</strong> Scripting Strategies</a></li><li class="chapter-item expanded "><a href="9_best_practices/3-scripting-reference.html"><strong aria-hidden="true">10.3.</strong> Scripting Reference</a></li><li class="chapter-item expanded "><a href="9_best_practices/4-managing-your-program.html"><strong aria-hidden="true">10.4.</strong> Managing Your Program</a></li></ol></li><li class="chapter-item expanded "><a href="10_sample_workflow/index.html"><strong aria-hidden="true">11.</strong> Sample Workflows</a></li><li><ol class="section"><li class="chapter-item expanded "><a href="10_sample_workflow/10-1_getting-started-workflows/index.html"><strong aria-hidden="true">11.1.</strong> Getting Started Workflows</a></li><li><ol class="section"><li class="chapter-item expanded "><a href="10_sample_workflow/10-1_getting-started-workflows/1-parametric-vase.html"><strong aria-hidden="true">11.1.1.</strong> Parametric Vase</a></li><li class="chapter-item expanded "><a href="10_sample_workflow/10-1_getting-started-workflows/2-attractor-points.html"><strong aria-hidden="true">11.1.2.</strong> Attractor Points</a></li></ol></li><li class="chapter-item expanded "><a href="10_sample_workflow/10-2_concept-index.html"><strong aria-hidden="true">11.2.</strong> Concept Index</a></li></ol></li><li class="chapter-item expanded "><a href="a_appendix/index.html"><strong aria-hidden="true">12.</strong> Appendix</a></li><li><ol class="section"><li class="chapter-item expanded "><a href="a_appendix/a-1_visual-programming-and-dynamo.html"><strong aria-hidden="true">12.1.</strong> Visual Programming and Dynamo</a></li><li class="chapter-item expanded "><a href="a_appendix/a-2_resources.html"><strong aria-hidden="true">12.2.</strong> Resources</a></li><li class="chapter-item expanded "><a href="a_appendix/a-3_packages.html"><strong aria-hidden="true">12.3.</strong> Useful Packages</a></li><li class="chapter-item expanded "><a href="a_appendix/a-4_example-files.html"><strong aria-hidden="true">12.4.</strong> Example Files</a></li><li class="chapter-item expanded "><a href="a_appendix/a-5_download-pdf.html"><strong aria-hidden="true">12.5.</strong> Download PDF</a></li></ol></li></ol>
            </div>
            <div id="sidebar-resize-handle" class="sidebar-resize-handle"></div>
        </nav>

        <div id="page-wrapper" class="page-wrapper">

            <div class="page">
                                <div id="menu-bar-hover-placeholder"></div>
                <div id="menu-bar" class="menu-bar sticky bordered">
                    <div class="left-buttons">
                        <button id="sidebar-toggle" class="icon-button" type="button" title="Toggle Table of Contents" aria-label="Toggle Table of Contents" aria-controls="sidebar">
                            <i class="fa fa-bars"></i>
                        </button>
                        <button id="theme-toggle" class="icon-button" type="button" title="Change theme" aria-label="Change theme" aria-haspopup="true" aria-expanded="false" aria-controls="theme-list">
                            <i class="fa fa-paint-brush"></i>
                        </button>
                        <ul id="theme-list" class="theme-popup" aria-label="Themes" role="menu">
                            <li role="none"><button role="menuitem" class="theme" id="light">Light (default)</button></li>
                            <li role="none"><button role="menuitem" class="theme" id="rust">Rust</button></li>
                            <li role="none"><button role="menuitem" class="theme" id="coal">Coal</button></li>
                            <li role="none"><button role="menuitem" class="theme" id="navy">Navy</button></li>
                            <li role="none"><button role="menuitem" class="theme" id="ayu">Ayu</button></li>
                        </ul>
                        <button id="search-toggle" class="icon-button" type="button" title="Search. (Shortkey: s)" aria-label="Toggle Searchbar" aria-expanded="false" aria-keyshortcuts="S" aria-controls="searchbar">
                            <i class="fa fa-search"></i>
                        </button>
                    </div>

                    <h1 class="menu-title">DynamoPrimer</h1>

                    <div class="right-buttons">
                        <a href="print.html" title="Print this book" aria-label="Print this book">
                            <i id="print-button" class="fa fa-print"></i>
                        </a>

                    </div>
                </div>

                <div id="search-wrapper" class="hidden">
                    <form id="searchbar-outer" class="searchbar-outer">
                        <input type="search" id="searchbar" name="searchbar" placeholder="Search this book ..." aria-controls="searchresults-outer" aria-describedby="searchresults-header">
                    </form>
                    <div id="searchresults-outer" class="searchresults-outer hidden">
                        <div id="searchresults-header" class="searchresults-header"></div>
                        <ul id="searchresults">
                        </ul>
                    </div>
                </div>

                <!-- Apply ARIA attributes after the sidebar and the sidebar toggle button are added to the DOM -->
                <script type="text/javascript">
                    document.getElementById('sidebar-toggle').setAttribute('aria-expanded', sidebar === 'visible');
                    document.getElementById('sidebar').setAttribute('aria-hidden', sidebar !== 'visible');
                    Array.from(document.querySelectorAll('#sidebar a')).forEach(function(link) {
                        link.setAttribute('tabIndex', sidebar === 'visible' ? 0 : -1);
                    });
                </script>

                <div id="content" class="content">
                    <main>
                        <h1 id="about"><a class="header" href="#about">About</a></h1>
<iframe width="560" height="315" src="https://www.youtube.com/embed/9vafneOBgYs" title="Dynamo Hype Video" frameborder="0" allow="accelerometer; autoplay; clipboard-write; encrypted-media; gyroscope; picture-in-picture" allowfullscreen></iframe>
<h2 id="for-dynamo-v213"><a class="header" href="#for-dynamo-v213">For Dynamo v2.13</a></h2>
<p><img src="images/dynamo_logo_dark-trim.jpg" alt="Dynamo Logo" /></p>
<blockquote>
<p>Dynamo is an open source visual programming platform for designers.</p>
</blockquote>
<h3 id="welcome"><a class="header" href="#welcome">Welcome</a></h3>
<p>You have just opened the Dynamo Primer, a comprehensive guide to visual programming in Autodesk Dynamo. This primer is an on-going project to share the fundamentals of programming. Topics include working with computational geometry, best practices for rules-based design, cross-disciplinary programming applications, and more with the Dynamo Platform.</p>
<p>The power of Dynamo can be found in a wide variety of design-related activities. Dynamo enables an expanding list of readily accessible ways for you to get started:</p>
<ul>
<li><strong>Explore</strong> visual programming for the first time</li>
<li><strong>Connect</strong> workflows in various software</li>
<li><strong>Engage</strong> an active community of users, contributors, and developers</li>
<li><strong>Develop</strong> an open-source platform for continued improvement</li>
</ul>
<p>In the midst of this activity and exciting opportunity for working with Dynamo, we need a document of the same caliber, the Dynamo Primer.</p>
<p>Refer to the <a href="1_introduction/2-primer-user-guide-dynamo-community-and-platform.html">primer user guide</a> to find out what you can expect to learn from this primer.</p>
<p>We are continuously improving Dynamo, so some features may look different from what is represented in this Primer. However, all functionality changes will be correctly represented.</p>
<h3 id="open-source"><a class="header" href="#open-source">Open Source</a></h3>
<p>The Dynamo Primer project is open source! We're dedicated to providing quality content and appreciate any feedback you may have. If you would like to report an issue on anything at all, please post them on our GitHub issue page: https://github.com/DynamoDS/DynamoPrimer/issues</p>
<p>If you would like to contribute a new section, edits, or anything else to this project, check out the GitHub repo to get started: https://github.com/DynamoDS/DynamoPrimer.</p>
<h3 id="the-dynamo-primer-project"><a class="header" href="#the-dynamo-primer-project">The Dynamo Primer Project</a></h3>
<p>The Dynamo Primer is an open-source project, initiated by Matt Jezyk and the Dynamo Development team at Autodesk.</p>
<p><strong>Mode Lab</strong> was commissioned to write the First Edition of the primer. We thank them for all of their efforts in establishing this valuable resource.</p>
<p><img src="images/MODELAB_Logo.png" alt="" /></p>
<hr />
<p><strong>John Pierson of Parallax Team</strong> was commissioned to update the primer to reflect the Dynamo 2.0. revisions.</p>
<p><img src="images/PRLX_Logo.jpg" alt="" /></p>
<hr />
<p><strong>Matterlab</strong> was commissioned to update the primer to reflect the Dynamo 2.13. revisions.</p>
<p><img src="images/matterlab_final-07.jpg" alt="" /></p>
<h3 id="acknowledgments"><a class="header" href="#acknowledgments">Acknowledgments</a></h3>
<p>A special thanks to Ian Keough for initiating and guiding the Dynamo project.</p>
<p>Thank you to Matt Jezyk, Ian Keough, Zach Kron, Racel Williams and Colin McCrone for enthusiastic collaboration and the opportunity to participate on a wide array of Dynamo projects.</p>
<h3 id="software-and-resources"><a class="header" href="#software-and-resources">Software and Resources</a></h3>
<p><strong>Dynamo</strong> Please refer to the following sites for the most current <strong>stable</strong> release of Dynamo.</p>
<p>http://dynamobim.com/download/ or http://dynamobuilds.com</p>
<p>*Note: Starting with Revit 2020, Dynamo is bundled with Revit releases, resulting in manual installation not being required. More information is available at this <a href="https://dynamobim.org/dynamo-core-2-1-release/">blog post</a>.</p>
<p><strong>DynamoBIM</strong> The best source for additional information, learning content, and forums is the DynamoBIM website.</p>
<p>http://dynamobim.org</p>
<p><strong>Dynamo GitHub</strong> Dynamo is an open-source development project on GitHub. To contribute, check out DynamoDS.</p>
<p>https://github.com/DynamoDS/Dynamo</p>
<p><strong>Contact</strong> Let us know about any issues with this document.</p>
<p>Dynamo@autodesk.com</p>
<h3 id="license"><a class="header" href="#license">License</a></h3>
<p>Copyright 2022 Autodesk</p>
<p>Licensed under the Apache License, Version 2.0 (the &quot;License&quot;); you may not use this file except in compliance with the License. You may obtain a copy of the License at</p>
<p>http://www.apache.org/licenses/LICENSE-2.0</p>
<p>Unless required by applicable law or agreed to in writing, software distributed under the License is distributed on an &quot;AS IS&quot; BASIS, WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied. See the License for the specific language governing permissions and limitations under the License.</p>
<div style="break-before: page; page-break-before: always;"></div><h1 id="introduction"><a class="header" href="#introduction">Introduction</a></h1>
<p>From its origins as an add-on for Building Information Modeling in Revit, Dynamo has matured to become many things. Above all else it is a platform, enabling designers to explore visual programming, solve problems, and make their own tools. Let's start our journey with Dynamo by setting some context - what is it and how do I approach using it?</p>
<p><img src="1_introduction/./images/introdynamocover.jpg" alt="Dynamo Ecosystem" /></p>
<div style="break-before: page; page-break-before: always;"></div><h1 id="what-is-dynamo--how-does-it-work"><a class="header" href="#what-is-dynamo--how-does-it-work">What is Dynamo &amp; How Does It Work?</a></h1>
<p>Dynamo is a <a href="https://primer2.dynamobim.org/a_appendix/a-1_visual-programming-and-dynamo">visual programming</a> application that can be downloaded and run in either stand-alone &quot;Sandbox&quot; mode or as a plug-in for other software like Revit, FormIt or Civil 3D.</p>
<p>{% hint style=&quot;info&quot; %}
Learn more about the <a href="https://dynamobim.org/a-new-way-to-get-dynamo-sandbox/">difference between <strong>Dynamo Core</strong>/<strong>Revit</strong>/<strong>Sandbox</strong>.</a>
{% endhint %}</p>
<h3 id="the-process"><a class="header" href="#the-process">The Process</a></h3>
<p>Dynamo enables us to work within a Visual Programming process wherein we connect elements together to define the relationships and the sequences of actions that compose custom algorithms. We can use our algorithms for a wide array of applications, from processing data to generating geometry, all in real-time and without writing a lick of <code>code</code>.</p>
<p><img src="1_introduction/images/1-1/nodesandwires-flowofdata.jpg" alt="" /></p>
<h3 id="connecting-nodes-and-wires"><a class="header" href="#connecting-nodes-and-wires">Connecting Nodes and Wires</a></h3>
<p>Nodes and Wires are the key components in Dynamo to support a <a href="1_introduction/../a_appendix/a-1_visual-programming-and-dynamo.html">visual programming</a> process. It help establish strong visual and systemic relationships between the parts of a design. Using simple mouse-click to connect the Nodes easily while developing and optimizing your design workflow.</p>
<p><img src="1_introduction/images/1-1/whatisdynamo-connectingnodeswithwires.gif" alt="" /></p>
<h2 id="what-can-dynamo-achieve"><a class="header" href="#what-can-dynamo-achieve">What can Dynamo Achieve?</a></h2>
<p>From using Visual Programming for project workflows to developing customized tools, Dynamo is an integral aspect of a wide variety of exciting applications.</p>
<p><a href="http://www.pinterest.com/modelabnyc/dynamo-in-action/">Follow the Dynamo in Action board on Pinterest.</a></p>
<div style="break-before: page; page-break-before: always;"></div><h1 id="primer-user-guide-dynamo-community--platform"><a class="header" href="#primer-user-guide-dynamo-community--platform">Primer User Guide, Dynamo Community &amp; Platform</a></h1>
<p>This Primer includes chapters developed with Mode Lab. These chapters focus on the essentials you will need to get up and running developing your own visual programs with Dynamo and key insights on how to take Dynamo further.</p>
<h3 id="primer-user-guide"><a class="header" href="#primer-user-guide">Primer User Guide</a></h3>
<p>This guide is designed to cater to readers from different backgrounds and skill levels. General introduction about Dynamo setup, user interface and key concepts can be found in the following sections, we recommend new users to cover the following topics:</p>
<ul>
<li><a href="1_introduction/1-what-is-dynamo.html">What is Dynamo &amp; How Does It Work?</a></li>
<li><a href="1_introduction/../2_setup_for_dynamo/">Setup for Dynamo</a></li>
<li><a href="1_introduction/../3_user_interface/">User Interface</a></li>
<li><a href="1_introduction/../4_nodes_and_wires/">Nodes and Wires</a></li>
</ul>
<p>For users who would like to develop a more in-depth understanding of each element such as a specific Nodes and the concept behind it, we cover the fundamentals in its own chapter.</p>
<ul>
<li><a href="1_introduction/../5_essential_nodes_and_concepts/">Essential Nodes &amp; Concepts</a></li>
</ul>
<p>If you would like to see the demonstration of Dynamo workflows, we have included some graphs in the Sample Workflows section. Follow the attached instructions to create your own Dynamo graphs.</p>
<ul>
<li><a href="1_introduction/../10_sample_workflow/10-1_getting-started-workflows/1-parametric-vase.html">Parametric Vase</a></li>
</ul>
<p><img src="1_introduction/../10_sample_workflow/images/10-1/1/vase1(3).gif" alt="" /></p>
<ul>
<li><a href="1_introduction/../10_sample_workflow/10-1_getting-started-workflows/2-attractor-points.html">Attractor points</a></li>
</ul>
<p><img src="1_introduction/images/1-2/attractor1.gif" alt="" /></p>
<p>{% hint style=&quot;info&quot; %}
There are more topic specific exercises can be found in later chapters as we cover different topics about Dynamo. <strong>Exercises</strong> can usually be found in the last section of each page.
{% endhint %}</p>
<h3 id="the-community"><a class="header" href="#the-community">The Community</a></h3>
<p>Dynamo wouldn't be what it is without a strong group of avid users and active contributors. Engage the community by following the <a href="http://dynamobim.org/blog/">Blog</a>, adding your work to the Gallery, or discussing Dynamo in the <a href="https://forum.dynamobim.com">Forum</a>.</p>
<p><img src="1_introduction/images/1-2/02-Community.png" alt="The Forum" /></p>
<h3 id="the-platform"><a class="header" href="#the-platform">The Platform</a></h3>
<p>Dynamo is envisioned as a visual programming tool for designers, allowing us to make tools that make use of external libraries or any Autodesk product that has an API. With Dynamo Sandbox we can develop programs in a &quot;Sandbox&quot; style application - but the Dynamo ecosystem continues to grow.</p>
<p>The source code for the project is open-source, enabling us to extend its functionality to our hearts content. Check out the project on GitHub and browse the Works in Progress of users customizing Dynamo.</p>
<p><img src="1_introduction/images/1-2/03-TheRepo.png" alt="The Repo" /></p>
<blockquote>
<p>Browse, Fork, and start extending Dynamo for your needs</p>
</blockquote>
<div style="break-before: page; page-break-before: always;"></div><h1 id="setup-for-dynamo"><a class="header" href="#setup-for-dynamo">Setup for Dynamo</a></h1>
<h3 id="dynamo-as-extension-vs-dynamo-sandbox"><a class="header" href="#dynamo-as-extension-vs-dynamo-sandbox">Dynamo as Extension vs Dynamo Sandbox</a></h3>
<p>Dynamo is an active open-source development project. Find out the <a href="http://dynamobim.org/download/">list of software that supports Dynamo</a>.</p>
<p><img src="2_setup_for_dynamo/images/setupfordynamo-dynamorevit.png" alt="" /> <img src="2_setup_for_dynamo/images/setupfordynamo-dynamocivil3D.png" alt="" /> <img src="2_setup_for_dynamo/images/setupfordynamo-dynamoaliasdesign.png" alt="" /> <img src="2_setup_for_dynamo/images/setupfordynamo-dynamoformit.png" alt="" /> <img src="2_setup_for_dynamo/images/setupfordynamo-dynamoadvancesteel.png" alt="" /> <img src="2_setup_for_dynamo/images/setupfordynamo-dynamorobotstructuralanalysis.png" alt="" /></p>
<h3 id="launch-dynamo-as-extension"><a class="header" href="#launch-dynamo-as-extension">Launch Dynamo as Extension</a></h3>
<p>Dynamo comes pre-installed with software such as <strong>Revit3D</strong>, <strong>FormIt</strong>, <strong>Civil3D</strong> and etc.</p>
<p>To start using, launch it from your toolbar panel. Depends on which software you are using, the launch icon can usually be found from the Menu &gt; <strong>Manage</strong> Tab. Click on Dynamo icon <img src="2_setup_for_dynamo/images/dynamoCore-halfSize.png" alt="" /> to launch it.</p>
<p><img src="2_setup_for_dynamo/images/launchdynamofromrevit.jpg" alt="" /></p>
<p>For more guidance on using Dynamo with a specific software, we recommend referring to the following sections:</p>
<ul>
<li><a href="2_setup_for_dynamo/../7_dynamo_for_revit/">Dynamo for Revit</a></li>
</ul>
<p>If you would like to use Dynamo as a standalone application. Continue reading for guidance on downloading the Sandbox.</p>
<h3 id="get-dynamo-sandbox"><a class="header" href="#get-dynamo-sandbox">Get Dynamo Sandbox</a></h3>
<h4 id="download"><a class="header" href="#download">Download</a></h4>
<p>The Dynamo application is available from the <a href="http://dynamobim.com">Dynamo website</a>. Both official, past or pre-released versions are available from the download page. Visit <a href="http://dynamobim.org/download/">Get Dynamo</a> page and Click <strong>Download</strong> for the official released version.</p>
<p><img src="2_setup_for_dynamo/images/dynamo-sandbox(1)%20(1).png" alt="" /></p>
<p>If you are looking for previous or 'bleeding edge' development releases, all versions can be found in the lower section from the same page.</p>
<p><img src="2_setup_for_dynamo/images/DynamoSandboxAllbuilds.jpg" alt="" /></p>
<p>{% hint style=&quot;info&quot; %}
'Bleeding edge' development may include some new and experimental features that are yet to be fully tested, hence may be unstable. By using this, you may discover bugs or issues, help us improve the application by reporting issues to our team.</p>
<p>Beginners are advised to download the official stable release.
{% endhint %}</p>
<h4 id="unzip"><a class="header" href="#unzip">Unzip</a></h4>
<p>Before launching any version you have downloaded, you are required to unzip the content to your chosen folder.</p>
<p>Download and install <a href="https://www.7-zip.org/download.html">7zip</a> to your computer for this step.</p>
<p>Right-click on the zip file and select <strong>Extract All</strong>...</p>
<p><img src="2_setup_for_dynamo/images/02-03Extractzipfile.jpg" alt="" /></p>
<p>Choose a destination to unzip all the files.</p>
<p><img src="2_setup_for_dynamo/images/02-04Extractdestinationfolder.jpg" alt="" /></p>
<h4 id="launching"><a class="header" href="#launching">Launching</a></h4>
<p>In your destination folder, double-click on <strong>DynamoSandbox.exe</strong> to launch it</p>
<p><img src="2_setup_for_dynamo/images/02-05Dynamoexe.jpg" alt="" /></p>
<p>You will see the DynamoSandbox startup screen as follow.</p>
<p><img src="2_setup_for_dynamo/images/02-06Dynamostartupscreen.jpg" alt="" /></p>
<p>Congratulations, you have now finished the setup for using DynamoSandbox!</p>
<p>{% hint style=&quot;info&quot; %}
<strong>Geometry</strong> is an additional functionality in Dynamo Sandbox that is only available to users who have a current subscription or license to the following Autodesk software: Revit, Robot Structural Analysis, FormIt, and Civil 3D. <strong>Geometry</strong> allows users too import, create, edit and export geometry from Dynamo Sandbox.
{% endhint %}</p>
<div style="break-before: page; page-break-before: always;"></div><h1 id="user-interface"><a class="header" href="#user-interface">User Interface</a></h1>
<h3 id="user-interface-overview"><a class="header" href="#user-interface-overview">User Interface Overview</a></h3>
<p>The User Interface (UI) for Dynamo is organized into five main regions. We will briefly cover the overview here and further explain the Workspace and Library in the following sections.</p>
<p><img src="3_user_interface/images/userinterface-ui.jpg" alt="" /></p>
<blockquote>
<ol>
<li>Menus</li>
<li>Toolbar</li>
<li>Library</li>
<li>Workspace</li>
<li>Execution bar</li>
</ol>
</blockquote>
<h3 id="menus"><a class="header" href="#menus">Menus</a></h3>
<p><img src="3_user_interface/../.gitbook/assets/userinterface-menu(1).jpg" alt="" /></p>
<p>Here are Menus for basic functionality of the Dynamo application. Like most Windows software, the first two menus related to managing files, operations for selection and content editing. The remaining menus are more specific to Dynamo.</p>
<h4 id="dynamo-menus"><a class="header" href="#dynamo-menus">Dynamo Menus</a></h4>
<p>General info and settings can be found on the <strong>Dynamo</strong> drop down menu.</p>
<p><img src="3_user_interface/images/userinterface-dynamomenu.jpg" alt="" /></p>
<blockquote>
<ol>
<li>About - Find out the Dynamo version installed on your machine.</li>
<li>Agreement to Collect Usability Data - This allows you to opt-in or out for sharing your user data to improve Dynamo.</li>
<li>Preferences - Includes settings such as define the application's decimal point precision and geometry render quality.</li>
<li>Exit Dynamo</li>
</ol>
</blockquote>
<h4 id="help"><a class="header" href="#help">Help</a></h4>
<p>If you're stuck, check out the <strong>Help</strong> Menu. You may access one of the Dynamo reference websites through your internet browser.</p>
<p><img src="3_user_interface/images/userinterface-helpmenu.jpg" alt="" /></p>
<blockquote>
<ol>
<li>Getting Started - A brief introduction to using Dynamo.</li>
<li>Interactive Guides -</li>
<li>Samples - Reference example files.</li>
<li>Dynamo Dictionary - Resource with documentation on all nodes.</li>
<li>Dynamo Website - View the Dynamo Project on GitHub.</li>
<li>Dynamo Project Wiki - Visit the wiki for learning about development using the Dynamo API, supporting libraries and tools.</li>
<li>Display Start Page - Return to the Dynamo start page when within a document.</li>
<li>Report A Bug - Open an Issue on GitHub.</li>
</ol>
</blockquote>
<h3 id="toolbar"><a class="header" href="#toolbar">Toolbar</a></h3>
<p>Dynamo's Toolbar contains a series of buttons for quick access to working with files as well as Undo [Ctrl + Z] and Redo [Ctrl + Y] commands. On the far right is another button that will export a snapshot of the workspace, which is extremely useful for documentation and sharing.</p>
<ul>
<li><img src="3_user_interface/images/userinterface-newfile.jpg" alt="" /> New - Create a new .dyn file</li>
<li><img src="3_user_interface/images/userinterface-open.jpg" alt="" /> Open - Open an existing .dyn (workspace) or .dyf (custom node) file</li>
<li><img src="3_user_interface/images/userinterface-save.jpg" alt="" /> Save/Save As - Save your active .dyn or .dyf file</li>
<li><img src="3_user_interface/images/userinterface-undo.jpg" alt="" /> Undo - Undo your last action</li>
<li><img src="3_user_interface/images/userinterface-redo.jpg" alt="" /> Redo - Redo the next action</li>
<li><img src="3_user_interface/images/userinterface-screenshot.jpg" alt="" /> Export Workspace as Image - Export the visible workspace as a PNG file</li>
</ul>
<h3 id="library"><a class="header" href="#library">Library</a></h3>
<p>The Dynamo Library is a collection of functional libraries, each Library containing Nodes grouped by Category. It consists basic libraries which are added during default installation of Dynamo, as we continue to introduce its usage, we will demonstrate how to extend the base functionality with Custom Nodes and additional Packages. The <a href="3_user_interface/2-library.html" title="mention">2-library.md</a> section will cover a more detailed guidance on using it.</p>
<p><img src="3_user_interface/images/userinterface-library.jpg" alt="" /></p>
<h3 id="workspace"><a class="header" href="#workspace">Workspace</a></h3>
<p>The Workspace is where we compose our visual programs, you may also change its Preview setting to view the 3D geometries from here. Refer <a href="3_user_interface/1-workspace.html" title="mention">1-workspace.md</a> for more details.</p>
<p><img src="3_user_interface/images/userinterface-workspace.gif" alt="" /></p>
<h3 id="execution-bar"><a class="header" href="#execution-bar">Execution Bar</a></h3>
<p>Run your Dynamo script from here. Click the dropdown icon on the Execution button to change between the different modes.</p>
<p><img src="3_user_interface/images/userinterface-executionbar.gif" alt="" /></p>
<ul>
<li>Automatic: Runs your script automatically. Changes is updated in realtime.</li>
<li>Manual: Script only runs when the 'Run' button is clicked. Useful for when making changes to complicated and 'heavy script'</li>
<li>Periodic: This option is grayed out by default. Only available when the DateTime.Now Node is used. You can set the graph to run automatically at a specified interval.</li>
</ul>
<p><img src="3_user_interface/images/userinterface-executionbarDateTimenode.jpg" alt="" /></p>
<div style="break-before: page; page-break-before: always;"></div><h1 id="workspace-1"><a class="header" href="#workspace-1">Workspace</a></h1>
<h3 id="main-workspace"><a class="header" href="#main-workspace">Main Workspace</a></h3>
<p>The Dynamo Workspace consists of four main elements.</p>
<p><img src="3_user_interface/./images/3-1/workspace-ui.jpg" alt="" /></p>
<blockquote>
<ol>
<li>All Active Tabs.</li>
<li>Preview Mode</li>
<li>Zoom/Pan Controls</li>
<li>Node in Workspace</li>
</ol>
</blockquote>
<h3 id="all-active-tabs"><a class="header" href="#all-active-tabs">All Active Tabs</a></h3>
<p>When you open a new file, a new Home Workspace will be opened by default.</p>
<p><img src="3_user_interface/./images/3-1/workspace-hometab.jpg" alt="" /></p>
<p>You may create a Custom Node and open it in a Custom Node Workspace.</p>
<p><img src="3_user_interface/./images/3-1/workspace-customnodetab.jpg" alt="" /></p>
<p>{% hint style=&quot;info&quot; %}
Only one Home Workspace is allowed in each Dynamo window but you may have multiple Custom Node Workspaces opened in tabs.
{% endhint %}</p>
<h3 id="preview-mode"><a class="header" href="#preview-mode">Preview Mode</a></h3>
<p>There are 3 methods to switch between different previews:</p>
<p>a. Using the top right icons</p>
<ul>
<li><img src="3_user_interface/./images/3-1/3-1-04Graphpreviewicon.jpg" alt="" />Graph Preview</li>
<li><img src="3_user_interface/./images/3-1/3-1-053Dpreviewicon.jpg" alt="" />3D Preview</li>
</ul>
<p>b. Right-click in Workspace</p>
<ul>
<li>Switch from 3D Preview to Graph Preview</li>
</ul>
<p><img src="3_user_interface/./images/3-1/3-1-06rightclickswitchtographpreview.jpg" alt="" /></p>
<ul>
<li>Switch from Graph Preview to 3D Preview</li>
</ul>
<p><img src="3_user_interface/./images/3-1/workspace-rightclickswitchtogeometry.jpg" alt="" /></p>
<p>c. Using keyboard shortcut (Ctrl+B)</p>
<h3 id="zoompan-controls"><a class="header" href="#zoompan-controls">Zoom/Pan Controls</a></h3>
<p>You may use icons or a mouse to navigate in either workspace.</p>
<p>a. In <strong>Graph Preview</strong> Mode</p>
<ul>
<li>Using icons:
<ul>
<li><img src="3_user_interface/./images/3-1/3-1-08graphpreviewzoomtofitpsd.jpg" alt="" />Zoom to fit</li>
<li><img src="3_user_interface/./images/3-1/3-1-09graphpreviewzoomin.jpg" alt="" />Zoom in</li>
<li><img src="3_user_interface/./images/3-1/3-1-10graphpreviewzoomout.jpg" alt="" />Zoom out</li>
<li><img src="3_user_interface/./images/3-1/3-1-11graphpreviewpan.jpg" alt="" />Pan</li>
</ul>
</li>
<li>Using mouse:
<ul>
<li>Left-click - Select</li>
<li>Left-click and drag - Selection box to select multiple nodes</li>
<li>Middle scroll up/down - Zoom in/out</li>
<li>Middle-click and drag - Pan</li>
<li>Right-click anywhere on canvas - Open In-Canvas Search</li>
</ul>
</li>
</ul>
<p><img src="3_user_interface/./images/3-1/workspace-incanvassearch.gif" alt="" /></p>
<p>b. In <strong>3D Preview</strong> Mode</p>
<ul>
<li>Using icons:
<ul>
<li><img src="3_user_interface/./images/3-1/3-1-08graphpreviewzoomtofitpsd.jpg" alt="" />Zoom to fit</li>
<li><img src="3_user_interface/./images/3-1/3-1-09graphpreviewzoomin.jpg" alt="" />Zoom in</li>
<li><img src="3_user_interface/./images/3-1/3-1-10graphpreviewzoomout.jpg" alt="" />Zoom out</li>
<li><img src="3_user_interface/./images/3-1/3-1-11graphpreviewpan.jpg" alt="" />Pan</li>
<li><img src="3_user_interface/./images/3-1/3-1-133Dprevieworbit.jpg" alt="" />Orbit</li>
</ul>
</li>
<li>Using mouse:
<ul>
<li>Middle scroll up/down - Zoom in/out</li>
<li>Middle-click and drag - Pan</li>
<li>Right-click and drag - Orbit</li>
</ul>
</li>
</ul>
<h3 id="node-in-workspace"><a class="header" href="#node-in-workspace">Node in Workspace</a></h3>
<p>Left-click to select any Node.</p>
<p>To select multiple Nodes, Click and drag to create a selection box.</p>
<p><img src="3_user_interface/./images/3-1/workspace-selectionbox.gif" alt="" /></p>
<div style="break-before: page; page-break-before: always;"></div><h1 id="library-1"><a class="header" href="#library-1">Library</a></h1>
<p>The Library contains all of the loaded Nodes, including the ten default categories Nodes that come with the installation as well as any additionally loaded Custom Nodes or Packages. The Nodes in the Library are organized hierarchically within libraries, categories, and, where appropriate, subcategories.</p>
<p><img src="3_user_interface/images/3-2/library-libraryUI.jpg" alt="" /></p>
<ul>
<li>Basic Nodes: Comes with default installation.</li>
<li>Custom Nodes: Store your frequently used routines or special graph as Custom Nodes. You can also share your Custom Nodes with the community</li>
<li>Nodes from the Package Manager: Collection of published Custom Nodes.</li>
</ul>
<p>We will go through the <a href="3_user_interface/3-3_dynamo_libraries.html#library-hierarchy-for-categories">hierarchy of Nodes</a> categories, show how you can <a href="3_user_interface/3-3_dynamo_libraries.html#quick-search-in-library">search quickly from the library</a> and learn about some of the <a href="3_user_interface/3-3_dynamo_libraries.html#frequently-used-nodes">frequently used Nodes</a> among them.</p>
<h3 id="library-hierarchy-for-categories"><a class="header" href="#library-hierarchy-for-categories">Library Hierarchy for Categories</a></h3>
<p>Browsing through these categories is the fastest way to understand the hierarchy of what we can add to our Workspace and the best way to discover new Nodes you haven't used before.</p>
<p>Browse the Library by clicking through the menus to expand each category and its subcategory</p>
<p>{% hint style=&quot;info&quot; %}
Geometry are great menus to begin exploring as they contain the largest quantity of Nodes.
{% endhint %}</p>
<p><img src="3_user_interface/images/3-2/library-modifiedandresizelibrarycategories.jpg" alt="" /></p>
<blockquote>
<ol>
<li>Library</li>
<li>Category</li>
<li>Subcategory</li>
<li>Node</li>
</ol>
</blockquote>
<p>These further categorize the Nodes among same subcategory based on whether the Nodes <strong>Create</strong> data, execute an <strong>Action</strong>, or <strong>Query</strong> data.</p>
<ul>
<li><img src="3_user_interface/images/3-2/userinterface-create.jpg" alt="" /> <strong>Create</strong>: Create or construct a geometry from scratch. E.g a circle.</li>
<li><img src="3_user_interface/images/3-2/userinterface-action.jpg" alt="" /> <strong>Action</strong>: Perform an action on an object. E.g scaling a circle.</li>
<li><img src="3_user_interface/images/3-2/userinterface-query.jpg" alt="" /> <strong>Query</strong>: Get a property of an object that already exists. E.g get the radius of a circle.</li>
</ul>
<p>Hover your mouse over a Node to reveal more detailed information beyond its name and icon. This offers us a quick way to understand what the Node does, what it will require for inputs, and what it will give as an output.</p>
<p><img src="3_user_interface/images/3-2/userinterface-nodedescription.jpg" alt="" /></p>
<blockquote>
<ol>
<li>Description - plain language description of the Node</li>
<li>Icon - larger version of the icon in the Library Menu</li>
<li>Input(s) - name, data type, and data structure</li>
<li>Output(s) - data type and structure</li>
</ol>
</blockquote>
<h3 id="quick-search-in-library"><a class="header" href="#quick-search-in-library">Quick search in Library</a></h3>
<p>If you know with relative specificity which Node you want to add to your Workspace, type in the <strong>Search</strong> field to look up all matching Nodes.</p>
<p>Choose by clicking on the Node you wish to add or hit Enter to add highlighted nodes to the center of the Workspace.</p>
<p><img src="3_user_interface/images/3-2/userinterface-search.jpg" alt="" /></p>
<h4 id="search-by-hierarchy"><a class="header" href="#search-by-hierarchy">Search by hierarchy</a></h4>
<p>Beyond using keywords to try to find Nodes, we can type the hierarchy separated with a period in the Search Field or with Code Blocks (which use the <em>Dynamo textual language</em>).</p>
<p>The hierarchy of each library is reflected in the Name of Nodes added to the Workspace.</p>
<p>Typing in different portions of the Node's place in the Library hierarchy in the <code>library.category.nodeName</code> format returns different results</p>
<ul>
<li><code>library.category.nodeName</code></li>
</ul>
<p><img src="3_user_interface/images/3-2/library-searchbyhierarchygeometrypointbycoordinates(1)%20(1).jpg" alt="" /></p>
<ul>
<li><code>category.nodeName</code></li>
</ul>
<p><img src="3_user_interface/images/3-2/library-searchbyhierarchy2pointbycoordinates.jpg" alt="" /></p>
<ul>
<li><code>nodeName</code> or <code>keyword</code></li>
</ul>
<p><img src="3_user_interface/images/3-2/library-searchbyhierarchy3bycoordinates.jpg" alt="" /></p>
<p>Typically the Name of the Node in the Workspace will be rendered in the <code>category.nodeName</code> format, with some notable exceptions particularly in the Input and View Categories.</p>
<p>Beware of similarly named Nodes and note the category difference:</p>
<ul>
<li>Nodes from most libraries will include the category format</li>
</ul>
<p><img src="3_user_interface/images/3-2/library-nodecategorydifferences1.jpg" alt="" /></p>
<ul>
<li><code>Point.ByCoordinates</code> and <code>UV.ByCoordinates</code> have the same Name but come from different categories</li>
</ul>
<p><img src="3_user_interface/images/3-2/library-nodecategorydifferences2.jpg" alt="" /></p>
<ul>
<li>Notable exceptions include Built-in Functions, Core.Input, Core.View, and Operators</li>
</ul>
<p><img src="3_user_interface/images/3-2/library-nodecategorydifferences3.jpg" alt="" /></p>
<h3 id="frequently-used-nodes"><a class="header" href="#frequently-used-nodes">Frequently Used Nodes</a></h3>
<p>With hundreds of Nodes included in the basic installation of Dynamo, which ones are essential for developing our Visual Programs? Let's focus on those that let us define our program's parameters (<strong>Input</strong>), see the results of a Node's action (<strong>Watch</strong>), and define inputs or functionality by way of a shortcut (<strong>Code Block</strong>).</p>
<h4 id="input-nodes"><a class="header" href="#input-nodes">Input Nodes</a></h4>
<p>Input Nodes are the primary means for the User of our Visual Program - be that yourself or someone else - to interface with the key parameters. Here are some available from the Core Library:</p>
<div class="table-wrapper"><table><thead><tr><th>Node</th><th></th><th>Node</th><th></th></tr></thead><tbody>
<tr><td>Boolean</td><td><img src="3_user_interface/images/3-2/library-boolean.jpg" alt="" /></td><td>Number</td><td><img src="3_user_interface/images/3-2/library-number.jpg" alt="" /></td></tr>
<tr><td>String</td><td><img src="3_user_interface/images/3-2/library-string.jpg" alt="" /></td><td>Number Slider</td><td><img src="3_user_interface/images/3-2/library-numberslider.jpg" alt="" /></td></tr>
<tr><td>Directory Path</td><td><img src="3_user_interface/images/3-2/library-directorypath.jpg" alt="" /></td><td>Integer Slider</td><td><img src="3_user_interface/images/3-2/library-integerslider.jpg" alt="" /></td></tr>
<tr><td>File Path</td><td><img src="3_user_interface/images/3-2/library-filepath.jpg" alt="" /></td><td></td><td></td></tr>
</tbody></table>
</div>
<h4 id="watch--watch3d"><a class="header" href="#watch--watch3d">Watch &amp; Watch3D</a></h4>
<p>The Watch Nodes are essential to managing the data that is flowing through your Visual Program. You can view the result of a Node through the <strong>Node data preview</strong> by hovering your mouse over the node.</p>
<p><img src="3_user_interface/images/3-2/library-nodepreview.jpg" alt="" /></p>
<p>It will be useful to keep it revealed in a <strong>Watch</strong> Node</p>
<p><img src="3_user_interface/images/3-2/library-watchnode.jpg" alt="" /></p>
<p>Or see the geometry results through a <strong>Watch3D</strong> Node.</p>
<p><img src="3_user_interface/images/3-2/library-watch3dnode.gif" alt="" /></p>
<p>Both of these are found in the View Category in the Core Library.</p>
<p>{% hint style=&quot;info&quot; %}
Tip: Occasionally the 3D Preview can be distracting when your Visual Program contains a lot of Nodes. Consider unchecking the Showing Background Preview option in the Settings Menu and using a Watch3D Node to preview your geometry.
{% endhint %}</p>
<h4 id="code-block"><a class="header" href="#code-block">Code Block</a></h4>
<p>Code Block Nodes can be used to define a block of code with lines separated by semi-colons. This can be as simple as <code>X/Y</code>.</p>
<p>We can also use Code Blocks as a shortcut to defining a Number Input or call to another Node's functionality. The syntax to do so follows the Naming Convention of the Dynamo textual language, <a href="3_user_interface/../coding-in-dynamo/7_code-blocks-and-design-script/7-2_design-script-syntax.html">DesignScript</a>.</p>
<p>Here is a simple demonstration (with instructions) for using Code Block in your script.</p>
<p><img src="3_user_interface/images/3-2/library-codeblockdemo.gif" alt="" /></p>
<ol>
<li>Double-click to create a Code Block Node</li>
<li>Type <code>Circle.ByCenterPointRadius(x,y);</code></li>
<li>Click on Workspace to clear the selection should add <code>x</code> and <code>y</code> inputs automatically.</li>
<li>Create a Point.ByCoordinates Node and a Number Slider then connect them to the inputs of the Code Block.</li>
<li>The result of the executing the Visual Program is shown as the circle in the 3D Preview</li>
</ol>
<div style="break-before: page; page-break-before: always;"></div><h1 id="nodes-and-wires"><a class="header" href="#nodes-and-wires">Nodes and Wires</a></h1>
<h2 id="nodes"><a class="header" href="#nodes">Nodes</a></h2>
<p>In Dynamo, <strong>Nodes</strong> are the objects you connect to form a Visual Program. Each <strong>Node</strong> performs an operation - sometimes that may be as simple as storing a number or it may be a more complex action such as creating or querying geometry.</p>
<h3 id="anatomy-of-a-node"><a class="header" href="#anatomy-of-a-node">Anatomy of a Node</a></h3>
<p>Most Nodes in Dynamo are composed of five parts. While there are exceptions, such as Input Nodes, the anatomy of each Node can be described as follows:</p>
<p><img src="4_nodes_and_wires/images/nodesandwires-nodesanatomy.jpg" alt="" /></p>
<blockquote>
<ol>
<li>Name - The Name of the Node with a <code>Category.Name</code> naming convention</li>
<li>Main body - The main body of the Node - Right-clicking here presents options at the level of the whole Node</li>
<li>Ports (In and Out) - The receptors for Wires that supply the input data to the Node as well as the results of the Node's action</li>
<li>Default Value - Right-click on an input Port - some Nodes have default values that can be used or not used.</li>
<li>Lacing Icon - Indicates the <a href="4_nodes_and_wires/../5_essential_nodes_and_concepts/5-4_designing-with-lists/1-whats-a-list.html#lacing">Lacing option</a> specified for matching list inputs (more on that later)</li>
</ol>
</blockquote>
<h3 id="nodes-inputoutput-ports"><a class="header" href="#nodes-inputoutput-ports">Nodes Input/Output Ports</a></h3>
<p>The Inputs and Outputs for Nodes are called Ports and act as the receptors for Wires. Data comes into the Node through Ports on the left and flows out of the Node after it has executed its operation on the right.</p>
<p>Ports expect to receive data of a certain type. For instance, connecting a number such as <em>2.75</em> to the Ports on a Point By Coordinates Node will successfully result in creating a Point; however, if we supply <em>&quot;Red&quot;</em> to the same Port it will result in an error.</p>
<p>{% hint style=&quot;info&quot; %}
Tip: Hover over a Port to see a tooltip containing the data type expected.
{% endhint %}</p>
<p><img src="4_nodes_and_wires/images/nodesandwires-nodesinputandtooltip.jpg" alt="" /></p>
<blockquote>
<ol>
<li>Port Label</li>
<li>Tool Tip</li>
<li>Data Type</li>
<li>Default Value</li>
</ol>
</blockquote>
<h3 id="node-states"><a class="header" href="#node-states">Node States</a></h3>
<p>Dynamo gives an indication of the state of the execution of your Visual Program by rendering Nodes with different color schemes based on each Node's status. The hierarchy of states follows this sequence: Error &gt; Warning &gt; Info &gt; Preview.</p>
<p>Hovering or right-clicking over the Name or Ports presents additional information and options.</p>
<p><img src="4_nodes_and_wires/../.gitbook/assets/nodesandwires-nodestates.png" alt="" /></p>
<blockquote>
<ol>
<li>Satisfied inputs - A node with blue vertical bars over its input ports is well-connected and has all of its inputs successfully connected.</li>
<li>Unsatisfied inputs  A node with a red vertical bar over one or more input ports needs to have those inputs connected.</li>
<li>Function  A node that outputs a function and has a gray vertical bar over an output port is a function node.</li>
<li>Selected - Currently selected nodes have an aqua highlight around their border.</li>
<li>Frozen - A translucent blue node is frozen, suspending the execution of the node.</li>
<li>Preview off - A gray status bar underneath the node and an eye icon <img src="4_nodes_and_wires/images/nodesandwires-previewoff.jpg" alt="" data-size="line"> indicate that geometry preview for the node is switched off.</li>
<li>Warning - A yellow status bar underneath the node indicates Warning state, meaning the node either lacks input data or may have incorrect data types.</li>
<li>Error - A red status bar underneath the node indicates that the node is in an Error state.</li>
<li>Info - Blue status bar underneath the node indicates Info state, which flags useful information about nodes. This state can be triggered when approaching a maximum value supported by the node, using a node in a way that has potential performance impacts, etc.</li>
</ol>
</blockquote>
<h4 id="handling-error-or-warning-nodes"><a class="header" href="#handling-error-or-warning-nodes">Handling Error or Warning Nodes</a></h4>
<p>If your Visual Program contains warning or errors, Dynamo will provide additional information about the problem. Any Node that is Yellow will also have a tooltip above the Name. Hover your mouse over the warning <img src="4_nodes_and_wires/images/nodesandwires-nodewarningicon.png" alt="" /> or error <img src="4_nodes_and_wires/images/nodesandwires-nodeerroricon.png" alt="" /> tooltip icon to expand it.</p>
<p>{% hint style=&quot;info&quot; %}
Tip: With this tooltip information in hand, examine the upstream Nodes to see if the data type or data structure required is in error.
{% endhint %}</p>
<p><img src="4_nodes_and_wires/images/nodesandwires-nodeswithwarningtooltip.jpg" alt="" /></p>
<blockquote>
<ol>
<li>Warning Tooltip - &quot;Null&quot; or no data cannot be understood as a Double, i.e., a number</li>
<li>Use the Watch Node to examine the input data</li>
<li>Upstream the Number Node is storing &quot;Red,&quot; not a number</li>
</ol>
</blockquote>
<h2 id="wires"><a class="header" href="#wires">Wires</a></h2>
<p>Wires connect between Nodes to create relationships and establish the Flow of our Visual Program. We can think of them literally as electrical wires that carry pulses of data from one object to the next.</p>
<h3 id="program-flow"><a class="header" href="#program-flow">Program Flow <a href="4_nodes_and_wires/index.html#program-flow" id="program-flow"></a></a></h3>
<p>Wires connect the output Port from one Node to the input Port of another Node. This directionality establishes the <strong>Flow of Data</strong> in the Visual Program.</p>
<p>Input Ports are on the left side and the Output Ports are located on the right side of Nodes, hence, we can generally say that the Program Flow moves from left to right.</p>
<p><img src="4_nodes_and_wires/images/nodesandwires-flowofdata.jpg" alt="" /></p>
<h3 id="creating-wires"><a class="header" href="#creating-wires">Creating Wires <a href="4_nodes_and_wires/index.html#creating-wires" id="creating-wires"></a></a></h3>
<p>Create a Wire by left-click on a Port subsequently left-click on the port of another Node to create a connection. While we are in the process of making a connection, the Wire will appear dashed and will snap to become solid lines when successfully connected.</p>
<p>The data will always flow through this Wire from output to input; however, we may create the wire in either direction in terms of the sequence of clicking on the connected Ports.</p>
<p><img src="4_nodes_and_wires/images/nodesandwires-creatingawire.gif" alt="" /></p>
<h3 id="editing-wires"><a class="header" href="#editing-wires">Editing Wires <a href="4_nodes_and_wires/index.html#editing-wires" id="editing-wires"></a></a></h3>
<p>Frequently we will want to adjust the Program Flow in our Visual Program by editing the connections represented by the Wires. To edit a Wire, left click on the input Port of the Node that is already connected. You now have two options:</p>
<ul>
<li>Change connection to an input Port, left-click on another input Port</li>
</ul>
<p><img src="4_nodes_and_wires/images/nodesandwires-editwirechangeport(2).gif" alt="" /></p>
<ul>
<li>To remove the Wire, pull the Wire away and left-click on Workspace</li>
</ul>
<p><img src="4_nodes_and_wires/images/nodesandwires-editwiresremove.gif" alt="" /></p>
<ul>
<li>Reconnect multiple wires using Shift+left-click</li>
</ul>
<p><img src="4_nodes_and_wires/images/nodesandwires-editmultiports.gif" alt="" /></p>
<ul>
<li>Duplicate a wire using Ctrl+left-click</li>
</ul>
<p><img src="4_nodes_and_wires/images/nodesandwires-duplicatewire.gif" alt="" /></p>
<h4 id="default-vs-highlighted-wires"><a class="header" href="#default-vs-highlighted-wires">Default vs Highlighted Wires <a href="4_nodes_and_wires/index.html#wire-previews" id="wire-previews"></a></a></h4>
<p>By default, our Wires will be previewed with a gray stroke. When a Node is selected, it will render any connecting Wire with the same aqua highlight as the Node.</p>
<p><img src="4_nodes_and_wires/images/nodesandwires-defaultvshighlightedwires.jpg" alt="" /></p>
<blockquote>
<ol>
<li>Highlighted Wire</li>
<li>Default Wire</li>
</ol>
</blockquote>
<p><strong>Hide Wires by Default</strong></p>
<p>In case you prefer to hide the Wires in your graph, you can find this option from View &gt; Connectors &gt; untick Show Connectors.</p>
<p>With this setting, only the selected Nodes and its joining Wires will be shown in faint aqua highlight.</p>
<p><img src="4_nodes_and_wires/images/nodesandwires-hidewiressetting(1).gif" alt="" /></p>
<h4 id="hide-individual-wire-only"><a class="header" href="#hide-individual-wire-only">Hide Individual Wire Only</a></h4>
<p>You can also hide selected wire only by Right-clicking on the Nodes output &gt; select Hide Wires</p>
<p><img src="4_nodes_and_wires/images/nodesandwires-hideselectedwire.gif" alt="" /></p>
<div style="break-before: page; page-break-before: always;"></div><h1 id="essential-nodes--concepts"><a class="header" href="#essential-nodes--concepts">Essential Nodes &amp; Concepts</a></h1>
<p>In this section, we introduce the essential Nodes available in the Dynamo Library that will help you create your own visual program like a pro.</p>
<ul>
<li><a href="5_essential_nodes_and_concepts/5-2_geometry-for-computational-design/">Geometry for Computational Design</a>: How do I work with geometric elements in Dynamo? Explore multiple ways to create simple or complex geometries from primitives.</li>
<li><a href="5_essential_nodes_and_concepts/5-3_the-building-blocks-of-programs/">The Building Blocks of Programs:</a> What is &quot;Data&quot; and what are some fundamental types I can start using in my programs? Also, learn more about incorporating math and logic operations in your design workflow.</li>
<li><a href="5_essential_nodes_and_concepts/5-4_designing-with-lists/">Designing with Lists: </a>How do I manage and coordinate my data structures? Understand more about the concept of List and use it to manage your design data efficiently.</li>
<li><a href="5_essential_nodes_and_concepts/5-5_dictionaries-in-dynamo/">Dictionaries in Dynamo: </a>What are Dictionaries? Find out how to use dictionaries to look up specific data and values from existing results.</li>
</ul>
<div style="break-before: page; page-break-before: always;"></div><h1 id="index-of-nodes"><a class="header" href="#index-of-nodes">Index of Nodes</a></h1>
<p>This index provides additional information on all the nodes used in this primer, as well as other components you might find useful. This is just an introduction to some of the 500 nodes available in Dynamo.</p>
<h2 id="display"><a class="header" href="#display">Display</a></h2>
<h3 id="color"><a class="header" href="#color">Color</a></h3>
<div class="table-wrapper"><table><thead><tr><th></th><th></th><th></th></tr></thead><tbody>
<tr><td></td><td>CREATE</td><td></td></tr>
<tr><td><img src="5_essential_nodes_and_concepts/images/5-1/ColorbyARGB%20(1).jpg" alt="" /></td><td><p><strong>Color.ByARGB</strong><br>Construct a color by alpha, red, green, and blue components.</p></td><td><img src="5_essential_nodes_and_concepts/images/5-1/indexofnodes-colorbyargb(1).jpg" alt="" /></td></tr>
<tr><td><img src="5_essential_nodes_and_concepts/images/5-1/ColorRange.jpg" alt="" /></td><td><p><strong>Color Range</strong><br>Get a color from a color gradient between a start color and an end color.</p></td><td><img src="5_essential_nodes_and_concepts/images/5-1/indexofnodes-colorrange(1)%20(1).jpg" alt="" /></td></tr>
<tr><td></td><td>ACTIONS</td><td></td></tr>
<tr><td><img src="5_essential_nodes_and_concepts/images/5-1/ColorBrightness%20(1).jpg" alt="" /></td><td><p><strong>Color.Brightness</strong><br>Gets the brightness value for this color.</p></td><td><img src="5_essential_nodes_and_concepts/images/5-1/indexofnodes-colorbrightness(1)%20(1).jpg" alt="" /></td></tr>
<tr><td><img src="5_essential_nodes_and_concepts/images/5-1/ColorComponent.jpg" alt="" /></td><td><p><strong>Color.Components</strong><br>Lists the components for the color in the order: alpha, red, green, blue.</p></td><td><img src="5_essential_nodes_and_concepts/images/5-1/indexofnodes-colorcomponent.jpg" alt="" /></td></tr>
<tr><td><img src="5_essential_nodes_and_concepts/images/5-1/ColorSaturation%20(1).jpg" alt="" /></td><td><p><strong>Color.Saturation</strong><br>Gets the saturation value for this color</p></td><td><img src="5_essential_nodes_and_concepts/images/5-1/indexofnodes-colorsaturation.jpg" alt="" /></td></tr>
<tr><td><img src="5_essential_nodes_and_concepts/images/5-1/ColorHue.jpg" alt="" /></td><td><p><strong>Color.Hue</strong><br>Gets the hue value for this color.</p></td><td><img src="5_essential_nodes_and_concepts/images/5-1/indexofnodes-colorhue.jpg" alt="" /></td></tr>
<tr><td></td><td>QUERY</td><td></td></tr>
<tr><td><img src="5_essential_nodes_and_concepts/images/5-1/ColorAlpha(1)(1).jpg" alt="" /></td><td><p><strong>Color.Alpha</strong><br>Find the alpha component of a color, 0 to 255.</p></td><td><img src="5_essential_nodes_and_concepts/images/5-1/indexofnodes-coloralpha.jpg" alt="" /></td></tr>
<tr><td><img src="5_essential_nodes_and_concepts/images/5-1/ColorBlue%20(1).jpg" alt="" /></td><td><p><strong>Color.Blue</strong><br>Find the blue component of a color, 0 to 255.</p></td><td><img src="5_essential_nodes_and_concepts/images/5-1/indexofnodes-colorblue.jpg" alt="" /></td></tr>
<tr><td><img src="5_essential_nodes_and_concepts/images/5-1/ColorGreen(1)(1)%20(3).jpg" alt="" /></td><td><p><strong>Color.Green</strong><br>Find the green component of a color, 0 to 255.</p></td><td><img src="5_essential_nodes_and_concepts/images/5-1/indexofnodes-colorgreen.jpg" alt="" /></td></tr>
<tr><td><img src="5_essential_nodes_and_concepts/images/5-1/ColorRed.jpg" alt="" /></td><td><p><strong>Color.Red</strong><br>Find the red component of a color, 0 to 255.</p></td><td><img src="5_essential_nodes_and_concepts/images/5-1/indexofnodes-colorred.jpg" alt="" /></td></tr>
</tbody></table>
</div><div class="table-wrapper"><table><thead><tr><th></th><th></th><th></th></tr></thead><tbody>
<tr><td></td><td>CREATE</td><td></td></tr>
<tr><td><img src="5_essential_nodes_and_concepts/images/5-1/GeometryColorByGeometryColor(1).jpg" alt="" /></td><td><p><strong>GeometryColor.ByGeometryColor</strong><br>Displays geometry using a color.</p></td><td><img src="5_essential_nodes_and_concepts/images/5-1/indexofnodes-geometrycolorbygeometrycolor.jpg" alt="" /></td></tr>
</tbody></table>
</div>
<h3 id="watch"><a class="header" href="#watch">Watch</a></h3>
<div class="table-wrapper"><table><thead><tr><th></th><th></th><th></th></tr></thead><tbody>
<tr><td></td><td>ACTIONS</td><td></td></tr>
<tr><td><img src="5_essential_nodes_and_concepts/images/5-1/Viewwatch.jpg" alt="" /></td><td><p><strong>View.Watch</strong><br>Visualize the output of node.</p></td><td><img src="5_essential_nodes_and_concepts/images/5-1/indexofnodes-viewwatch.jpg" alt="" /></td></tr>
<tr><td><img src="5_essential_nodes_and_concepts/images/5-1/Viewwatch3d.jpg" alt="" /></td><td><p><strong>View.Watch 3D</strong><br>Shows a dynamic preview of geometry.</p></td><td><img src="5_essential_nodes_and_concepts/images/5-1/indexofnodes-viewwatch.3Djpg.jpg" alt="" /></td></tr>
</tbody></table>
</div>
<h2 id="input"><a class="header" href="#input">Input</a></h2>
<div class="table-wrapper"><table><thead><tr><th></th><th></th><th></th></tr></thead><tbody>
<tr><td></td><td>ACTIONS</td><td></td></tr>
<tr><td><img src="5_essential_nodes_and_concepts/images/5-1/Boolean.jpg" alt="" /></td><td><p><strong>Boolean</strong><br>Selection between a true and false.</p></td><td><img src="5_essential_nodes_and_concepts/images/5-1/indexofnodes-boolean.jpg" alt="" /></td></tr>
<tr><td><img src="5_essential_nodes_and_concepts/images/5-1/CodeBlock(1)(1).jpg" alt="" /></td><td><p><strong>Code Block</strong><br>Allows for DesignScript code to be authored directly.</p></td><td><img src="5_essential_nodes_and_concepts/images/5-1/indexofnodes-codeblock.jpg" alt="" /></td></tr>
<tr><td><img src="5_essential_nodes_and_concepts/images/5-1/DirectoryPath.jpg" alt="" /></td><td><p><strong>Directory Path</strong><br>Allows you to select a directory on the system to get its path</p></td><td><img src="5_essential_nodes_and_concepts/images/5-1/indexofnodes-directorypath.jpg" alt="" /></td></tr>
<tr><td><img src="5_essential_nodes_and_concepts/images/5-1/FilePath.jpg" alt="" /></td><td><p><strong>File Path</strong><br>Allows you to select a file on the system to get its filenam</p></td><td><img src="5_essential_nodes_and_concepts/images/5-1/indexofnodes-filepath.jpg" alt="" /></td></tr>
<tr><td><img src="5_essential_nodes_and_concepts/images/5-1/Integerslider.jpg" alt="" /></td><td><p><strong>Integer Slider</strong><br>A slider that produces integer values.</p></td><td><img src="5_essential_nodes_and_concepts/images/5-1/indexofnodes-integerslider.jpg" alt="" /></td></tr>
<tr><td><img src="5_essential_nodes_and_concepts/images/5-1/number.jpg" alt="" /></td><td><p><strong>Number</strong><br>Creates a number.</p></td><td><img src="5_essential_nodes_and_concepts/images/5-1/indexofnodes-number(1)%20(1).jpg" alt="" /></td></tr>
<tr><td><img src="5_essential_nodes_and_concepts/images/5-1/Numberslider.jpg" alt="" /></td><td><p><strong>Number Slider</strong><br>A slider that produces numeric values.</p></td><td><img src="5_essential_nodes_and_concepts/images/5-1/indexofnodes-numberslider.jpg" alt="" /></td></tr>
<tr><td><img src="5_essential_nodes_and_concepts/images/5-1/string.jpg" alt="" /></td><td><p><strong>String</strong><br>Creates a string.</p></td><td><img src="5_essential_nodes_and_concepts/images/5-1/indexofnodes-string.jpg" alt="" /></td></tr>
<tr><td><img src="5_essential_nodes_and_concepts/images/5-1/ObjectisNull.jpg" alt="" /></td><td><p><strong>Object.IsNull</strong><br>Determines if the given object is null.</p></td><td><img src="5_essential_nodes_and_concepts/images/5-1/indexofnodes-objectisnull.jpg" alt="" /></td></tr>
</tbody></table>
</div>
<h2 id="list"><a class="header" href="#list">List</a></h2>
<div class="table-wrapper"><table><thead><tr><th></th><th></th><th></th></tr></thead><tbody>
<tr><td></td><td>CREATE</td><td></td></tr>
<tr><td><img src="5_essential_nodes_and_concepts/images/5-1/ListCreate.jpg" alt="" /></td><td><p><strong>List.Create</strong><br>Makes a new list out of the given inputs.</p></td><td><img src="5_essential_nodes_and_concepts/images/5-1/indexofnodes-listcreate.jpg" alt="" /></td></tr>
<tr><td><img src="5_essential_nodes_and_concepts/images/5-1/ListCombine.jpg" alt="" /></td><td><p><strong>List.Combine</strong><br>Applies a combinator to each element in two sequences</p></td><td><img src="5_essential_nodes_and_concepts/images/5-1/indexofnodes-listcombine.jpg" alt="" /></td></tr>
<tr><td><img src="5_essential_nodes_and_concepts/images/5-1/Range.jpg" alt="" /></td><td><p><strong>Number Range</strong><br>Creates a sequence of numbers in the specified range</p></td><td><img src="5_essential_nodes_and_concepts/images/5-1/indexofnodes-range(1).jpg" alt="" /></td></tr>
<tr><td><img src="5_essential_nodes_and_concepts/images/5-1/Sequence.jpg" alt="" /></td><td><p><strong>Number Sequence</strong><br>Creates a sequence of numbers.</p></td><td><img src="5_essential_nodes_and_concepts/images/5-1/indexofnodes-sequence.jpg" alt="" /></td></tr>
<tr><td></td><td>ACTIONS</td><td></td></tr>
<tr><td><img src="5_essential_nodes_and_concepts/images/5-1/ListChop.jpg" alt="" /></td><td><p><strong>List.Chop</strong><br>Chop a list into a set of lists each containing the given amount of items.</p></td><td><img src="5_essential_nodes_and_concepts/images/5-1/indexofnodes-listchop.jpg" alt="" /></td></tr>
<tr><td><img src="5_essential_nodes_and_concepts/images/5-1/Count(1)%20(1).jpg" alt="" /></td><td><p><strong>List.Count</strong><br>Returns the number of items stored in the given list.</p></td><td><img src="5_essential_nodes_and_concepts/images/5-1/indexofnodes-listcount.jpg" alt="" /></td></tr>
<tr><td><img src="5_essential_nodes_and_concepts/images/5-1/ListFlatten.jpg" alt="" /></td><td><p><strong>List.Flatten</strong><br>Flattens a nested list of lists by a certain amount.</p></td><td><img src="5_essential_nodes_and_concepts/images/5-1/indexofnodes-listflatten.jpg" alt="" /></td></tr>
<tr><td><img src="5_essential_nodes_and_concepts/images/5-1/ListFilterbyBoolMask.jpg" alt="" /></td><td><p><strong>List.FilterByBoolMask</strong><br>Filters a sequence by looking up corresponding indices in a separate list of booleans.</p></td><td><img src="5_essential_nodes_and_concepts/images/5-1/indexofnodes-listfilterbyboolmask.jpg" alt="" /></td></tr>
<tr><td><img src="5_essential_nodes_and_concepts/images/5-1/ListGetItemAtIndex.jpg" alt="" /></td><td><p><strong>List.GetItemAtIndex</strong><br>Gets an item from the given list that's located at the specified index.</p></td><td><img src="5_essential_nodes_and_concepts/images/5-1/indexofnodes-listgetitematindex.jpg" alt="" /></td></tr>
<tr><td></td><td><p><strong>List.Map</strong><br>Applies a function over all elements of a list, generating a new list from the results</p></td><td><img src="5_essential_nodes_and_concepts/images/5-1/indexofnodes-listmap.jpg" alt="" /></td></tr>
<tr><td></td><td><p><strong>List.Reverse</strong><br>Creates a new list containing the items of the given list but in reverse order</p></td><td><img src="5_essential_nodes_and_concepts/images/5-1/indexofnodes-listreverse.jpg" alt="" /></td></tr>
<tr><td><img src="5_essential_nodes_and_concepts/images/5-1/ListReplaceItemAtIndex.jpg" alt="" /></td><td><p><strong>List.ReplaceItemAtIndex</strong><br>Replace an item from the given list that's located at the specified index</p></td><td><img src="5_essential_nodes_and_concepts/images/5-1/indexofnodes-replaceitematindex.jpg" alt="" /></td></tr>
<tr><td><img src="5_essential_nodes_and_concepts/images/5-1/ListShiftIndices.jpg" alt="" /></td><td><p><strong>List.ShiftIndices</strong><br>Shifts indices in the list to the right by the given amount</p></td><td><img src="5_essential_nodes_and_concepts/images/5-1/indexofnodes-listshiftindices.jpg" alt="" /></td></tr>
<tr><td><img src="5_essential_nodes_and_concepts/images/5-1/ListTakeEveryNthItem.jpg" alt="" /></td><td><p><strong>List.TakeEveryNthItem</strong><br>Fetches items from the given list at indices that are multiples of the given value, after the given offset.</p></td><td><img src="5_essential_nodes_and_concepts/images/5-1/indexofnodes-listtakeeverynthitem.jpg" alt="" /></td></tr>
<tr><td><img src="5_essential_nodes_and_concepts/images/5-1/ListTranspose.jpg" alt="" /></td><td><p><strong>List.Transpose</strong><br>Swaps rows and columns in a list of lists. If there are some rows that are shorter than others, null values are inserted as place holders in the resultant array such that it is always rectangular</p></td><td><img src="5_essential_nodes_and_concepts/images/5-1/indexofnodes-listtranspose.jpg" alt="" /></td></tr>
</tbody></table>
</div>
<h2 id="logic"><a class="header" href="#logic">Logic</a></h2>
<div class="table-wrapper"><table><thead><tr><th></th><th></th><th></th></tr></thead><tbody>
<tr><td></td><td>ACTIONS</td><td></td></tr>
<tr><td><img src="5_essential_nodes_and_concepts/images/5-1/If.jpg" alt="" /></td><td><p><strong>If</strong><br>Conditional statement. Checks the boolean value of the test input. If the test input is true, the result outputs the true input, otherwise the result outputs the false input.</p></td><td><img src="5_essential_nodes_and_concepts/images/5-1/indexofnodes-if.jpg" alt="" /></td></tr>
</tbody></table>
</div>
<h2 id="math"><a class="header" href="#math">Math</a></h2>
<div class="table-wrapper"><table><thead><tr><th></th><th></th><th></th></tr></thead><tbody>
<tr><td></td><td>ACTIONS</td><td></td></tr>
<tr><td><img src="5_essential_nodes_and_concepts/images/5-1/Mathcos.jpg" alt="" /></td><td><p><strong>Math.Cos</strong><br>Fines the cosine of an angle.</p></td><td><img src="5_essential_nodes_and_concepts/images/5-1/indexofnodes-mathcos.jpg" alt="" /></td></tr>
<tr><td><img src="5_essential_nodes_and_concepts/images/5-1/Mathdegreestoradians.jpg" alt="" /></td><td><p><strong>Math.DegreesToRadians</strong><br>Converts an angle in degrees to an angle in radians.</p></td><td><img src="5_essential_nodes_and_concepts/images/5-1/indexofnodes-mathdegreestoradians.jpg" alt="" /></td></tr>
<tr><td><img src="5_essential_nodes_and_concepts/images/5-1/Mathpow.jpg" alt="" /></td><td><p><strong>Math.Pow</strong><br>Raises a number to the specified power.</p></td><td><img src="5_essential_nodes_and_concepts/images/5-1/indexofnodes-mathpow.jpg" alt="" /></td></tr>
<tr><td><img src="5_essential_nodes_and_concepts/images/5-1/Mathradianstodegrees.jpg" alt="" /></td><td><p><strong>Math.RadiansToDegrees</strong><br>Converts an angle in radians to an angle in degrees.</p></td><td><img src="5_essential_nodes_and_concepts/images/5-1/indexofnodes-mathradianstodegrees.jpg" alt="" /></td></tr>
<tr><td><img src="5_essential_nodes_and_concepts/images/5-1/Mathremaprange.jpg" alt="" /></td><td><p><strong>Math.RemapRange</strong><br>Adjusts the range of a list of numbers while preserving the distribution ratio.</p></td><td><img src="5_essential_nodes_and_concepts/images/5-1/indexofnodes-mathremaprange.jpg" alt="" /></td></tr>
<tr><td><img src="5_essential_nodes_and_concepts/images/5-1/Mathsin.jpg" alt="" /></td><td><p><strong>Math.Sin</strong><br>Finds the sine of an angle.</p></td><td><img src="5_essential_nodes_and_concepts/images/5-1/indexofnodes-mathsin.jpg" alt="" /></td></tr>
<tr><td><img src="5_essential_nodes_and_concepts/images/5-1/Formula.jpg" alt="" /></td><td><p><strong>Formula</strong><br>Evaluates mathematical formulas. Uses NCalc for evaluation. See http://ncalc.codeplex.com</p></td><td><img src="5_essential_nodes_and_concepts/images/5-1/indexofnodes-formula.jpg" alt="" /></td></tr>
<tr><td><img src="5_essential_nodes_and_concepts/images/5-1/Map(1)%20(1).jpg" alt="" /></td><td><p><strong>Map</strong><br>Maps a value into an input range</p></td><td><img src="5_essential_nodes_and_concepts/images/5-1/indexofnodes-mathmap.jpg" alt="" /></td></tr>
</tbody></table>
</div>
<h2 id="string"><a class="header" href="#string">String</a></h2>
<div class="table-wrapper"><table><thead><tr><th></th><th></th><th></th></tr></thead><tbody>
<tr><td></td><td>ACTIONS</td><td></td></tr>
<tr><td><img src="5_essential_nodes_and_concepts/images/5-1/Stringconcat.jpg" alt="" /></td><td><p><strong>String.Concat</strong><br>Concatenates multiple strings into a single string.</p></td><td><img src="5_essential_nodes_and_concepts/images/5-1/indexofnodes-stringconcat.jpg" alt="" /></td></tr>
<tr><td><img src="5_essential_nodes_and_concepts/images/5-1/Stringcontains.jpg" alt="" /></td><td><p><strong>String.Contains</strong><br>Determines if the given string contains the given substring.</p></td><td><img src="5_essential_nodes_and_concepts/images/5-1/indexofnodes-stringcontains.jpg" alt="" /></td></tr>
<tr><td><img src="5_essential_nodes_and_concepts/images/5-1/Stringjoin.jpg" alt="" /></td><td><p><strong>String.Join</strong><br>Concatenates multiple strings into a single string, inserting the given separator between each joined string.</p></td><td><img src="5_essential_nodes_and_concepts/images/5-1/indexofnodes-stringjoin(1).jpg" alt="" /></td></tr>
<tr><td><img src="5_essential_nodes_and_concepts/images/5-1/Stringsplit.jpg" alt="" /></td><td><p><strong>String.Split</strong><br>Divides a single string into a list of strings, with divisions determined by the given separater strings.</p></td><td><img src="5_essential_nodes_and_concepts/images/5-1/indexofnodes-stringsplit.jpg" alt="" /></td></tr>
<tr><td><img src="5_essential_nodes_and_concepts/images/5-1/Stringtonumber.jpg" alt="" /></td><td><p><strong>String.ToNumber</strong><br>Converts a string to an integer or a double.</p></td><td><img src="5_essential_nodes_and_concepts/images/5-1/indexofnodes-stringtonumber.jpg" alt="" /></td></tr>
</tbody></table>
</div>
<h2 id="geometry"><a class="header" href="#geometry">Geometry</a></h2>
<h3 id="circle"><a class="header" href="#circle">Circle</a></h3>
<div class="table-wrapper"><table><thead><tr><th></th><th></th><th></th></tr></thead><tbody>
<tr><td></td><td>CREATE</td><td></td></tr>
<tr><td><img src="5_essential_nodes_and_concepts/images/5-1/Circlebycenterpointradius.jpg" alt="" /></td><td><p><strong>Circle.ByCenterPointRadius</strong><br>Creates a Circle with input center Point and radius in the world XY plane, with world Z as normal.</p></td><td><img src="5_essential_nodes_and_concepts/images/5-1/indexofnodes-circlebycenterpointradiusnormal.jpg" alt="" /></td></tr>
<tr><td><img src="5_essential_nodes_and_concepts/images/5-1/Circlebyplaneradius.jpg" alt="" /></td><td><p><strong>Circle.ByPlaneRadius</strong><br>Create a Circle centered at the input Plane origin (root), lying in the input Plane, with given radius.</p></td><td><img src="5_essential_nodes_and_concepts/images/5-1/indexofnodes-circlebyplaneradius.jpg" alt="" /></td></tr>
</tbody></table>
</div><div class="table-wrapper"><table><thead><tr><th></th><th></th><th></th></tr></thead><tbody>
<tr><td></td><td>CREATE</td><td></td></tr>
<tr><td><img src="5_essential_nodes_and_concepts/images/5-1/Coordinatesystembyorigin.jpg" alt="" /></td><td><p><strong>CoordinateSystem.ByOrigin</strong><br>Create a CoordinateSystem with origin at input Point, with X and Y Axes set as WCS X and Y axes</p></td><td><img src="5_essential_nodes_and_concepts/images/5-1/indexofnodes-coordinatessystembyorigin.jpg" alt="" /></td></tr>
<tr><td><img src="5_essential_nodes_and_concepts/images/5-1/Coordinatesystembycylindricalcoordinates(1)%20(1).jpg" alt="" /></td><td><p><strong>CoordinateSystem.ByCyclindricalCoordinates</strong><br>Creates a CoordinateSystem at the specified cylindrical coordinate parameters with respet to the specified coordinate system</p></td><td><img src="5_essential_nodes_and_concepts/images/5-1/indexofnodes-coordinatessystembycylindricalcoordinates.jpg" alt="" /></td></tr>
</tbody></table>
</div>
<h3 id="cuboid"><a class="header" href="#cuboid">Cuboid</a></h3>
<div class="table-wrapper"><table><thead><tr><th></th><th></th><th></th></tr></thead><tbody>
<tr><td></td><td>CREATE</td><td></td></tr>
<tr><td><img src="5_essential_nodes_and_concepts/images/5-1/Cuboidbylength(1).jpg" alt="" /></td><td><p><strong>Cuboid.ByLengths</strong><br>Create a Cuboid centered at WCS origin, with width, length, and height.</p></td><td><img src="5_essential_nodes_and_concepts/images/5-1/indexofnodes-cuboidbylengths.jpg" alt="" /></td></tr>
<tr><td><img src="5_essential_nodes_and_concepts/images/5-1/Cuboidbylengthorigin(1)%20(1).jpg" alt="" /></td><td><p><strong>Cuboid.ByLengths</strong> (origin)</p><p>Create a Cuboid centered at input Point, with specified width, length, and height.</p></td><td><img src="5_essential_nodes_and_concepts/images/5-1/indexofnodes-cuboidbylengthsorigin.jpg" alt="" /></td></tr>
<tr><td><img src="5_essential_nodes_and_concepts/images/5-1/Cuboidbylengthcoordinatessystem(1)%20(1).jpg" alt="" /></td><td><p><strong>Cuboid.ByLengths</strong> (coordinateSystem)</p><p>Create a Cuboid centered at WCS origin, with width, length, and height.</p></td><td><img src="5_essential_nodes_and_concepts/images/5-1/indexofnodes-cuboidbylengthscoordinatesystem.jpg" alt="" /></td></tr>
<tr><td><img src="5_essential_nodes_and_concepts/images/5-1/Cuboidbycorners(1)%20(1).jpg" alt="" /></td><td><p><strong>Cuboid.ByCorners</strong></p><p>Create a Cuboid spanning from low Point to high Point.</p></td><td><img src="5_essential_nodes_and_concepts/images/5-1/indexofnodes-cuboidbycorners.jpg" alt="" /></td></tr>
<tr><td><img src="5_essential_nodes_and_concepts/images/5-1/Cuboidlength(1).jpg" alt="" /></td><td><p><strong>Cuboid.Length</strong></p><p>Return the input dimensions of the Cuboid, NOT the actual world space dimensions. **</p></td><td><img src="5_essential_nodes_and_concepts/images/5-1/indexofnodes-cuboidlength.jpg" alt="" /></td></tr>
<tr><td><img src="5_essential_nodes_and_concepts/images/5-1/Cuboidwidth(1)%20(1).jpg" alt="" /></td><td><p><strong>Cuboid.Width</strong></p><p>Return the input dimensions of the Cuboid, NOT the actual world space dimensions. **</p></td><td><img src="5_essential_nodes_and_concepts/images/5-1/indexofnodes-cuboidwidth.jpg" alt="" /></td></tr>
<tr><td><img src="5_essential_nodes_and_concepts/images/5-1/Cuboidheight(1).jpg" alt="" /></td><td><p><strong>Cuboid.Height</strong></p><p>Return the input dimensions of the Cuboid, NOT the actual world space dimensions. **</p></td><td><img src="5_essential_nodes_and_concepts/images/5-1/indexofnodes-cuboidheight.jpg" alt="" /></td></tr>
<tr><td><img src="5_essential_nodes_and_concepts/images/5-1/Boundingboxtocuboid(1).jpg" alt="" /></td><td><p><strong>BoundingBox.ToCuboid</strong></p><p>Get the Bounding Box as a solid Cuboid</p></td><td><img src="5_essential_nodes_and_concepts/images/5-1/indexofnodes-boundingboxtocuboid.jpg" alt="" /></td></tr>
</tbody></table>
</div>
<p>{% hint style=&quot;warning&quot; %}
**In other words, if you create a Cuboid width (X-axis) length 10, and transform it to a CoordinateSystem with 2 times scaling in X, the width will still be 10. ASM does not allow you to extract the Vertices of a body in any predictable order, so it is impossible to determine the dimensions after a transform.
{% endhint %}</p>
<h3 id="curve"><a class="header" href="#curve">Curve</a></h3>
<div class="table-wrapper"><table><thead><tr><th></th><th></th><th></th></tr></thead><tbody>
<tr><td></td><td>ACTIONS</td><td></td></tr>
<tr><td><img src="5_essential_nodes_and_concepts/images/5-1/Curveextrude.jpg" alt="" /></td><td><p><strong>Curve.Extrude</strong> (distance)<br>Extrudes a Curve in the normal Vector direction.</p></td><td><img src="5_essential_nodes_and_concepts/images/5-1/indexofnodes-curveextrude.jpg" alt="" /></td></tr>
<tr><td><img src="5_essential_nodes_and_concepts/images/5-1/Curvepointatparameter.jpg" alt="" /></td><td><p><strong>Curve.PointAtParameter</strong><br>Get a Point on the Curve at a specified parameter between StartParameter() and EndParameter().</p></td><td><img src="5_essential_nodes_and_concepts/images/5-1/indexofnodes-curvepointatparameter.jpg" alt="" /></td></tr>
</tbody></table>
</div>
<h3 id="geometry-modifiers"><a class="header" href="#geometry-modifiers">Geometry Modifiers</a></h3>
<div class="table-wrapper"><table><thead><tr><th></th><th></th><th></th></tr></thead><tbody>
<tr><td></td><td>ACTIONS</td><td></td></tr>
<tr><td><img src="5_essential_nodes_and_concepts/images/5-1/Geometrydistanceto.jpg" alt="" /></td><td><p><strong>Geometry.DistanceTo</strong><br>Obtain the distance from this Ge ometry to another.</p></td><td><img src="5_essential_nodes_and_concepts/images/5-1/indexofnodes-geometrydistanceto.jpg" alt="" /></td></tr>
<tr><td><img src="5_essential_nodes_and_concepts/images/5-1/Geometryexplode.jpg" alt="" /></td><td><p><strong>Geometry.Explode</strong><br>Separates compound or non-separated elements into their component parts</p></td><td><img src="5_essential_nodes_and_concepts/images/5-1/indexofnodes-geometryexplode.jpg" alt="" /></td></tr>
<tr><td><img src="5_essential_nodes_and_concepts/images/5-1/GeometryimportfromSAT.jpg" alt="" /></td><td><p><strong>Geometry.ImportFromSAT</strong><br>List of imported geometries</p></td><td><img src="5_essential_nodes_and_concepts/images/5-1/indexofnodes-geometryimportfromsat.jpg" alt="" /></td></tr>
<tr><td><img src="5_essential_nodes_and_concepts/images/5-1/Geometryrotate.jpg" alt="" /></td><td><p><strong>Geometry.Rotate</strong> (basePlane)<br>Rotates an object around the Plane origin and normal by a specified degree.</p></td><td><img src="5_essential_nodes_and_concepts/images/5-1/indexofnodes-geometryrotate.jpg" alt="" /></td></tr>
<tr><td><img src="5_essential_nodes_and_concepts/images/5-1/Geometrytranslate.jpg" alt="" /></td><td><p><strong>Geometry.Translate</strong><br>Translates any geometry type by the given distance in the given direction.</p></td><td><img src="5_essential_nodes_and_concepts/images/5-1/indexofnodes-geometrytranslate.jpg" alt="" /></td></tr>
</tbody></table>
</div>
<h3 id="line"><a class="header" href="#line">Line</a></h3>
<div class="table-wrapper"><table><thead><tr><th></th><th></th><th></th></tr></thead><tbody>
<tr><td></td><td>CREATE</td><td></td></tr>
<tr><td><img src="5_essential_nodes_and_concepts/images/5-1/Linebybestfitthroughpoints.jpg" alt="" /></td><td><p><strong>Line.ByBestFitThroughPoints</strong><br>Creates a Line best approximating a scatter plot of Points.</p></td><td><img src="5_essential_nodes_and_concepts/images/5-1/indexofnodes-linebybestfitthroughpoints.jpg" alt="" /></td></tr>
<tr><td><img src="5_essential_nodes_and_concepts/images/5-1/Linebystartpointdirectionlength.jpg" alt="" /></td><td><p><strong>Line.ByStartPointDirectionLength</strong><br>Create a straight Line starting at Point, extending in Vector direction by specified length.</p></td><td><img src="5_essential_nodes_and_concepts/images/5-1/indexofnodes-linebystartpointdirectionlength.jpg" alt="" /></td></tr>
<tr><td><img src="5_essential_nodes_and_concepts/images/5-1/Linebystartpointendpoint.jpg" alt="" /></td><td><p><strong>Line.ByStartPointEndPoint</strong><br>Creates a straight Line between two input Points.</p></td><td><img src="5_essential_nodes_and_concepts/images/5-1/indexofnodes-linebystartpointendpoint.jpg" alt="" /></td></tr>
<tr><td><img src="5_essential_nodes_and_concepts/images/5-1/Linebytangency.jpg" alt="" /></td><td><p><strong>Line.ByTangency</strong><br>Create a Line tangent to the input Curve, positioned at the parameter Point of the input Curve.</p></td><td><img src="5_essential_nodes_and_concepts/images/5-1/indexofnodes-linebytangency.jpg" alt="" /></td></tr>
<tr><td></td><td>QUERY</td><td></td></tr>
<tr><td><img src="5_essential_nodes_and_concepts/images/5-1/Linedirection.jpg" alt="" /></td><td><p><strong>Line.Direction</strong><br>The direction of the Curve.</p></td><td><img src="5_essential_nodes_and_concepts/images/5-1/indexofnodes-linedirection.jpg" alt="" /></td></tr>
</tbody></table>
</div>
<h3 id="nurbscurve"><a class="header" href="#nurbscurve">NurbsCurve</a></h3>
<div class="table-wrapper"><table><thead><tr><th></th><th></th><th></th></tr></thead><tbody>
<tr><td></td><td>Create</td><td></td></tr>
<tr><td><img src="5_essential_nodes_and_concepts/images/5-1/Nurbscurvebycontrolpoints.jpg" alt="" /></td><td><p><strong>NurbsCurve.ByControlPoints</strong><br>Create a BSplineCurve by using explicit control points.</p></td><td><img src="5_essential_nodes_and_concepts/images/5-1/indexofnodes-nurbscurvebycontrolpoints.jpg" alt="" /></td></tr>
<tr><td><img src="5_essential_nodes_and_concepts/images/5-1/Nurbscurvebypoints.jpg" alt="" /></td><td><p><strong>NurbsCurve.ByPoints</strong><br>Create a BSplineCurve by interpolating between points</p></td><td><img src="5_essential_nodes_and_concepts/images/5-1/indexofnodes-nurbscurvebypoints.jpg" alt="" /></td></tr>
</tbody></table>
</div>
<h3 id="nurbssurface"><a class="header" href="#nurbssurface">NurbsSurface</a></h3>
<div class="table-wrapper"><table><thead><tr><th></th><th></th><th></th></tr></thead><tbody>
<tr><td></td><td>Create</td><td></td></tr>
<tr><td><img src="5_essential_nodes_and_concepts/images/5-1/Nurbssurfacebycontrolpoints.jpg" alt="" /></td><td><p><strong>NurbsSurface.ByControlPoints</strong><br>Create a NurbsSurface by using explicit control Points with specified U and V degrees.</p></td><td><img src="5_essential_nodes_and_concepts/images/5-1/indexofnodes-nurbssurfacebycontrolpoints.jpg" alt="" /></td></tr>
<tr><td><img src="5_essential_nodes_and_concepts/images/5-1/Nurbssurfacebypoints.jpg" alt="" /></td><td><p><strong>NurbsSurface.ByPoints</strong><br>Creates a NurbsSurface with specified interpolated points and U and V degrees. The resultant surface will pass through all of the points.</p></td><td><img src="5_essential_nodes_and_concepts/images/5-1/indexofnodes-nurbssurfacebypoints.jpg" alt="" /></td></tr>
</tbody></table>
</div>
<h3 id="plane"><a class="header" href="#plane">Plane</a></h3>
<div class="table-wrapper"><table><thead><tr><th></th><th></th><th></th></tr></thead><tbody>
<tr><td></td><td>CREATE</td><td></td></tr>
<tr><td><img src="5_essential_nodes_and_concepts/images/5-1/Planebyoriginnormal.jpg" alt="" /></td><td><p><strong>Plane.ByOriginNormal</strong><br>Create a Plane centered at root Point, with input normal Vector.</p></td><td><img src="5_essential_nodes_and_concepts/images/5-1/indexofnodes-planebyoriginnormal.jpg" alt="" /></td></tr>
<tr><td><img src="5_essential_nodes_and_concepts/images/5-1/PlaneXY.jpg" alt="" /></td><td><p><strong>Plane.XY</strong><br>Creates a plane in the world XY</p></td><td><img src="5_essential_nodes_and_concepts/images/5-1/indexofnodes-planexy.jpg" alt="" /></td></tr>
</tbody></table>
</div>
<h3 id="point"><a class="header" href="#point">Point</a></h3>
<div class="table-wrapper"><table><thead><tr><th></th><th></th><th></th></tr></thead><tbody>
<tr><td></td><td>CREATE</td><td></td></tr>
<tr><td><img src="5_essential_nodes_and_concepts/images/5-1/Pointbycartesiancoordinates.jpg" alt="" /></td><td><p><strong>Point.ByCartesianCoordinates</strong><br>Form a Point in th egiven coordinate system with 3 cartesian coordinates</p></td><td><img src="5_essential_nodes_and_concepts/images/5-1/indexofnodes-pointbycartesiancoordinates.jpg" alt="" /></td></tr>
<tr><td><img src="5_essential_nodes_and_concepts/images/5-1/Pointbycoordinates2D.jpg" alt="" /></td><td><p><strong>Point.ByCoordinates</strong> (2d)<br>Form a Point in the XY plane given two 2 Cartesian coordinates. The Z component is 0.</p></td><td><img src="5_essential_nodes_and_concepts/images/5-1/indexofnodes-pointbycoordinates2D.jpg" alt="" /></td></tr>
<tr><td><img src="5_essential_nodes_and_concepts/images/5-1/Pointbycoordinates3D.jpg" alt="" /></td><td><p><strong>Point.ByCoordinates</strong> (3d)<br>Form a Point given 3 Cartesian coordinates.</p></td><td><img src="5_essential_nodes_and_concepts/images/5-1/indexofnodes-pointbycoordinates3D.jpg" alt="" /></td></tr>
<tr><td><img src="5_essential_nodes_and_concepts/images/5-1/Pointorigin.jpg" alt="" /></td><td><p><strong>Point.Origin</strong><br>Get the Origin point (0,0,0)</p></td><td><img src="5_essential_nodes_and_concepts/images/5-1/indexofnodes-pointorigin.jpg" alt="" /></td></tr>
<tr><td></td><td>ACTIONS</td><td></td></tr>
<tr><td><img src="5_essential_nodes_and_concepts/images/5-1/Pointadd.jpg" alt="" /></td><td><p><strong>Point.Add</strong><br>Add a vector to a point. The same as Translate (Vector).</p></td><td><img src="5_essential_nodes_and_concepts/images/5-1/indexofnodes-pointadd.jpg" alt="" /></td></tr>
<tr><td></td><td>QUERY</td><td></td></tr>
<tr><td><img src="5_essential_nodes_and_concepts/images/5-1/Pointx.jpg" alt="" /></td><td><p><strong>Point.X</strong><br>Get the X component of a point</p></td><td><img src="5_essential_nodes_and_concepts/images/5-1/indexofnodes-pointx.jpg" alt="" /></td></tr>
<tr><td><img src="5_essential_nodes_and_concepts/images/5-1/Pointy.jpg" alt="" /></td><td><p><strong>Point.Y</strong><br>Get the Y component of a point</p></td><td><img src="5_essential_nodes_and_concepts/images/5-1/indexofnodes-pointy.jpg" alt="" /></td></tr>
<tr><td><img src="5_essential_nodes_and_concepts/images/5-1/Pointz.jpg" alt="" /></td><td><p><strong>Point.Z</strong><br>Get the Z component of a point</p></td><td><img src="5_essential_nodes_and_concepts/images/5-1/indexofnodes-pointz.jpg" alt="" /></td></tr>
</tbody></table>
</div>
<h3 id="polycurve"><a class="header" href="#polycurve">Polycurve</a></h3>
<div class="table-wrapper"><table><thead><tr><th></th><th></th><th></th></tr></thead><tbody>
<tr><td></td><td>CREATE</td><td></td></tr>
<tr><td><img src="5_essential_nodes_and_concepts/images/5-1/Polycurvebypoints.jpg" alt="" /></td><td><p><strong>Polycurve.ByPoints</strong><br>Make PolyCurve from sequence of lines connecting points. For closed curve last point should be in the same location as the start point.</p></td><td><img src="5_essential_nodes_and_concepts/images/5-1/indexofnodes-polycurvebypoints.jpg" alt="" /></td></tr>
</tbody></table>
</div>
<h3 id="rectangle"><a class="header" href="#rectangle">Rectangle</a></h3>
<div class="table-wrapper"><table><thead><tr><th></th><th></th><th></th></tr></thead><tbody>
<tr><td></td><td>CREATE</td><td></td></tr>
<tr><td><img src="5_essential_nodes_and_concepts/images/5-1/Rectanglebywidthlength.jpg" alt="" /></td><td><p><strong>Rectangle.ByWidthLength</strong> (Plane)<br>Create a Rectangle centered at input Plane root, with input width (Plane X axis length) and (Plane Y axis length).</p></td><td><img src="5_essential_nodes_and_concepts/images/5-1/indexofnodes-rectanglebywidthlength.jpg" alt="" /></td></tr>
</tbody></table>
</div>
<h3 id="sphere"><a class="header" href="#sphere">Sphere</a></h3>
<div class="table-wrapper"><table><thead><tr><th></th><th></th><th></th></tr></thead><tbody>
<tr><td></td><td>CREATE</td><td></td></tr>
<tr><td><img src="5_essential_nodes_and_concepts/images/5-1/Spherebycenterpointradius.jpg" alt="" /></td><td><p><strong>Sphere.ByCenterPointRadius</strong><br>Create a Solid Sphere centered at the input Point, with given radius.</p></td><td><img src="5_essential_nodes_and_concepts/images/5-1/indexofnodes-spherebycenterpointradius.jpg" alt="" /></td></tr>
</tbody></table>
</div>
<h3 id="surface"><a class="header" href="#surface">Surface</a></h3>
<div class="table-wrapper"><table><thead><tr><th></th><th></th><th></th></tr></thead><tbody>
<tr><td></td><td>CREATE</td><td></td></tr>
<tr><td><img src="5_essential_nodes_and_concepts/images/5-1/Surfacebyloft(3).jpg" alt="" /></td><td><p><strong>Surface.ByLoft</strong><br>Create a Surface by lofting between input cross section Curves</p></td><td><img src="5_essential_nodes_and_concepts/images/5-1/indexofnodes-surfacebyloft.jpg" alt="" /></td></tr>
<tr><td><img src="5_essential_nodes_and_concepts/images/5-1/Surfacebypatch.jpg" alt="" /></td><td><p><strong>Surface.ByPatch</strong><br>Create a Surface by filling in the interior of a closed boundary defined by input Curves.</p></td><td><img src="5_essential_nodes_and_concepts/images/5-1/indexofnodes-surfacebypatch(1)%20(1).jpg" alt="" /></td></tr>
<tr><td></td><td>ACTIONS</td><td></td></tr>
<tr><td><img src="5_essential_nodes_and_concepts/images/5-1/Surfaceoffset(1).jpg" alt="" /></td><td><p><strong>Surface.Offset</strong><br>Offset Surface in direction of Surface normal by specified distance</p></td><td><img src="5_essential_nodes_and_concepts/images/5-1/indexofnodes-surfaceoffset.jpg" alt="" /></td></tr>
<tr><td><img src="5_essential_nodes_and_concepts/images/5-1/Surfacepointatparameter(1)%20(1).jpg" alt="" /></td><td><p><strong>Surface.PointAtParameter</strong><br>Return the Point at a specified U and V parameters.</p></td><td><img src="5_essential_nodes_and_concepts/images/5-1/indexofnodes-surfacepointatparameter.jpg" alt="" /></td></tr>
<tr><td><img src="5_essential_nodes_and_concepts/images/5-1/Surfacethicken(1)%20(1).jpg" alt="" /></td><td><p><strong>Surface.Thicken</strong><br>Thicken Surface into a Solid, extruding in the direction of Surface normals on both sides of the Surface.</p></td><td><img src="5_essential_nodes_and_concepts/images/5-1/indexofnodes-surfacethicken.jpg" alt="" /></td></tr>
</tbody></table>
</div>
<h3 id="uv"><a class="header" href="#uv">UV</a></h3>
<div class="table-wrapper"><table><thead><tr><th></th><th></th><th></th></tr></thead><tbody>
<tr><td></td><td>CREATE</td><td></td></tr>
<tr><td><img src="5_essential_nodes_and_concepts/images/5-1/UVbycoordinates(1).jpg" alt="" /></td><td><p><strong>UV.ByCoordinates</strong><br>Create a UV from two doubles.</p></td><td><img src="5_essential_nodes_and_concepts/images/5-1/indexofnodes-UVbycoordinates.jpg" alt="" /></td></tr>
</tbody></table>
</div>
<h3 id="vector"><a class="header" href="#vector">Vector</a></h3>
<div class="table-wrapper"><table><thead><tr><th></th><th></th><th></th></tr></thead><tbody>
<tr><td></td><td>CREATE</td><td></td></tr>
<tr><td><img src="5_essential_nodes_and_concepts/images/5-1/Vectorbycoordinates(1).jpg" alt="" /></td><td><p><strong>Vector.ByCoordinates</strong><br>Form a Vector by 3 Euclidean coordinates</p></td><td><img src="5_essential_nodes_and_concepts/images/5-1/indexofnodes-vectorbycoordinates.jpg" alt="" /></td></tr>
<tr><td><img src="5_essential_nodes_and_concepts/images/5-1/Vectorxaxis(1)%20(1).jpg" alt="" /></td><td><p><strong>Vector.XAxis</strong><br>Gets the canonical X axis Vector (1,0,0)</p></td><td><img src="5_essential_nodes_and_concepts/images/5-1/indexofnodes-vectorx.jpg" alt="" /></td></tr>
<tr><td><img src="5_essential_nodes_and_concepts/images/5-1/Vectoryaxis(1)%20(1).jpg" alt="" /></td><td><p><strong>Vector.YAxis</strong><br>Gets the canonical Y axis Vector (0,1,0)</p></td><td><img src="5_essential_nodes_and_concepts/images/5-1/indexofnodes-vectory.jpg" alt="" /></td></tr>
<tr><td><img src="5_essential_nodes_and_concepts/images/5-1/Vectorzaxis(1)%20(1).jpg" alt="" /></td><td><p><strong>Vector.ZAxis</strong><br>Gets the canonical Z axis Vector (0,0,1)</p></td><td><img src="5_essential_nodes_and_concepts/images/5-1/indexofnodes-vectorz.jpg" alt="" /></td></tr>
<tr><td></td><td>ACTIONS</td><td></td></tr>
<tr><td><img src="5_essential_nodes_and_concepts/images/5-1/Vectornormalized(1).jpg" alt="" /></td><td><p><strong>Vector.Normalized</strong><br>Get the normalized version of a vector</p></td><td><img src="5_essential_nodes_and_concepts/images/5-1/indexofnodes-vectornormalized.jpg" alt="" /></td></tr>
</tbody></table>
</div>
<h2 id="coordinatesystem"><a class="header" href="#coordinatesystem">CoordinateSystem</a></h2>
<div class="table-wrapper"><table><thead><tr><th></th><th></th><th></th></tr></thead><tbody>
<tr><td></td><td>CREATE</td><td></td></tr>
<tr><td><img src="5_essential_nodes_and_concepts/images/5-1/Coordinatesystembyorigin.jpg" alt="" /></td><td><p><strong>CoordinateSystem.ByOrigin</strong><br>Create a CoordinateSystem with origin at input Point, with X and Y Axes set as WCS X and Y axes</p></td><td><img src="5_essential_nodes_and_concepts/images/5-1/indexofnodes-coordinatessystembyorigin.jpg" alt="" /></td></tr>
<tr><td><img src="5_essential_nodes_and_concepts/images/5-1/Coordinatesystembycylindricalcoordinates(1)%20(1).jpg" alt="" /></td><td><p><strong>CoordinateSystem.ByCyclindricalCoordinates</strong><br>Creates a CoordinateSystem at the specified cylindrical coordinate parameters with respet to the specified coordinate system</p></td><td><img src="5_essential_nodes_and_concepts/images/5-1/indexofnodes-coordinatessystembycylindricalcoordinates.jpg" alt="" /></td></tr>
</tbody></table>
</div>
<h2 id="operators"><a class="header" href="#operators">Operators</a></h2>
<div class="table-wrapper"><table><thead><tr><th></th><th></th><th></th></tr></thead><tbody>
<tr><td><img src="5_essential_nodes_and_concepts/images/5-1/addition(1)(1).jpg" alt="" /></td><td><p><strong>+</strong><br>Addition</p></td><td><img src="5_essential_nodes_and_concepts/images/5-1/indexofnodes-addition.jpg" alt="" /></td></tr>
<tr><td><img src="5_essential_nodes_and_concepts/images/5-1/Subtraction(1)(1)%20(1).jpg" alt="" /></td><td><p><strong>-</strong><br>Subtraction</p></td><td><img src="5_essential_nodes_and_concepts/images/5-1/indexofnodes-subtraction.jpg" alt="" /></td></tr>
<tr><td><img src="5_essential_nodes_and_concepts/images/5-1/Multiplication(1)(1).jpg" alt="" /></td><td><p><strong>*</strong><br>Multiplication</p></td><td><img src="5_essential_nodes_and_concepts/images/5-1/indexofnodes-multiplication.jpg" alt="" /></td></tr>
<tr><td><img src="5_essential_nodes_and_concepts/images/5-1/Division(1)(1).jpg" alt="" /></td><td><p><strong>/</strong><br>Division</p></td><td><img src="5_essential_nodes_and_concepts/images/5-1/indexofnodes-division.jpg" alt="" /></td></tr>
<tr><td><img src="5_essential_nodes_and_concepts/images/5-1/modular(1)%20(1).jpg" alt="" /></td><td><p><strong>%</strong><br>Modular Division finds the remainder of the first input after dividing by the second input</p></td><td><img src="5_essential_nodes_and_concepts/images/5-1/indexofnodes-modular.jpg" alt="" /></td></tr>
<tr><td><img src="5_essential_nodes_and_concepts/images/5-1/Lessthan(1)%20(1).jpg" alt="" /></td><td><p><strong>&lt;</strong><br>Less Than</p></td><td><img src="5_essential_nodes_and_concepts/images/5-1/indexofnodes-lessthan.jpg" alt="" /></td></tr>
<tr><td><img src="5_essential_nodes_and_concepts/images/5-1/greaterthan(1).jpg" alt="" /></td><td><p><strong>&gt;</strong><br>Greater Than</p></td><td><img src="5_essential_nodes_and_concepts/images/5-1/indexofnodes-greaterthan.jpg" alt="" /></td></tr>
<tr><td><img src="5_essential_nodes_and_concepts/images/5-1/==(1).jpg" alt="" /></td><td><p><strong>==</strong><br>Equality tests for equality between two values.</p></td><td><img src="5_essential_nodes_and_concepts/images/5-1/indexofnodes-==.jpg" alt="" /></td></tr>
</tbody></table>
</div><div style="break-before: page; page-break-before: always;"></div><h1 id="geometry-for-computational-design"><a class="header" href="#geometry-for-computational-design">Geometry for Computational Design</a></h1>
<p>As a Visual Programming environment, Dynamo enables you to craft the way that data is processed. Data is numbers or text, but so is Geometry. As understood by the Computer, Geometry - or sometimes called Computational Geometry - is the data we can use to create beautiful, intricate, or performance-driven models. To do so, we need to understand the ins and outs of the various types of Geometry we can use.</p>
<p><img src="5_essential_nodes_and_concepts/5-2_geometry-for-computational-design/../images/5-2/GeometryforComputationalDesign-01.jpg" alt="" /></p>
<div style="break-before: page; page-break-before: always;"></div><h1 id="geometry-overview"><a class="header" href="#geometry-overview">Geometry Overview</a></h1>
<h2 id="geometry-in-dynamo-sandbox"><a class="header" href="#geometry-in-dynamo-sandbox">Geometry in Dynamo Sandbox</a></h2>
<p><strong>Geometry</strong> is the language for design. When a programming language or environment has a geometry kernel at its core, we can unlock the possibilities for designing precise and robust models, automating design routines, and generating design iterations with algorithms.</p>
<p>Understanding the Geometry types and <a href="5_essential_nodes_and_concepts/5-2_geometry-for-computational-design/1-geometry-overview.html#stepping-through-the-hierarchy">how they are related</a> will allow us to navigate the collection of <strong>Geometry Nodes</strong> available to us in the Library. The Geometry Nodes are organized alphabetically as opposed to hierarchically - here they are displayed similar to their layout in the Dynamo interface.</p>
<p><img src="5_essential_nodes_and_concepts/5-2_geometry-for-computational-design/../images/5-2/1/geometryoverview-geometryindynamo.jpg" alt="" /></p>
<p>Additionally, making models in Dynamo and connecting the preview of what we see in the Background Preview to the flow of data in our graph should become more intuitive over time.</p>
<p><img src="5_essential_nodes_and_concepts/5-2_geometry-for-computational-design/../images/5-2/1/GeometryforComputationalDesign-Overview.jpg" alt="" /></p>
<blockquote>
<ol>
<li>Note the assumed coordinate system rendered by the grid and colored axes</li>
<li>Selected Nodes will render the corresponding geometry (if the Node creates geometry) in the background the highlight color</li>
</ol>
</blockquote>
<blockquote>
<p>Download the example file by clicking on the link below.</p>
<p>A full list of example files can be found in the Appendix.</p>
</blockquote>
<p>{% file src=&quot;../datasets/5-2/1/Geometry for Computational Design - Geometry Overview.dyn&quot; %}</p>
<h2 id="the-concept-of-geometry"><a class="header" href="#the-concept-of-geometry">The Concept of Geometry</a></h2>
<p>Geometry, traditionally defined, is the study of shape, size, relative position of figures, and the properties of space. This field has a rich history going back thousands of years. With the advent and popularization of the computer, we gained a powerful tool in defining, exploring, and generating geometry. It is now so easy to calculate the result of complex geometric interactions, the fact that we are doing so is almost transparent.</p>
<p><img src="5_essential_nodes_and_concepts/5-2_geometry-for-computational-design/../images/5-2/1/StanfordBunny.jpg" alt="Stanford Bunny" /></p>
<blockquote>
<p>If you're curious to see how diverse and complex geometry can get using the power of your computer, do a quick web search for the Stanford Bunny - a canonical model used to test algorithms.</p>
</blockquote>
<p>Understanding geometry in the context of algorithms, computing, and complexity, may sound daunting; however, there are a few key, and relatively simple, principles that we can establish as fundamentals to start building towards more advanced applications:</p>
<ol>
<li>Geometry is <strong>Data</strong> - to the computer and Dynamo, a Bunny not all that different from a number.</li>
<li>Geometry relies on <strong>Abstraction</strong> - fundamentally, geometric elements are described by numbers, relationships, and formulas within a given spatial coordinate system</li>
<li>Geometry has a <strong>Hierarchy</strong> - points come together to make lines, lines come together to make surfaces, and so on</li>
<li>Geometry simultaneously describes both <strong>the Part and the Whole</strong> - when we have a curve, it is both the shape as well as all the possible points along it</li>
</ol>
<p>In practice, these principles mean that we need to be aware of what we are working with (what type of geometry, how was it created, etc.) so that we can fluidly compose, decompose, and recompose different geometries as we develop more complex models.</p>
<h2 id="stepping-through-the-hierarchy"><a class="header" href="#stepping-through-the-hierarchy">Stepping through the Hierarchy</a></h2>
<p>Let's take a moment to look at the relationship between the Abstract and Hierarchical descriptions of Geometry. Because these two concepts are related, but not always obvious at first, we can quickly arrive at a conceptual roadblock once we start developing deeper workflows or models. For starters, let's use dimensionality as an easy descriptor of the &quot;stuff&quot; we model. The number of dimensions required to describe a shape gives us a window into how Geometry is organized hierarchically.</p>
<p><img src="5_essential_nodes_and_concepts/5-2_geometry-for-computational-design/../images/5-2/1/GeometryDimensionality.jpg" alt="Computational Geometry" /></p>
<blockquote>
<ol>
<li>A <strong>Point</strong> (defined by coordinates) doesn't have any dimensions to it - it's just numbers describing each coordinate</li>
<li>A <strong>Line</strong> (defined by two points) now has <em>one</em> dimension - we can &quot;walk&quot; the line either forward (positive direction) or backward (negative direction)</li>
<li>A <strong>Plane</strong> (defined by two lines) has <em>two</em> dimensions - walking more left or more right is now possible</li>
<li>A <strong>Box</strong> (defined by two planes) has <em>three</em> dimensions - we can define a position relative to up or down</li>
</ol>
</blockquote>
<p>Dimensionality is a convenient way to start categorizing Geometry but it's not necessarily the best. After all, we don't model with only Points, Lines, Planes, and Boxes - what if I want something curvy? Furthermore, there is a whole other category of Geometric types that are completely abstract ie. they define properties like orientation, volume, or relationships between parts. We can't really grab a hold of a Vector so how do we define it relative to what we see in space? A more detailed categorization of the geometric hierarchy should accommodate the difference between Abstract Types or &quot;Helpers,&quot; each of which we can group by what they help do and types that help describe the shape of model elements.</p>
<p><img src="5_essential_nodes_and_concepts/5-2_geometry-for-computational-design/../images/5-2/1/GeometryHierarchy.jpg" alt="Geometry Hierarchy" /></p>
<h2 id="going-further-with-geometry"><a class="header" href="#going-further-with-geometry">Going Further with Geometry</a></h2>
<p>Creating models in Dynamo is not limited to what we can generate with Nodes. Here are some key ways to take your process to the next level with Geometry:</p>
<ol>
<li>Dynamo allows you to import files - try using a CSV for point clouds or SAT for bringing in surfaces</li>
<li>When working with Revit, we can reference Revit elements to use in Dynamo</li>
<li>The Dynamo Package Manager offers additional functionality for extended geometry types and operations - check out the <a href="https://github.com/DynamoDS/Dynamo/wiki/Dynamo-Mesh-Toolkit">Mesh Toolkit</a> package</li>
</ol>
<div style="break-before: page; page-break-before: always;"></div><h1 id="vector-plane--coordinate-system"><a class="header" href="#vector-plane--coordinate-system">Vector, Plane &amp; Coordinate System</a></h1>
<h2 id="vector-plane--coordinates-system-in-dynamo"><a class="header" href="#vector-plane--coordinates-system-in-dynamo">Vector, Plane &amp; Coordinates System in Dynamo</a></h2>
<h3 id="vector-1"><a class="header" href="#vector-1">Vector</a></h3>
<p><a href="5_essential_nodes_and_concepts/5-2_geometry-for-computational-design/5-2_vectors.html#vector-1">Vector </a>is a representation of magnitude and direction, you can picture it as an arrow accelerating towards a particular direction at a given speed. It is a key component to our models in Dynamo. Note that, because they are in the Abstract category of &quot;Helpers,&quot; when we create a Vector, we won't see anything in the Background Preview.</p>
<p><img src="5_essential_nodes_and_concepts/5-2_geometry-for-computational-design/../images/5-2/2/GeometryforComputationalDesign-vectors.jpg" alt="Vectors in Dynamo" /></p>
<blockquote>
<ol>
<li>We can use a line as a stand in for a Vector preview.</li>
</ol>
</blockquote>
<blockquote>
<p>Download the example file by clicking on the link below.</p>
<p>A full list of example files can be found in the Appendix.</p>
</blockquote>
<p>{% file src=&quot;../datasets/5-2/2/Geometry for Computational Design - Vectors.dyn&quot; %}</p>
<h3 id="plane-1"><a class="header" href="#plane-1">Plane</a></h3>
<p><a href="5_essential_nodes_and_concepts/5-2_geometry-for-computational-design/5-2_vectors.html#plane-1">Plane </a>is a two dimensional surface, you can picture it as a flat surface that extends indefinitely. Each Plane has an Origin, X Direction, Y Direction, and a Z (Up) Direction.</p>
<p><img src="5_essential_nodes_and_concepts/5-2_geometry-for-computational-design/../images/5-2/2/GeometryforComputationalDesign-plane.jpg" alt="Planes in Dynamo" /></p>
<blockquote>
<ol>
<li>Although they are abstract, Planes do have an origin position so we can locate them in space.</li>
<li>In Dynamo, Planes are rendered in the Background Preview.</li>
</ol>
</blockquote>
<blockquote>
<p>Download the example file by clicking on the link below.</p>
<p>A full list of example files can be found in the Appendix.</p>
</blockquote>
<p>{% file src=&quot;../datasets/5-2/2/Geometry for Computational Design - Plane.dyn&quot; %}</p>
<h3 id="coordinate-system"><a class="header" href="#coordinate-system">Coordinate System</a></h3>
<p><a href="5_essential_nodes_and_concepts/5-2_geometry-for-computational-design/5-2_vectors.html#coordinate-system-1">Coordinate system</a> is a system to determine the location of points or other geometric elements. The image below explains how it looks like in Dynamo and what each color represents.</p>
<p><img src="5_essential_nodes_and_concepts/5-2_geometry-for-computational-design/../images/5-2/2/GeometryforComputationalDesign-Coordinate.jpg" alt="Coordinate System in Dynamo" /></p>
<blockquote>
<ol>
<li>Although they are abstract, Coordinate Systems also have an origin position so we can locate them in space.</li>
<li>In Dynamo, Coordinate Systems are rendered in the Background Preview as a point (origin) and lines defining the axes (X is red, Y is green, and Z is blue following convention).</li>
</ol>
</blockquote>
<blockquote>
<p>Download the example file by clicking on the link below.</p>
<p>A full list of example files can be found in the Appendix.</p>
</blockquote>
<p>{% file src=&quot;../datasets/5-2/2/Geometry for Computational Design - Coordinate System.dyn&quot; %}</p>
<h2 id="deep-dive-into"><a class="header" href="#deep-dive-into">Deep Dive into...</a></h2>
<p>Vectors, Planes, and Coordinate Systems make up the primary group of Abstract Geometry Types. They help us define location, orientation, and the spatial context for other geometry that describe shapes. If I say that I'm in New York City at 42nd Street and Broadway (Coordinate System), standing on the street level (Plane), looking North (Vector), I've just used these &quot;Helpers&quot; to define where I am. The same goes for a phone case product or a skyscraper - we need this context to develop our model.</p>
<p><img src="5_essential_nodes_and_concepts/5-2_geometry-for-computational-design/../images/5-2/2/VectorsPlanesCoodinates.jpg" alt="Vectors, Planes, and Coordinates" /></p>
<h3 id="vector-2"><a class="header" href="#vector-2">Vector</a></h3>
<p>A vector is a geometric quantity describing Direction and Magnitude. Vectors are abstract; ie. they represent a quantity, not a geometrical element. Vectors can be easily confused with Points because they both are composed of a list of values. There is a key difference though: Points describe a position in a given coordinate system while Vectors describe a relative difference in position which is the same as saying &quot;direction.&quot;</p>
<p><img src="5_essential_nodes_and_concepts/5-2_geometry-for-computational-design/../images/5-2/2/Vector-Detailed.jpg" alt="Vector Details" /></p>
<p>If the idea of relative difference is confusing, think of the Vector AB as &quot;I'm standing at Point A, looking toward Point B.&quot; The direction, from here (A) to there (B), is our Vector.</p>
<p>Breaking down Vectors further into their parts using the same AB notation:</p>
<p><img src="5_essential_nodes_and_concepts/5-2_geometry-for-computational-design/../images/5-2/2/Vector.jpg" alt="Vector" /></p>
<blockquote>
<ol>
<li>The <strong>Start Point</strong> of the Vector is called the <strong>Base</strong>.</li>
<li>The **End Point **of the Vector is called the <strong>Tip</strong> or the <strong>Sense</strong>.</li>
<li>Vector AB is not the same as Vector BA - that would point in the opposite direction.</li>
</ol>
</blockquote>
<p>If you're ever in need of comic relief regarding Vectors (and their abstract definition), watch the classic comedy Airplane and listen for the oft-quoted tongue-in cheek line:</p>
<blockquote>
<p><em>Roger, Roger. What's our vector, Victor?</em></p>
</blockquote>
<h3 id="plane-2"><a class="header" href="#plane-2">Plane</a></h3>
<p>Planes are two-dimensional abstract &quot;Helpers.&quot; More specifically, Planes are conceptually flat, extending infinitely in two directions. Usually they are rendered as a smaller rectangle near their origin.</p>
<p><img src="5_essential_nodes_and_concepts/5-2_geometry-for-computational-design/../images/5-2/2/Plane.jpg" alt="Plane" /></p>
<p>You might be thinking, &quot;Wait! Origin? That sounds like a Coordinate System... like the one I use to model in my CAD software!&quot;</p>
<p>And you're correct! Most modeling software take advantage of construction planes or &quot;levels&quot; to define a local two-dimentional context to draft in. XY, XZ, YZ -or- North, Southeast, Plan might sound more familiar. These are all Planes, defining an infinite &quot;flat&quot; context. Planes don't have depth, but they do help us describe direction as well -</p>
<h3 id="coordinate-system-1"><a class="header" href="#coordinate-system-1">Coordinate System</a></h3>
<p>If we are comfortable with Planes, we are a small step away from understanding Coordinate Systems. A Plane has all the same parts as a Coordinate System, provided it is a standard &quot;Euclidean&quot; or &quot;XYZ&quot; Coordinate System.</p>
<p>There are other, however, alternative Coordinate Systems such as Cylindrical or Spherical. As we will see in later sections, Coordinate Systems can also be applied to other Geometry types to define a position on that geometry.</p>
<p><img src="5_essential_nodes_and_concepts/5-2_geometry-for-computational-design/../images/5-2/2/CoordinateSystem.jpg" alt="Coordinate System" /></p>
<blockquote>
<p>Add alternative coordinate systems - cylindrical, spherical</p>
</blockquote>
<div style="break-before: page; page-break-before: always;"></div><h1 id="points"><a class="header" href="#points">Points</a></h1>
<h2 id="points-in-dynamo"><a class="header" href="#points-in-dynamo">Points in Dynamo</a></h2>
<h3 id="what-is-a-point"><a class="header" href="#what-is-a-point">What is a Point?</a></h3>
<p>A <a href="5_essential_nodes_and_concepts/5-2_geometry-for-computational-design/5-3_points.html#point-as-coordinates">Point</a> is defined by nothing more than one or more values called coordinates. How many coordinate values we need to define the Point depends upon the Coordinate System or context in which it resides.</p>
<h3 id="2d--3d-point"><a class="header" href="#2d--3d-point">2D &amp; 3D Point</a></h3>
<p>The most common kind of Point in Dynamo exists in our three-dimensional World Coordinate System and has three coordinates [X,Y,Z] (3D Point in Dynamo).</p>
<p><img src="5_essential_nodes_and_concepts/5-2_geometry-for-computational-design/../images/5-2/3/points-3dpointindynamo.jpg" alt="" /></p>
<p>A 2D Point in Dynamo has two coordinates [X,Y].</p>
<p><img src="5_essential_nodes_and_concepts/5-2_geometry-for-computational-design/../images/5-2/3/points-2dpointindynamo.jpg" alt="" /></p>
<h3 id="point-on-curves-and-surfaces"><a class="header" href="#point-on-curves-and-surfaces">Point on Curves and Surfaces</a></h3>
<p>Parameters for both Curves and Surfaces are continuous and extend beyond the edge of the given geometry. Since the shapes that define the Parameter Space reside in a three-dimensional World Coordinate System, we can always translate a Parametric Coordinate into a &quot;World&quot; Coordinate. The point [0.2, 0.5] on the surface for example is the same as point [1.8, 2.0, 4.1] in world coordinates.</p>
<p><img src="5_essential_nodes_and_concepts/5-2_geometry-for-computational-design/../images/5-2/3/points-xyzvscoordsysvsuv.jpg" alt="" /></p>
<blockquote>
<ol>
<li>Point in assumed World XYZ Coordinates</li>
<li>Point relative to a given Coordinate System (Cylindrical)</li>
<li>Point as UV Coordinate on a Surface</li>
</ol>
</blockquote>
<blockquote>
<p>Download the example file by clicking on the link below.</p>
<p>A full list of example files can be found in the Appendix.</p>
</blockquote>
<p>{% file src=&quot;../datasets/5-2/3/Geometry for Computational Design - Points.dyn&quot; %}</p>
<h2 id="deep-dive-into-1"><a class="header" href="#deep-dive-into-1">Deep Dive into...</a></h2>
<p>If Geometry is the language of a model, then Points are the alphabet. Points are the foundation upon which all other geometry is created - we need at least two Points to create a Curve, we need at least three Points to make a Polygon or a Mesh Face, and so on. Defining the position, order, and relationship among Points (try a Sine Function) allows us to define higher order geometry like things we recognize as Circles or Curves.</p>
<p><img src="5_essential_nodes_and_concepts/5-2_geometry-for-computational-design/../images/5-2/3/PointsAsBuildingBlocks-1.jpg" alt="Point to Curve" /></p>
<blockquote>
<ol>
<li>A Circle using the functions <code>x=r*cos(t)</code> and <code>y=r*sin(t)</code></li>
<li>A Sine Curve using the functions <code>x=(t)</code> and <code>y=r*sin(t)</code></li>
</ol>
</blockquote>
<h3 id="point-as-coordinates"><a class="header" href="#point-as-coordinates">Point as Coordinates</a></h3>
<p>Points can exist in a two-dimensional Coordinate System as well. Convention has different letter notation depending upon what kind of space we are working with - we might be using [X,Y] on a Plane or [U,V] if we are on a surface.</p>
<p><img src="5_essential_nodes_and_concepts/5-2_geometry-for-computational-design/../images/5-2/3/Coordinates.jpg" alt="Point as Coordinates" /></p>
<blockquote>
<ol>
<li>A Point in Euclidean Coordinate System: [X,Y,Z]</li>
<li>A Point in a Curve Parameter Coordinate System: [t]</li>
<li>A Point in a Surface Parameter Coordinate System: [U,V]</li>
</ol>
</blockquote>
<div style="break-before: page; page-break-before: always;"></div><h1 id="curves"><a class="header" href="#curves">Curves</a></h1>
<h2 id="curves-in-dynamo"><a class="header" href="#curves-in-dynamo">Curves in Dynamo</a></h2>
<h3 id="what-is-curve"><a class="header" href="#what-is-curve">What is Curve?</a></h3>
<p><a href="5_essential_nodes_and_concepts/5-2_geometry-for-computational-design/5-4_curves.html#curve">Curves </a>are the first Geometric Data Type we've covered that have a more familiar set of shape descriptive properties - How curvey or straight? How long or short? And remember that Points are still our building blocks for defining anything from a line to a spline and all the Curve types in between.</p>
<p><img src="5_essential_nodes_and_concepts/5-2_geometry-for-computational-design/../images/5-2/4/CurveTypes.jpg" alt="Curve Types" /></p>
<blockquote>
<ol>
<li>Line</li>
<li>Polyline</li>
<li>Arc</li>
<li>Circle</li>
<li>Ellipse</li>
<li>NURBS Curve</li>
<li>Polycurve</li>
</ol>
</blockquote>
<h3 id="line-1"><a class="header" href="#line-1">Line</a></h3>
<p><a href="5_essential_nodes_and_concepts/5-2_geometry-for-computational-design/5-4_curves.html#lines">Line </a>is made of a set of points, each line has at least 2 points. One of the most common way to create line in Dynamo is using <code>Line.ByStartPointEndPoint</code> <img src="5_essential_nodes_and_concepts/5-2_geometry-for-computational-design/./images/5-2/4/Linebystartpointendpoint.jpg" alt="" /> to create a Line in Dynamo.</p>
<p><img src="5_essential_nodes_and_concepts/5-2_geometry-for-computational-design/../images/5-2/4/curves-linebystartpointendpoint.jpg" alt="" /></p>
<h3 id="nurbs-curve"><a class="header" href="#nurbs-curve">NURBS Curve</a></h3>
<p><a href="5_essential_nodes_and_concepts/5-2_geometry-for-computational-design/5-4_curves.html#nurbs-+-polycurves">NURBS</a> is a model used for representing curves and surfaces accurately. A sine curve in Dynamo using two different methods to create NURBS Curves to compare the results.</p>
<p><img src="5_essential_nodes_and_concepts/5-2_geometry-for-computational-design/../images/5-2/4/curves-NurbsCurves.jpg" alt="" /></p>
<blockquote>
<ol>
<li><em>NurbsCurve.ByControlPoints</em> uses the List of Points as Control Points</li>
<li><em>NurbsCurve.ByPoints</em> draws a Curve through the List of Points</li>
</ol>
</blockquote>
<blockquote>
<p>Download the example file by clicking on the link below.</p>
<p>A full list of example files can be found in the Appendix.</p>
</blockquote>
<p>{% file src=&quot;../datasets/5-2/4/Geometry for Computational Design - Curves.dyn&quot; %}</p>
<h2 id="deep-dive-into-2"><a class="header" href="#deep-dive-into-2">Deep Dive into...</a></h2>
<h3 id="curves-1"><a class="header" href="#curves-1">Curves</a></h3>
<p>The term <strong>Curve</strong> is generally a catch-all for all different sort of curved (even if straight) shapes. Capital &quot;C&quot; Curve is the parent categorization for all of those shape types - Lines, Circles, Splines, etc. More technically, a Curve describes every possible Point that can be found by inputting &quot;t&quot; into a collection of functions, which may range from the simple (<code>x = -1.26*t, y = t</code>) to functions involving calculus. No matter what kind of Curve we are working with, this <strong>Parameter</strong> called &quot;t&quot; is a property we can evaluate. Furthermore, regardless of the look of the shape, all Curves also have a start point and end point, which coincidentally align with the minimum and maximum t values used to create the Curve. This also helps us understand its directionality.</p>
<p><img src="5_essential_nodes_and_concepts/5-2_geometry-for-computational-design/../images/5-2/4/CurveParameter.jpg" alt="Curve Parameter" /></p>
<blockquote>
<p>It's important to note that Dynamo assumes that the domain of &quot;t&quot; values for a Curve is understood to be 0.0 to 1.0.</p>
</blockquote>
<p>All Curves also possess a number of properties or characteristics which can be used to describe or analyze them. When the distance between the start and end points is zero, the curve is &quot;closed.&quot; Also, every curve has a number of control-points, if all these points are located in the same plane, the curve is &quot;planar.&quot; Some properties apply to the curve as a whole, while others only apply to specific points along the curve. For example, planarity is a global property while a tangent vector at a given t value is a local property.</p>
<h3 id="lines"><a class="header" href="#lines">Lines</a></h3>
<p><strong>Lines</strong> are the simplest form of Curves. They may not look curvy but they are in fact Curves - just without any curvature. There are a few different ways to create Lines, the most intuitive being from Point A to Point B. The shape of the Line AB will be drawn between the points but mathematically it extends infinitely in both directions.</p>
<p><img src="5_essential_nodes_and_concepts/5-2_geometry-for-computational-design/../images/5-2/4/Line.jpg" alt="Line" /></p>
<p>When we connect two Lines together, we have a <strong>Polyline</strong>. Here we have a straightforward representation of what a Control Point is. Editing any of these point locations will change the shape of the Polyline. If the Polyline is closed, we have a Polygon. If the Polygon's edge lengths are all equal, it is described as regular.</p>
<p><img src="5_essential_nodes_and_concepts/5-2_geometry-for-computational-design/../images/5-2/4/Polyline.jpg" alt="Polyline + Polygon" /></p>
<h3 id="arcs-circles-ellipse-arcs-and-ellipses"><a class="header" href="#arcs-circles-ellipse-arcs-and-ellipses">Arcs, Circles, Ellipse Arcs, and Ellipses</a></h3>
<p>As we add more complexity to the Parametric Functions that define a shape, we can take one step further from a Line to create an <strong>Arc</strong>, <strong>Circle</strong>, <strong>Ellipse Arc</strong>, or <strong>Ellipse</strong> by describing one or two radii. The differences between the Arc version and the Circle or Ellipse is only whether or not the shape is closed.</p>
<p><img src="5_essential_nodes_and_concepts/5-2_geometry-for-computational-design/../images/5-2/4/Arcs+Circles.jpg" alt="Arcs + Circles" /></p>
<h3 id="nurbs--polycurves"><a class="header" href="#nurbs--polycurves">NURBS + Polycurves</a></h3>
<p><strong>NURBS</strong> (Non-uniform Rational Basis Splines) are mathematical representations that can accurately model any shape from a simple two dimensional Line, Circle, Arc, or Rectangle to the most complex three-dimensional free-form organic Curve. Because of their flexibility (relatively few control points, yet smooth interpolation based on Degree settings) and precision (bound by a robust math), NURBS models can be used in any process from illustration and animation to manufacturing.</p>
<p><img src="5_essential_nodes_and_concepts/5-2_geometry-for-computational-design/../images/5-2/4/NURBScurve.jpg" alt="NURBS Curve" /></p>
<p><strong>Degree</strong>: The Degree of the Curve determines the range of influence the Control Points have on a Curve; where the higher the degree, the larger the range. The Degree is a positive whole number. This number is usually 1, 2, 3 or 5, but can be any positive whole number. NURBS lines and polylines are usually Degree 1 and most free-form Curves are Degree 3 or 5.</p>
<p><strong>Control Points</strong>: The Control Points are a list of at least Degree+1 Points. One of the easiest ways to change the shape of a NURBS Curve is to move its Control Points.</p>
<p><strong>Weight</strong>: Control Points have an associated number called a Weight. Weights are usually positive numbers. When a Curves Control Points all have the same weight (usually 1), the Curve is called non-rational, otherwise the Curve is called rational. Most NURBS curves are non-rational.</p>
<p><strong>Knots</strong>: Knots are a list of (Degree+N-1) numbers, where N is the number of Control Points. The Knots are used together with the weights to control the influence of the Control Points on the resulting Curve. One use for Knots is to create kinks at certain points in the curve.</p>
<p><img src="5_essential_nodes_and_concepts/5-2_geometry-for-computational-design/../images/5-2/4/NURBScurve_Degree.jpg" alt="NURBS Curve Degree" /></p>
<blockquote>
<ol>
<li>Degree = 1</li>
<li>Degree = 2</li>
<li>Degree = 3</li>
</ol>
</blockquote>
<p>{% hint style=&quot;info&quot; %}
Note that the higher the degree value, the more Control Points are used to interpolate the resulting Curve.
{% endhint %}</p>
<div style="break-before: page; page-break-before: always;"></div><h1 id="surfaces"><a class="header" href="#surfaces">Surfaces</a></h1>
<h2 id="surfaces-in-dynamo"><a class="header" href="#surfaces-in-dynamo">Surfaces in Dynamo</a></h2>
<h3 id="what-is-surface"><a class="header" href="#what-is-surface">What is Surface</a></h3>
<p>We use <a href="5_essential_nodes_and_concepts/5-2_geometry-for-computational-design/5-surfaces.html#surface">Surface</a> in model to represent objects we see in our three dimensional world. While Curves are not always planar ie. they are three dimensional, the space they define is always bound to one dimension. Surfaces give us another dimension and a collection of additional properties we can use within other modeling operations.</p>
<h3 id="surface-at-parameter"><a class="header" href="#surface-at-parameter">Surface at Parameter</a></h3>
<p>Import and evaluate a Surface at a Parameter in Dynamo to see what kind of information we can extract.</p>
<p><img src="5_essential_nodes_and_concepts/5-2_geometry-for-computational-design/../images/5-2/5/surfaces-surfaceindynamo.jpg" alt="" /></p>
<blockquote>
<ol>
<li><em>Surface.PointAtParameter</em> returns the Point at a given UV Coordinate</li>
<li><em>Surface.NormalAtParameter</em> returns the Normal Vector at a given UV Coordinate</li>
<li><em>Surface.GetIsoline</em> returns the Isoparametric Curve at a U or V Coordinate - note the isoDirection input.</li>
</ol>
</blockquote>
<blockquote>
<p>Download the example files by clicking on the link below.</p>
<p>A full list of example files can be found in the Appendix.</p>
</blockquote>
<p>{% file src=&quot;../datasets/5-2/5/Surfaces.zip&quot; %}</p>
<h2 id="deep-dive-into-3"><a class="header" href="#deep-dive-into-3">Deep Dive into...</a></h2>
<h3 id="surface-1"><a class="header" href="#surface-1">Surface</a></h3>
<p>A Surface is a mathematical shape defined by a function and two parameters, Instead of <code>t</code> for Curves, we use <code>U</code> and <code>V</code> to describe the corresponding parameter space. This means we have more geometrical data to draw from when working with this type of Geometry. For example, Curves have tangent vectors and normal planes (which can rotate or twist along the curve's length), whereas Surfaces have normal vectors and tangent planes that will be consistent in their orientation.</p>
<p><img src="5_essential_nodes_and_concepts/5-2_geometry-for-computational-design/../images/5-2/5/Surface.jpg" alt="Surface" /></p>
<blockquote>
<ol>
<li>Surface</li>
<li>U Isocurve</li>
<li>V Isocurve</li>
<li>UV Coordinate</li>
<li>Perpendicular Plane</li>
<li>Normal Vector</li>
</ol>
</blockquote>
<p><strong>Surface Domain</strong>: A surface domain is defined as the range of (U,V) parameters that evaluate into a three dimensional point on that surface. The domain in each dimension (U or V) is usually described as two numbers (U Min to U Max) and (V Min to V Max).</p>
<p><img src="5_essential_nodes_and_concepts/5-2_geometry-for-computational-design/../images/5-2/5/SurfaceParameter.jpg" alt="Surface" /></p>
<p>Although the shape of the Surface by not look &quot;rectangular&quot; and it locally may have a tighter or looser set of isocurves, the &quot;space&quot; defined by its domain is always two dimensional. In Dynamo, Surfaces are always understood to have a domain defined by a minimum of 0.0 and maximum of 1.0 in both U and V directions. Planar or trimmed Surfaces may have different domains.</p>
<p><strong>Isocurve</strong> (or Isoparametric Curve): A curve defined by a constant U or V value on the surface and a domain of values for the corresponding other U or V direction.</p>
<p><strong>UV Coordinate</strong>: The Point in UV Parameter Space defined by U, V, and sometimes W.</p>
<p><img src="5_essential_nodes_and_concepts/5-2_geometry-for-computational-design/../images/5-2/5/SurfaceCoordinate.jpg" alt="Surface Coordinate" /></p>
<p><strong>Perpendicular Plane</strong>: A Plane that is perpendicular to both U and V Isocurves at a given UV Coordinate.</p>
<p><strong>Normal Vector</strong>: A Vector defining the direction of &quot;up&quot; relative to the Perpendicular Plane.</p>
<h3 id="nurbs-surfaces"><a class="header" href="#nurbs-surfaces">NURBS Surfaces</a></h3>
<p><strong>NURBS Surfaces</strong> are very similar to NURBS curves. You can think of NURBS Surfaces as a grid of NURBS Curves that go in two directions. The shape of a NURBS Surface is defined by a number of control points and the degree of that surface in the U and V directions. The same algorithms are used to calculate shape, normals, tangents, curvatures and other properties by way of control points, weights and degree.</p>
<p><img src="5_essential_nodes_and_concepts/5-2_geometry-for-computational-design/../images/5-2/5/NURBSsurface.jpg" alt="NURBS Surface" /></p>
<p>In the case of NURBS surfaces, there are two directions implied by the geometry, because NURBS surfaces are, regardless of the shape we see, rectangular grids of control points. And even though these directions are often arbitrary relative to the world coordinate system, we will use them frequently to analyze our models or generate other geometry based on the Surface.</p>
<p><img src="5_essential_nodes_and_concepts/5-2_geometry-for-computational-design/../images/5-2/5/NURBSsurface-Degree.jpg" alt="NURBS Surface" /></p>
<blockquote>
<ol>
<li>Degree (U,V) = (3,3)</li>
<li>Degree (U,V) = (3,1)</li>
<li>Degree (U,V) = (1,2)</li>
<li>Degree (U,V) = (1,1)</li>
</ol>
</blockquote>
<h3 id="polysurfaces"><a class="header" href="#polysurfaces">Polysurfaces</a></h3>
<p><strong>Polysurfaces</strong> are composed of Surfaces that are joined across an edge. Polysurfaces offer more than two dimensional UV definition in that we can now move through the connected shapes by way of their Topology.</p>
<p>While &quot;Topology&quot; generally describes a concept around how parts are connected and/or related Topology in Dynamo is also a type of Geometry. Specifically it is a parent category for Surfaces, Polysurfaces, and Solids.</p>
<p><img src="5_essential_nodes_and_concepts/5-2_geometry-for-computational-design/../images/5-2/5/PolySurface.jpg" alt="PolySurface" /></p>
<p>Sometimes called patches, joining Surfaces in this manner allows us to make more complex shapes as well as define detail across the seam. Conveniently we can apply a fillet or chamfer operation to the edges of a Polysurface.</p>
<div style="break-before: page; page-break-before: always;"></div><h1 id="solids"><a class="header" href="#solids">Solids</a></h1>
<h2 id="solids-in-dynamo"><a class="header" href="#solids-in-dynamo">Solids in Dynamo</a></h2>
<h3 id="what-is-solid"><a class="header" href="#what-is-solid">What is Solid?</a></h3>
<p>If we want to construct more complex models that cannot be created from a single surface or if we want to define an explicit volume, we must now venture into the realm of <a href="5_essential_nodes_and_concepts/5-2_geometry-for-computational-design/5-6_solids.html#solids">Solids </a>(and Polysurfaces). Even a simple cube is complex enough to need six surfaces, one per face. Solids give access to two key concepts that Surfaces do not - a more refined topological description (faces, edges, vertices) and Boolean operations.</p>
<h3 id="boolean-operation-to-create-spiky-ball-solid"><a class="header" href="#boolean-operation-to-create-spiky-ball-solid">Boolean Operation to Create Spiky Ball Solid</a></h3>
<p>You can use <a href="5_essential_nodes_and_concepts/5-2_geometry-for-computational-design/5-6_solids.html#boolean-operations">Boolean operations</a> to modify solids. Let's use a few Boolean operations to create a spiky ball.</p>
<p><img src="5_essential_nodes_and_concepts/5-2_geometry-for-computational-design/../images/5-2/6/solids-spikyball.jpg" alt="" /></p>
<blockquote>
<ol>
<li><strong>Sphere.ByCenterPointRadius</strong>: Create the base Solid.</li>
<li><strong>Topology.Faces</strong>, <strong>Face.SurfaceGeometry</strong>: Query the faces of the Solid and convert to surface geometryin this case, the Sphere has only one Face.</li>
<li><strong>Cone.ByPointsRadii</strong>: Construct cones using points on the surface.</li>
<li><strong>Solid.UnionAll</strong>: Union the Cones and the Sphere.</li>
<li><strong>Topology.Edges</strong>: Query the edges of the new Solid</li>
<li><strong>Solid.Fillet</strong>: Fillet the Edges of the spiky ball</li>
</ol>
</blockquote>
<blockquote>
<p>Download the example file by clicking on the link below.</p>
<p>A full list of example files can be found in the Appendix.</p>
</blockquote>
<p>{% file src=&quot;../datasets/5-2/6/Geometry for Computational Design - Solids.dyn&quot; %}</p>
<h3 id="freezing"><a class="header" href="#freezing">Freezing</a></h3>
<p>Boolean operations are complex and can be slow to calculate. Use Freeze functionality to suspend the execution of selected nodes and affected downstream nodes.</p>
<p><img src="5_essential_nodes_and_concepts/5-2_geometry-for-computational-design/../images/5-2/6/solids-freezenode.jpg" alt="" /></p>
<blockquote>
<p>1.Use the right-click contextual menu to Freeze the Solid Union operation</p>
<p>2. The selected node and all downstream nodes will preview in a light grey ghosted mode, and affected wires will be displayed as dashed lines. The affected geometry preview will also be ghosted. You can now change values upstream without calculating the boolean union.</p>
<p>3. To unfreeze the nodes, right-click and uncheck Freeze.</p>
<p>4. All affected nodes and associated geometry previews will update and revert to the standard preview mode.</p>
</blockquote>
<h2 id="deep-dive-into-4"><a class="header" href="#deep-dive-into-4">Deep Dive into...</a></h2>
<h3 id="solids-1"><a class="header" href="#solids-1">Solids</a></h3>
<p>Solids consist of one or more Surfaces that contain volume by way of a closed boundary that defines &quot;in&quot; or &quot;out.&quot; Regardless of how many of these Surfaces there are, they must form a &quot;watertight&quot; volume to be considered a Solid. Solids can be created by joining Surfaces or Polysurfaces together or by using operations such as loft, sweep, and revolve. Sphere, Cube, Cone and Cylinder primitives are also Solids. A Cube with at least one face removed counts as a Polysurface, which has some similar properties, but it is not a Solid.</p>
<p><img src="5_essential_nodes_and_concepts/5-2_geometry-for-computational-design/../images/5-2/6/Primitives.jpg" alt="Solids" /></p>
<blockquote>
<ol>
<li>A Plane is made of a single Surface and is not a Solid.</li>
<li>A Sphere is made of one Surface but <em>is</em> a Solid.</li>
<li>A Cone is made of two surfaces joined together to make a Solid.</li>
<li>A Cylinder is made of three surfaces joined together to make a Solid.</li>
<li>A Cube is made of six surfaces joined together to make a Solid.</li>
</ol>
</blockquote>
<h3 id="topology"><a class="header" href="#topology">Topology</a></h3>
<p>Solids are made up of three types of elements: Vertices, Edges, and Faces. Faces are the surfaces that make up the Solid. Edges are the Curves that define the connection between adjacent faces, and vertices are the start and end points of those Curves. These elements can be queried using the Topology nodes.</p>
<p><img src="5_essential_nodes_and_concepts/5-2_geometry-for-computational-design/../images/5-2/6/Solid-topology.jpg" alt="Topology" /></p>
<blockquote>
<ol>
<li>Faces</li>
<li>Edges</li>
<li>Vertices</li>
</ol>
</blockquote>
<h3 id="operations"><a class="header" href="#operations">Operations</a></h3>
<p>Solids can be modified by filleting or chamfering their edges to eliminate sharp corners and angles. The chamfer operation creates a ruled surface between two faces, while a fillet blends between faces to maintain tangency.</p>
<p><img src="5_essential_nodes_and_concepts/5-2_geometry-for-computational-design/../images/5-2/6/SolidOperations.jpg" alt="" /></p>
<blockquote>
<ol>
<li>Solid Cube</li>
<li>Chamfered Cube</li>
<li>Filleted Cube</li>
</ol>
</blockquote>
<h3 id="boolean-operations"><a class="header" href="#boolean-operations">Boolean Operations</a></h3>
<p>Solid Boolean operations are methods for combining two or more Solids. A single Boolean operation actually means performing four operations:</p>
<ol>
<li><strong>Intersect</strong> two or more objects.</li>
<li><strong>Split</strong> them at the intersections.</li>
<li><strong>Delete</strong> unwanted portions of the geometry.</li>
<li><strong>Join</strong> everything back together.</li>
</ol>
<p>This makes Solid Booleans a powerful time-saving process. There are three Solid Boolean operations that distinguish which parts of the geometry are kept. <img src="5_essential_nodes_and_concepts/5-2_geometry-for-computational-design/../images/5-2/6/SolidBooleans.jpg" alt="Solid Boolean" /></p>
<blockquote>
<ol>
<li><strong>Union:</strong> Remove the overlapping portions of the Solids and join them into a single Solid.</li>
<li><strong>Difference:</strong> Subtract one Solid from another. The Solid to be subtracted is referred to as a tool. Note that you could switch which Solid is the tool to keep the inverse volume.</li>
<li><strong>Intersection:</strong> Keep only the intersecting volume of the two Solids.</li>
</ol>
</blockquote>
<p>In addition to these three operations, Dynamo has <strong>Solid.DifferenceAll</strong> and <strong>Solid.UnionAll</strong> nodes for performing difference and union operations with multiple Solids. <img src="5_essential_nodes_and_concepts/5-2_geometry-for-computational-design/../images/5-2/6/BooleanAll.jpg" alt="" /></p>
<blockquote>
<ol>
<li><strong>UnionAll:</strong> Union operation with sphere and outward-facing cones</li>
<li><strong>DifferenceAll:</strong> Difference operation with sphere and inward-facing cones</li>
</ol>
</blockquote>
<h2 id=""><a class="header" href="#"></a></h2>
<div style="break-before: page; page-break-before: always;"></div><h1 id="meshes"><a class="header" href="#meshes">Meshes</a></h1>
<h2 id="mesh-in-dynamo"><a class="header" href="#mesh-in-dynamo">Mesh in Dynamo</a></h2>
<h3 id="what-is-mesh"><a class="header" href="#what-is-mesh">What is Mesh?</a></h3>
<p>In the field of computational modeling, <a href="5_essential_nodes_and_concepts/5-2_geometry-for-computational-design/7-meshes.html#mesh">Meshes </a>are one of the most pervasive forms of representing 3D geometry. Mesh geometry is generally made of a collection of quadrilaterals or triangles, it can be a light-weight and flexible alternative to working with NURBS, and Meshes are used in everything from rendering and visualizations to digital fabrication and 3D printing.</p>
<h3 id="mesh-elements"><a class="header" href="#mesh-elements">Mesh Elements</a></h3>
<p>Dynamo defines Meshes using a Face-Vertex data structure. At its most basic level, this structure is simply a collection of points which are grouped into polygons. The points of a Mesh are called vertices, while the surface-like polygons are called faces.</p>
<p>To create a Mesh we need a list of vertices and a system of grouping those vertices into faces called an index group.</p>
<p><img src="5_essential_nodes_and_concepts/5-2_geometry-for-computational-design/../images/5-2/7/meshes-meshelements.jpg" alt="" /></p>
<blockquote>
<ol>
<li>List of vertices</li>
<li>List of index groups to define faces</li>
</ol>
</blockquote>
<h3 id="mesh-toolkit"><a class="header" href="#mesh-toolkit">Mesh Toolkit</a></h3>
<p>Dynamo's mesh capabilities can be extended by installing the <a href="https://github.com/DynamoDS/Dynamo/wiki/Dynamo-Mesh-Toolkit">Mesh Toolkit</a> package. The Dynamo Mesh Toolkit provides tools to import Meshes from external file formats, create a Mesh from Dynamo geometry objects, and manually build Meshes by their vertices and indices.</p>
<p>The library also provides tools to modify Meshes, repair Meshes, or extract horizontal slices for use in fabrication.</p>
<p>Visit <a href="5_essential_nodes_and_concepts/5-2_geometry-for-computational-design/../../custom-nodes-and-packages/11-packages/11-2_mesh-toolkit.html">Mesh Toolkit case studies</a> for example on using this package.</p>
<p><img src="5_essential_nodes_and_concepts/5-2_geometry-for-computational-design/../images/5-2/7/meshes-meshtoolkitstandfordbunny.jpg" alt="Mesh Toolkit" /></p>
<h2 id="deep-dive-into-5"><a class="header" href="#deep-dive-into-5">Deep Dive into...</a></h2>
<h3 id="mesh"><a class="header" href="#mesh">Mesh</a></h3>
<p>A Mesh is a collection of quadrilaterals and triangles that represents a surface or solid geometry. Like Solids, the structure of a Mesh object includes vertices, edges, and faces. There are additional properties that make Meshes unique as well, such as normals.</p>
<p><img src="5_essential_nodes_and_concepts/5-2_geometry-for-computational-design/../images/5-2/7/MeshElements2.jpg" alt="Mesh Elements" /></p>
<blockquote>
<ol>
<li>Mesh vertices</li>
<li>Mesh edges *Edges with only one adjoining face are called &quot;Naked.&quot; All other edges are &quot;Clothed&quot;</li>
<li>Mesh faces</li>
</ol>
</blockquote>
<h3 id="vertices--vertex-normals"><a class="header" href="#vertices--vertex-normals">Vertices + Vertex Normals</a></h3>
<p>The vertices of a Mesh are simply a list of points. The index of the vertices is very important when constructing a Mesh, or getting information about the structure of a Mesh. For each vertex, there is also a corresponding vertex normal (vector) which describes the average direction of the attached faces and helps us understand the &quot;in&quot; and &quot;out&quot; orientation of the Mesh.</p>
<p><img src="5_essential_nodes_and_concepts/5-2_geometry-for-computational-design/../images/5-2/7/vertexNormals.jpg" alt="Vertices + Normals" /></p>
<blockquote>
<ol>
<li>Vertices</li>
<li>Vertex Normals</li>
</ol>
</blockquote>
<h3 id="faces"><a class="header" href="#faces">Faces</a></h3>
<p>A face is an ordered list of three or four vertices. The surface representation of a Mesh face is therefore implied according to the position of the vertices being indexed. We already have the list of vertices that make up the Mesh, so instead of providing individual points to define a face, we simply use the index of the vertices. This also allows us to use the same vertex in more than one face.</p>
<p><img src="5_essential_nodes_and_concepts/5-2_geometry-for-computational-design/../images/5-2/7/meshFaces.jpg" alt="" /></p>
<blockquote>
<ol>
<li>A quad face made with indices 0, 1, 2, and 3</li>
<li>A triangle face made with indices 1, 4, and 2 Note that the index groups can be shifted in their order - as long as the sequence is ordered in a counter-clockwise manner, the face will be defined correctly</li>
</ol>
</blockquote>
<h3 id="meshes-versus-nurbs-surfaces"><a class="header" href="#meshes-versus-nurbs-surfaces">Meshes versus NURBS Surfaces</a></h3>
<p>How is Mesh geometry different from NURBS geometry? When might you want to use one instead of the other?</p>
<h4 id="parameterization"><a class="header" href="#parameterization">Parameterization</a></h4>
<p>In a previous chapter, we saw that NURBS surfaces are defined by a series of NURBS curves going in two directions. These directions are labeled <code>U</code> and <code>V</code>, and allow a NURBs surface to be parameterized according to a two-dimensional surface domain. The curves themselves are stored as equations in the computer, allowing the resulting surfaces to be calculated to an arbitrarily small degree of precision. It can be difficult, however, to combine multiple NURBS surfaces together. Joining two NURBS surfaces will result in a polysurface, where different sections of the geometry will have different UV parameters and curve definitions.</p>
<p><img src="5_essential_nodes_and_concepts/5-2_geometry-for-computational-design/../images/5-2/7/NURBSvsMESH-01.jpg" alt="Control Points" /></p>
<blockquote>
<ol>
<li>Surface</li>
<li>Isoparametric (Isoparm) Curve</li>
<li>Surface Control Point</li>
<li>Surface Control Polygon</li>
<li>Isoparametric Point</li>
<li>Surface Frame</li>
<li>Mesh</li>
<li>Naked Edge</li>
<li>Mesh Network</li>
<li>Mesh Edges</li>
<li>Vertex Normal</li>
<li>Mesh Face / Mesh Face Normal</li>
</ol>
</blockquote>
<p>Meshes, on the other hand, are comprised of a discrete number of exactly defined vertices and faces. The network of vertices generally cannot be defined by simple <code>UV</code> coordinates, and because the faces are discrete the amount of precision is built into the Mesh and can only be changed by refining the Mesh and adding more faces. The lack of mathematical descriptions allows Meshes to more flexibly handle complex geometry within a single Mesh.</p>
<h3 id="local-versus-global-influence"><a class="header" href="#local-versus-global-influence">Local versus Global Influence</a></h3>
<p>Another important difference is the extent to which a local change in Mesh or NURBS geometry affects the entire form. Moving one vertex of a Mesh only affects the faces that are adjacent to that vertex. In NURBS surfaces, the extent of the influence is more complicated and depends on the degree of the surface as well as the weights and knots of the control points. In general, however, moving a single control point in a NURBS surface creates a smoother, more extensive change in geometry.</p>
<p><img src="5_essential_nodes_and_concepts/5-2_geometry-for-computational-design/../images/5-2/7/NURBSvsMESH-02.jpg" alt="Editing" /></p>
<blockquote>
<ol>
<li>NURBS Surface - moving a control point has influence that extends across the shape</li>
<li>Mesh geometry - moving a vertex has influence only on adjacent elements</li>
</ol>
</blockquote>
<p>One analogy that can be helpful is to compare a vector image (composed of lines and curves) with a raster image (composed of individual pixels). If you zoom into a vector image, the curves remain crisp and clear, while zooming into a raster image results in seeing individual pixels become larger. In this analogy, NURBS surfaces can be compared to a vector image because there is a smooth mathematical relationship, while a Mesh behaves similarly to a raster image with a set resolution.</p>
<h2 id="-1"><a class="header" href="#-1"></a></h2>
<div style="break-before: page; page-break-before: always;"></div><h1 id="the-building-blocks-of-programs"><a class="header" href="#the-building-blocks-of-programs">The Building Blocks of Programs</a></h1>
<p>Once we are ready to dive deeper into developing Visual Programs, we will need a deeper understanding of the building blocks we will use. This chapter introduces fundamental concepts around data - the stuff that travels through the Wires of our Dynamo program.</p>
<p><img src="5_essential_nodes_and_concepts/5-3_the-building-blocks-of-programs/../images/5-3/buildingblocksofprogram.png" alt="" /></p>
<div style="break-before: page; page-break-before: always;"></div><h1 id="data"><a class="header" href="#data">Data</a></h1>
<p>Data is the stuff of our programs. It travels through Wires, supplying inputs for Nodes where it gets processed into a new form of output data. Let's review the definition of data, how it's structured, and begin using it in Dynamo.</p>
<h2 id="what-is-data"><a class="header" href="#what-is-data">What is Data?</a></h2>
<p>Data is a set of values of qualitative or quantitative variables. The simplest form of data is numbers such as <code>0</code>, <code>3.14</code>, or <code>17</code>. But data can also be of a number of different types: a variable representing changing numbers (<code>height</code>); characters (<code>myName</code>); geometry (<code>Circle</code>); or a list of data items (<code>1,2,3,5,8,13,...</code>).</p>
<p>In Dynamo, we add/feed data to the input Ports of Nodes - we can have data without actions but we need data to process the actions that our Nodes represent. When we've added a Node to the Workspace, if it doesn't have any inputs supplied, the result will be a function, not the result of the action itself.</p>
<p><img src="5_essential_nodes_and_concepts/5-3_the-building-blocks-of-programs/../images/5-3/1/data-whatisdata.jpg" alt="Data and Actions" /></p>
<blockquote>
<ol>
<li>Simple Data</li>
<li>Data and Action (A Node) successfully executes</li>
<li>Action (A Node) without Data Inputs returns a generic function</li>
</ol>
</blockquote>
<h3 id="null---absence-of-data"><a class="header" href="#null---absence-of-data">Null - Absence of Data</a></h3>
<p>Beware of Nulls The <code>'null'</code> type represents the absence of data. While this is an abstract concept, you will likely come across this while working with Visual Programming. If an action doesn't create a valid result, the Node will return a null.</p>
<p>Testing for nulls and removing nulls from data structure is a crucial part to creating robust programs.</p>
<div class="table-wrapper"><table><thead><tr><th>Icon</th><th>Name/Syntax</th><th>Inputs</th><th>Outputs</th></tr></thead><tbody>
<tr><td><img src="5_essential_nodes_and_concepts/5-3_the-building-blocks-of-programs/../images/5-3/1/data-objectIsNull.jpg" alt="" /></td><td>Object.IsNull</td><td>obj</td><td>bool</td></tr>
</tbody></table>
</div>
<h3 id="data-structures"><a class="header" href="#data-structures">Data Structures</a></h3>
<p>When we are Visual Programming, we can very quickly generate a lot of data and require a means of managing its hierarchy. This is the role of Data Structures, the organizational schemes in which we store data. The specifics of Data Structures and how to use them vary from programming language to programming language.</p>
<p>In Dynamo, we add hierarchy to our data through Lists. We will explore this in depth in later chapters, but let's start simply:</p>
<p>A list represents a collection of items placed into one structure of data:</p>
<ul>
<li>I have five fingers (<em>items</em>) on my hand (<em>list</em>).</li>
<li>There are ten houses (<em>items</em>) on my street (<em>list</em>).</li>
</ul>
<p><img src="5_essential_nodes_and_concepts/5-3_the-building-blocks-of-programs/../images/5-3/1/data-datastructures.jpg" alt="List Breakdown" /></p>
<blockquote>
<ol>
<li>A <strong>Number Sequence</strong> node defines a list of numbers by using a <em>start</em>, <em>amount</em>, and <em>step</em> input. With these nodes, we've created two separate lists of ten numbers, one which ranges from <em>100-109</em> and another which ranges from <em>0-9</em>.</li>
<li>The <strong>List.GetItemAtIndex</strong> node selects an item in a list at a specific index. When choosing <em>0</em>, we get the first item in the list (<em>100</em> in this case).</li>
<li>Applying the same process to the second list, we get a value of <em>0</em>, the first item in the list.</li>
<li>Now we merge the two lists into one by using the <strong>List.Create</strong> node. Notice that the node creates a <em>list of lists.</em> This changes the structure of the data.</li>
<li>When using <strong>List.GetItemAtIndex</strong> again, with index set to <em>0</em>, we get the first list in the list of lists. This is what it means to treat a list as an item, which is somewhat different from other scripting languages. We will get more advanced with list manipulation and data structure in later chapters.</li>
</ol>
</blockquote>
<p>The key concept to understand about data hierarchy in Dynamo: <strong>with respect to data structure, lists are regarded as items.</strong> In other words, Dynamo functions with a top-down process for understanding data structures. What does this mean? Let's walk through it with an example.</p>
<h2 id="exercise-using-data-to-make-a-chain-of-cylinders"><a class="header" href="#exercise-using-data-to-make-a-chain-of-cylinders">Exercise: Using Data to Make a Chain of Cylinders</a></h2>
<blockquote>
<p>Download the example file by clicking on the link below.</p>
<p>A full list of example files can be found in the Appendix.</p>
</blockquote>
<p>{% file src=&quot;../datasets/5-3/1/Building Blocks of Programs - Data.dyn&quot; %}</p>
<p>In this first example, we assemble a shelled cylinder which walks through the geometry hierarchy discussed in this section.</p>
<h3 id="part-i-set-up-graph-for-one-cylinder-with-some-changeable-parameters"><a class="header" href="#part-i-set-up-graph-for-one-cylinder-with-some-changeable-parameters">Part I: Set up Graph for one cylinder with some changeable parameters.</a></h3>
<p>1.Add <strong>Point.ByCoordinates -</strong> after adding the node to canvas, we see a point at the origin of the Dynamo preview grid. The default values of the <em>x,y</em>, and <em>z</em> inputs are <em>0.0</em>, giving us a point at this location.</p>
<p><img src="5_essential_nodes_and_concepts/5-3_the-building-blocks-of-programs/../images/5-3/1/data-exercisestep1.jpg" alt="" /></p>
<p>2. <strong>Plane.ByOriginNormal -</strong> The next step in the geometry hierarchy is a plane. There are several ways to construct a plane, and we are using an origin and normal for the input. The origin is the point node created in the previous step.</p>
<p><strong>Vector.ZAxis -</strong> this is a unitized vector in the z direction. Notice there are not inputs, only a vector of [0,0,1] value. We use this as the <em>normal</em> input for the <strong>Plane.ByOriginNormal</strong> node. This gives us a rectangular plane in the Dynamo preview.</p>
<p><img src="5_essential_nodes_and_concepts/5-3_the-building-blocks-of-programs/../images/5-3/1/data-exercisestep2.jpg" alt="" /></p>
<p>3. <strong>Circle.ByPlaneRadius -</strong> Stepping up the hierarchy, we now create a curve from the plane in our previous step. After plugging into the node, we get a circle at the origin. The default radius on the node is value of <em>1</em>.</p>
<p><img src="5_essential_nodes_and_concepts/5-3_the-building-blocks-of-programs/../images/5-3/1/data-exercisestep3.jpg" alt="" /></p>
<p>4. <strong>Curve.Extrude -</strong> Now we make this thing pop by giving it some depth and going in the third dimension. This node creates a surface from a curve by extruding it. The default distance on the node is <em>1</em>, and we should see a cylinder in the viewport.</p>
<p><img src="5_essential_nodes_and_concepts/5-3_the-building-blocks-of-programs/../images/5-3/1/data-exercisestep4.jpg" alt="" /></p>
<p>5. <strong>Surface.Thicken -</strong> This node gives us a closed solid by offsetting the surface a given distance and closing the form. The default thickness value is <em>1</em>, and we see a shelled cylinder in the viewport in line with these values.</p>
<p><img src="5_essential_nodes_and_concepts/5-3_the-building-blocks-of-programs/../images/5-3/1/data-exercisestep5.jpg" alt="" /></p>
<p>6. <strong>Number Slider -</strong> Rather than using the default values for all of these inputs, let's add some parametric control to the model.</p>
<p><strong>Domain Edit -</strong> after adding the number slider to the canvas, click the caret in the top left to reveal the domain options.</p>
<p><strong>Min/Max/Step -</strong> change the <em>min</em>, <em>max</em>, and <em>step</em> values to <em>0</em>,<em>2</em>, and <em>0.01</em> respectively. We are doing this to control the size of the overall geometry.</p>
<p><img src="5_essential_nodes_and_concepts/5-3_the-building-blocks-of-programs/../images/5-3/1/data-exercisestep6.gif" alt="" /></p>
<p>7. <strong>Number Sliders -</strong> In all of the default inputs, let's copy and paste this number slider (select the slider, hit Ctrl+C, then Ctrl+V) several times, until all of the inputs with defaults have a slider instead. Some of the slider values will have to be larger than zero to get the definition to work (ie: you need an extrusion depth in order to have a surface to thicken).</p>
<p><img src="5_essential_nodes_and_concepts/5-3_the-building-blocks-of-programs/../images/5-3/1/data-exercisestep7a.gif" alt="" /></p>
<p><img src="5_essential_nodes_and_concepts/5-3_the-building-blocks-of-programs/../images/5-3/1/data-exercisestep7b.gif" alt="" /></p>
<p>8. We've now created a parametric shelled cylinder with these sliders. Try to flex some of these parameters and see the geometry update dynamically in the Dynamo viewport.</p>
<p><img src="5_essential_nodes_and_concepts/5-3_the-building-blocks-of-programs/../images/5-3/1/data-exercisestep8a.gif" alt="" /></p>
<p><strong>Number Sliders -</strong> taking this a step further, we've added a lot of sliders to the canvas, and need to clean up the interface of the tool we just created. Right click on one slider, select &quot;Rename...&quot; and change each slider to the appropriate name for its parameter (thickness, Radius, Height, etc).</p>
<p><img src="5_essential_nodes_and_concepts/5-3_the-building-blocks-of-programs/../images/5-3/1/data-exercisestep8bstep.jpg" alt="" /></p>
<h3 id="part-ii-populate-an-array-of-cylinders-from-part-i"><a class="header" href="#part-ii-populate-an-array-of-cylinders-from-part-i">Part II: Populate an array of cylinders from Part I</a></h3>
<p>9. At this point, we've created an awesome thickening cylinder thing. This is one object currently, let's look at how to create an array of cylinders that remains dynamically linked. To do this, we're going to create a list of cylinders, rather than working with a single item.</p>
<p><strong>Addition (+) -</strong> Our goal is to add a row of cylinders next to the cylinder we've created. If we want to add one cylinder adjacent to the current one, we need to consider both radius of the cylinder and the thickness of its shell. We get this number by adding the two values of the sliders.</p>
<p><img src="5_essential_nodes_and_concepts/5-3_the-building-blocks-of-programs/../images/5-3/1/data-exercisestep9.jpg" alt="" /></p>
<p>10. This step is more involved so let's walk through it slowly: the end goal is to create a list of numbers which define the locations of each cylinder in a row.</p>
<p><img src="5_essential_nodes_and_concepts/5-3_the-building-blocks-of-programs/../images/5-3/1/data-exercisestep10.jpg" alt="" /></p>
<blockquote>
<p>a. <strong>Multiplication -</strong> First, we want to multiply the value from the previous step by 2. The value from the previous step represents a radius, and we want to move the cylinder the full diameter.</p>
<p>b. <strong>Number Sequence -</strong> we create an array of numbers with this node. The first input is the <em>multiplication</em> node from the previous step into the <em>step</em> value. The <em>start</em> value can be set to <em>0.0</em> using a <em>number</em> node.</p>
<p>c. <strong>Integer Slider</strong> - For the <em>amount</em> value, we connect an integer slider. This will define how many cylinders are created.</p>
<p>d. <strong>Output</strong> - This list shows us the distance moved for each cylinder in the array, and is parametrically driven by the original sliders.</p>
</blockquote>
<p>11. This step is simple enough - plug the sequence defined in the previous step into the <em>x</em> input of the original <strong>Point.ByCoordinates</strong>. This will replace the slider <em>pointX</em> which we can delete. We now see an array of cylinders in the viewport (make sure the integer slider is larger than 0).</p>
<p><img src="5_essential_nodes_and_concepts/5-3_the-building-blocks-of-programs/../images/5-3/1/data-exercisestep11.gif" alt="" /></p>
<p>12. The chain of cylinders is still dynamically linked to all of the sliders. Flex each slider to watch the definition update!</p>
<p><img src="5_essential_nodes_and_concepts/5-3_the-building-blocks-of-programs/../images/5-3/1/data-exercisestep12.gif" alt="" /></p>
<div style="break-before: page; page-break-before: always;"></div><h1 id="math-1"><a class="header" href="#math-1">Math</a></h1>
<p>If the simplest form of data is numbers, the easiest way to relate those numbers is through Mathematics. From simple operators like divide to trigonometric functions, to more complex formulas, Math is a great way to start exploring numeric relationships and patterns.</p>
<h3 id="arithmetic-operators"><a class="header" href="#arithmetic-operators">Arithmetic Operators</a></h3>
<p>Operators are a set of components that use algebraic functions with two numeric input values, which result in one output value (addition, subtraction, multiplication, division, etc.). These can be found under Operators&gt;Actions.</p>
<div class="table-wrapper"><table><thead><tr><th>Icon</th><th>Name (Syntax)</th><th>Inputs</th><th>Outputs</th></tr></thead><tbody>
<tr><td><img src="5_essential_nodes_and_concepts/5-3_the-building-blocks-of-programs/../images/5-3/2/addition.jpg" alt="" /></td><td>Add (<strong>+</strong>)</td><td>var[]...[], var[]...[]</td><td>var[]...[]</td></tr>
<tr><td><img src="5_essential_nodes_and_concepts/5-3_the-building-blocks-of-programs/../images/5-3/2/Subtraction.jpg" alt="" /></td><td>Subtract (<strong>-</strong>)</td><td>var[]...[], var[]...[]</td><td>var[]...[]</td></tr>
<tr><td><img src="5_essential_nodes_and_concepts/5-3_the-building-blocks-of-programs/../images/5-3/2/Multiplication.jpg" alt="" /></td><td>Multiply (<strong>*</strong>)</td><td>var[]...[], var[]...[]</td><td>var[]...[]</td></tr>
<tr><td><img src="5_essential_nodes_and_concepts/5-3_the-building-blocks-of-programs/../images/5-3/2/Division.jpg" alt="" /></td><td>Divide (<strong>/</strong>)</td><td>var[]...[], var[]...[]</td><td>var[]...[]</td></tr>
</tbody></table>
</div>
<h2 id="exercise-the-golden-spiral-formula"><a class="header" href="#exercise-the-golden-spiral-formula">Exercise: The Golden Spiral Formula</a></h2>
<blockquote>
<p>Download the example file by clicking on the link below.</p>
<p>A full list of example files can be found in the Appendix.</p>
</blockquote>
<p>{% file src=&quot;../datasets/5-3/2/Building Blocks of Programs - Math.dyn&quot; %}</p>
<h3 id="part-i-parametric-formula"><a class="header" href="#part-i-parametric-formula">Part I: Parametric Formula</a></h3>
<p>Combine operators and variables to form a more complex relationship through <strong>Formulas</strong>. Use sliders to make a Formula that can be controlled with input parameters.</p>
<p>1.Create Number sequence that represents the 't' in the parametric equation, so we want to use a list that's large enough to define a spiral.</p>
<p><strong>Number Sequence:</strong> define a number sequence based on three inputs: <em>start, amount</em> and <em>step</em>.</p>
<p><img src="5_essential_nodes_and_concepts/5-3_the-building-blocks-of-programs/../images/5-3/2/math-partI-01.jpg" alt="" /></p>
<p>2. The step above has created a list of numbers to define the parametric domain. Next, create group of Nodes represent the golden spiral equation.</p>
<p>The golden spiral is defined as the equation:</p>
<p>$$
x = r cos  = a cos  e^{b}
$$</p>
<p>$$
y = r sin  = a sin e^{b}
$$</p>
<p>The image below represents the golden spiral in in visual programming form. When stepping through the group of Nodes, try to pay attention to the parallel between the visual program and written equation.</p>
<p><img src="5_essential_nodes_and_concepts/5-3_the-building-blocks-of-programs/../images/5-3/2/math-partI-02.jpg" alt="" /></p>
<blockquote>
<p>a. <strong>Number Slider</strong>: Add two number sliders to the canvas. These sliders will represent the <em>a</em> and the <em>b</em> variables of the parametric equation. These represent a constant which is flexible, or parameters which we can adjust towards a desired outcome.</p>
<p>b. <strong>Multiplication (*)</strong> : The multiplication Node is represented by an asterisk. We'll use this repeatedly to connect multiplying variables</p>
<p>c. <strong>Math.RadiansToDegrees</strong>: The '<em>t</em>' values need to be translated to degrees for their evaluation in the trigonometric functions. Remember, Dynamo defaults to degrees for evaluating these functions.</p>
<p>d. <strong>Math.Pow</strong>: as a function of the '<em>t</em>' and the number '<em>e</em>' this creates the Fibonacci sequence.</p>
<p>e. <strong>Math.Cos and Math.Sin</strong>: These two trigonmetric functions will differentiate the x-coordinate and the y-coordinate, respectively, of each parametric point.</p>
<p>f. <strong>Watch</strong>: We now see that our output is two lists, these will be the <em>x</em> and <em>y</em> coordinates of the points used to generate the spiral.</p>
</blockquote>
<h3 id="part-ii-from-formula-to-geometry"><a class="header" href="#part-ii-from-formula-to-geometry">Part II: From Formula to Geometry</a></h3>
<p>Now, the bulk of Nodes from the previous step will work fine, but it is a lot of work. To create a more efficient workflow, have a look at <a href="5_essential_nodes_and_concepts/5-3_the-building-blocks-of-programs/../../8_coding_in_dynamo/8-1_code-blocks-and-design-script/2-design-script-syntax.html">DesignScript </a>to define a string of Dynamo expressions into one node. In this next series of steps, we'll look at using the parametric equation to draw the Fibonacci spiral.</p>
<p><strong>Point.ByCoordinates:</strong> Connect the upper multiplication node into the '<em>x</em>' input and the lower into the '<em>y</em>' input. We now see a parametric spiral of points on the screen.</p>
<p><img src="5_essential_nodes_and_concepts/5-3_the-building-blocks-of-programs/../images/5-3/2/math-partII-01.gif" alt="" /></p>
<p><strong>Polycurve.ByPoints:</strong> Connect <strong>Point.ByCoordinates</strong> from the previous step into <em>points</em>. We can leave <em>connectLastToFirst</em> without an input because we aren't making a closed curve. This creates a spiral which passes through each point defined in the previous step.</p>
<p><img src="5_essential_nodes_and_concepts/5-3_the-building-blocks-of-programs/../images/5-3/2/math-partII-02.jpg" alt="" /></p>
<p>We've now completed the Fibonacci Spiral! Let's take this further into two separate exercises from here, which we'll call the Nautilus and the Sunflower. These are abstractions of natural systems, but the two different applications of the Fibonacci spiral will be well represented.</p>
<h3 id="part-iii-from-spiral-to-nautilus"><a class="header" href="#part-iii-from-spiral-to-nautilus">Part III: From Spiral to Nautilus</a></h3>
<p><strong>Circle.ByCenterPointRadius:</strong> We'll use a circle Node here with the same inputs as the previous step. The radius value defaults to <em>1.0</em>, so we see an immediate output of circles. It becomes immediately legible how the points diverge further from the origin.</p>
<p><img src="5_essential_nodes_and_concepts/5-3_the-building-blocks-of-programs/../images/5-3/2/math-partIII-01.jpg" alt="" /></p>
<p><strong>Number Sequence:</strong> This is the original array of '<em>t</em>'. By plugging this into the radius value of <strong>Circle.ByCenterPointRadius</strong>, the circle centers are still diverging further from the origin, but the radius of the circles is increasing, creating a funky Fibonacci circle graph.</p>
<p>Bonus points if you make it 3D!</p>
<p><img src="5_essential_nodes_and_concepts/5-3_the-building-blocks-of-programs/../images/5-3/2/math-partIII-02.gif" alt="" /></p>
<h3 id="part-iv-from-nautilus-to-phyllotaxis"><a class="header" href="#part-iv-from-nautilus-to-phyllotaxis">Part IV: From Nautilus to Phyllotaxis</a></h3>
<p>Pattern Now that we've made a circular Nautilus shell, let's jump into parametric grids. We're going to use a basic rotate on the Fibonacci Spiral to create a Fibonacci grid, and the result is modeled after the <a href="https://blogs.unimelb.edu.au/sciencecommunication/2018/09/02/this-flower-uses-maths-to-reproduce/">growth of sunflower seeds</a>.</p>
<p>As a jumping-off point, let's start with the same step from the previous exercise: creating a spiral array of points with the <strong>Point.ByCoordinates</strong> Node.</p>
<p>![](../images/5-3/2/math-part IV-01.jpg)</p>
<p>Next, follow these mini steps to generate a series of spiral at various rotation.</p>
<p><img src="5_essential_nodes_and_concepts/5-3_the-building-blocks-of-programs/../images/5-3/2/math-partIV-02.jpg" alt="" /></p>
<blockquote>
<p>a. <strong>Geometry.Rotate:</strong> There are several <strong>Geometry.Rotate</strong> options; be certain you've chosen the Node with <em>geometry</em>,<em>basePlane</em>, and <em>degrees</em> as its inputs. Connect <strong>Point.ByCoordinates</strong> into the geometry input. Right click on this Node and make sure the lacing is set to 'Cross Product'</p>
<p><img src="5_essential_nodes_and_concepts/5-3_the-building-blocks-of-programs/../images/5-3/2/math-partIV-03crossproduct.jpg" alt="" /></p>
<p>b. <strong>Plane.XY:</strong> Connect to the <em>basePlane</em> input. We will rotate around the origin, which is the same location as the base of the spiral.</p>
<p>c. <strong>Number Range:</strong> For our degree input, we want to create multiple rotations. We can do this quickly with a <strong>Number Range</strong> component. Connect this into the <em>degrees</em> input.</p>
<p>d. <strong>Number:</strong> And to define the range of numbers, add three number nodes to the canvas in vertical order. From top to bottom, assign values of <em>0.0,360.0,</em> and <em>120.0</em> respectively. These are driving the rotation of the spiral. Notice the output results from the <strong>Number Range</strong> node after connecting the three number nodes to the Node.</p>
</blockquote>
<p>Our output is beginning to resemble a whirlpool. Let's adjust some of the <strong>Number Range</strong> parameters and see how the results change.</p>
<p>Change the step size of the <strong>Number Range</strong> node from <em>120.0</em> to <em>36.0</em>. Notice that this is creating more rotations and is therefore giving us a denser grid.</p>
<p><img src="5_essential_nodes_and_concepts/5-3_the-building-blocks-of-programs/../images/5-3/2/math-partIV-04.jpg" alt="" /></p>
<p>Change the step size of the <strong>Number Range</strong> node from <em>36.0</em> to <em>3.6</em>. This now gives us a much denser grid, and the directionality of the spiral is unclear. Ladies and gentlemen, we've created a sunflower.</p>
<p><img src="5_essential_nodes_and_concepts/5-3_the-building-blocks-of-programs/../images/5-3/2/math-partIV-05.jpg" alt="" /></p>
<div style="break-before: page; page-break-before: always;"></div><h1 id="logic-1"><a class="header" href="#logic-1">Logic</a></h1>
<p><strong>Logic</strong>, or more specifically, <strong>Conditional Logic</strong>, allows us to specify an action or set of actions based on a test. After evaluating the test, we will have a Boolean value representing <code>True</code> or <code>False</code> that we can use to control the Program Flow.</p>
<h3 id="booleans"><a class="header" href="#booleans">Booleans</a></h3>
<p>Numeric variables can store a whole range of different numbers. Boolean variables can only store two values referred to as True or False, Yes or No, 1 or 0. We rarely use booleans to perform calculations because of their limited range.</p>
<h3 id="conditional-statements"><a class="header" href="#conditional-statements">Conditional Statements</a></h3>
<p>The &quot;If&quot; statement is a key concept in programming: &quot;If <em>this</em> is true, then <em>that</em> happens, otherwise <em>something else</em> happens. The resulting action of the statement is driven by a boolean value. There are multiple ways to define an &quot;If&quot; statement in Dynamo:</p>
<div class="table-wrapper"><table><thead><tr><th>Icon</th><th>Name (Syntax)</th><th>Inputs</th><th>Outputs</th></tr></thead><tbody>
<tr><td><img src="5_essential_nodes_and_concepts/5-3_the-building-blocks-of-programs/../images/5-3/3/If.jpg" alt="" /></td><td>If (<strong>If</strong>)</td><td>test, true, false</td><td>result</td></tr>
<tr><td><img src="5_essential_nodes_and_concepts/5-3_the-building-blocks-of-programs/../images/5-3/3/Formula.jpg" alt="" /></td><td>Formula (<strong>IF(x,y,z)</strong>)</td><td>x, y, z</td><td>result</td></tr>
<tr><td><img src="5_essential_nodes_and_concepts/5-3_the-building-blocks-of-programs/../images/5-3/3/CodeBlock.jpg" alt="" /></td><td>Code Block (<strong>(x?y:z);</strong>)</td><td>x? y, z</td><td>result</td></tr>
</tbody></table>
</div>
<p>Let's go over a brief example on each of these three nodes in action using the conditional &quot;If&quot; statement.</p>
<p>In this image, the <em>boolean</em> is set to <em>true</em>, which means that the result is a string reading: <em>&quot;this is the result if true&quot;.</em> The three Nodes creating the <em>If</em> statement are working identically here.</p>
<p><img src="5_essential_nodes_and_concepts/5-3_the-building-blocks-of-programs/../images/5-3/3/logic-conditionalstatements01false.jpg" alt="" /></p>
<p>Again, the Nodes are working identically. If the <em>boolean</em> is changed to <em>false</em>, our result is the number <em>Pi</em>, as defined in the original <em>If</em> statement.</p>
<p><img src="5_essential_nodes_and_concepts/5-3_the-building-blocks-of-programs/../images/5-3/3/logic-conditionalstatements02true.jpg" alt="" /></p>
<h2 id="exercise-logic-and-geometry"><a class="header" href="#exercise-logic-and-geometry">Exercise: Logic and Geometry</a></h2>
<blockquote>
<p>Download the example file by clicking on the link below.</p>
<p>A full list of example files can be found in the Appendix.</p>
</blockquote>
<p>{% file src=&quot;../datasets/5-3/3/Building Blocks of Programs - Logic.dyn&quot; %}</p>
<h3 id="part-i-filtering-a-list"><a class="header" href="#part-i-filtering-a-list">Part I: Filtering a List</a></h3>
<ol>
<li>Let's use logic to separate a list of numbers into a list of even numbers and a list of odd numbers.</li>
</ol>
<p><img src="5_essential_nodes_and_concepts/5-3_the-building-blocks-of-programs/../images/5-3/3/logic-exercisepartI-01.jpg" alt="" /></p>
<blockquote>
<p>a. <strong>Number Range -</strong> add a number range to the canvas.</p>
<p>b. <strong>Numbers -</strong> add three number nodes to the canvas. The value for each number node should be: <em>0.0</em> for <em>start</em>, <em>10.0</em> for <em>end</em>, and <em>1.0</em> for <em>step</em>.</p>
<p>c. <strong>Output</strong> - our output is a list of 11 numbers ranging from 0-10.</p>
<p>d. <strong>Modulo (%)-</strong> <strong>Number Range</strong> into <em>x</em> and <em>2.0</em> into <em>y</em>. This calculates the remainder for each number in the list divided by 2. The output from this list gives us a list of values alternating between 0 and 1.</p>
<p>e. <strong>Equality Test (==) -</strong> add an equality test to the canvas. Plug <em>modulo</em> output into the <em>x</em> input and <em>0.0</em> into the <em>y</em> input.</p>
<p>f. <strong>Watch -</strong> The output of the equality test is a list of values alternating between true and false. These are the values used to separate the items in the list. <em>0</em> (or <em>true</em>) represents even numbers and (<em>1</em>, or <em>false</em>) represents odd numbers.</p>
<p>g. <strong>List.FilterByBoolMask -</strong> this Node will filter the values into two different lists based on the input boolean. Plug the original <em>number range</em> into the <em>list</em> input and the <em>equality test</em> output into the <em>mask</em> input. The <em>in</em> output represents true values while the <em>out</em> output represents false values.</p>
<p>h. <strong>Watch</strong> - as a result, we now have a list of even numbers and a list of odd numbers. We've used logical operators to separate lists into patterns!</p>
</blockquote>
<h3 id="part-ii-from-logic-to-geometry"><a class="header" href="#part-ii-from-logic-to-geometry">Part II: From Logic to Geometry</a></h3>
<p>Building off of the logic established in the first exercise, let's apply this setup into a modeling operation.</p>
<p>2. We'll jump off from the previous exercise with the same Nodes. The only exceptions (in addition to changing the format are):</p>
<p><img src="5_essential_nodes_and_concepts/5-3_the-building-blocks-of-programs/../images/5-3/3/logic-exercisepartII-01.jpg" alt="" /></p>
<blockquote>
<p>a. Use a <strong>Sequence</strong> Node with these input values.</p>
<p>b. We've unplugged the in list input into <strong>List.FilterByBoolMask</strong>. We'll put these Nodes aside for now, but they'll come in handy later in the exercise.</p>
</blockquote>
<p>3. Let's begin by creating a separate group of Graph as shown in the image above. This group of Nodes represents a parametric equation to define a line curve. A few notes:</p>
<p><img src="5_essential_nodes_and_concepts/5-3_the-building-blocks-of-programs/../images/5-3/3/logic-exercisepartII-02.jpg" alt="" /></p>
<blockquote>
<p>a. The first <strong>Number Slider</strong> represents the frequency of the wave, it should have a min of 1, a max of 4, and a step of 0.01.</p>
<p>b. The second <strong>Number Slider</strong> represents the amplitude of the wave, should have a min of 0, a max of 1, and a step of 0.01.</p>
<p>c. <strong>PolyCurve.ByPoints -</strong> if the above Node diagram is copied, the result is a sine curve in the Dynamo Preview viewport.</p>
</blockquote>
<p>The method here for the inputs: use number nodes for more static properties and number sliders on the more flexible ones. We want to keep the original number range that we're defining in the beginning of this step. However, the sine curve that we create here should have some flexibility. We can move these sliders to watch the curve update its frequency and amplitude.</p>
<p><img src="5_essential_nodes_and_concepts/5-3_the-building-blocks-of-programs/../images/5-3/3/logic-exercisepartII-03.gif" alt="" /></p>
<p>4. We're going to jump around a bit in the definition, so let's look at the end result so that we can reference what we're getting at. The first two steps are made separately, we now want to connect the two. We'll use the base sine curve to drive the location of the zipper components, and we'll use the true/false logic to alternate between little boxes and larger boxes.</p>
<p><img src="5_essential_nodes_and_concepts/5-3_the-building-blocks-of-programs/../images/5-3/3/logic-exercisepartII-04.jpg" alt="" /></p>
<blockquote>
<p>a. <strong>Math.RemapRange</strong> - Using the number sequence created in step 02, let's create a new series of numbers by remapping the range. The original numbers from step 01 range from 0-100. These numbers range from 0 to 1 by the <em>newMin</em> and <em>newMax</em> inputs respectively.</p>
</blockquote>
<p>5. Create a <strong>Curve.PointAtParameter</strong> Node, then connect the <strong>Math.RemapRange</strong> output from step 04 as its <em>param</em> input.</p>
<p><img src="5_essential_nodes_and_concepts/5-3_the-building-blocks-of-programs/../images/5-3/3/logic-exercisepartII-05.jpg" alt="" /></p>
<p>This step creates points along the curve. We remapped the numbers to 0 to 1 because the input of <em>param</em> is looking for values in this range. A value of <em>0</em> represents the start point, a value of <em>1</em> represents the end points. All numbers in between evaluate within the <em>[0,1]</em> range.</p>
<p>6. Connect the output from <strong>Curve.PointAtParameter</strong> to the <strong>List.FilterByBoolMask</strong> to separate the list of odd and even indices.</p>
<p><img src="5_essential_nodes_and_concepts/5-3_the-building-blocks-of-programs/../images/5-3/3/logic-exercisepartII-06.jpg" alt="" /></p>
<blockquote>
<p>a. <strong>List.FilterByBoolMask</strong> - Plug <strong>Curve.PointAtParameter</strong> from the previous step into the <em>list</em> input.</p>
<p>b. <strong>Watch -</strong> a watch node for <em>in</em> and a watch node for <em>out</em> shows that we have two lists representing even indices and odd indices. These points are ordered in the same way on the curve, which we demonstrate in the next step.</p>
</blockquote>
<p>7. Next, we are going to use the output result from <strong>List.FilterByBoolMask</strong> in step 05 to generate geometries with sizes according to its indices.</p>
<p><strong>Cuboid.ByLengths -</strong> recreate the connections seen in the image above to get a zipper along the sine curve. A cuboid is just a box here, and we're defining its size based on the curve point in the center of the box. The logic of the even/odd divide should now be clear in the model.</p>
<p><img src="5_essential_nodes_and_concepts/5-3_the-building-blocks-of-programs/../images/5-3/3/logic-exercisepartII-07.jpg" alt="" /></p>
<blockquote>
<p>a. List of cuboids at even indices.</p>
<p>b. List of cuboids at odd indices.</p>
</blockquote>
<p>Voila! You have just programmed a process of defining the geometry dimensions according to the logic operation demonstrated in this exercise.</p>
<div style="break-before: page; page-break-before: always;"></div><h1 id="strings"><a class="header" href="#strings">Strings</a></h1>
<h3 id="what-is-a-string"><a class="header" href="#what-is-a-string">What is a String</a></h3>
<p>Formally, a <strong>String</strong> is a sequence of characters representing a literal constant or some type of variable. Informally, a string is programming lingo for text. We've worked with numbers, both integers and decimal numbers, to drive parameters and we can do the same with text.</p>
<h3 id="creating-strings"><a class="header" href="#creating-strings">Creating Strings</a></h3>
<p>Strings can be used for a wide range of applications, including defining custom parameters, annotating documentation sets, and parsing through text-based data sets. The string Node is located in the Core&gt;Input Category.</p>
<p>The sample Nodes above are strings. A number can be represented as a string, as can a letter, or an entire array of text.</p>
<p><img src="5_essential_nodes_and_concepts/5-3_the-building-blocks-of-programs/../images/5-3/4/strings-creatingstrings.jpg" alt="" /></p>
<h2 id="exercise"><a class="header" href="#exercise">Exercise</a></h2>
<blockquote>
<p>Download the example file by clicking on the link below.</p>
<p>A full list of example files can be found in the Appendix.</p>
</blockquote>
<p>{% file src=&quot;../datasets/5-3/4/Building Blocks of Programs - Strings.dyn&quot; %}</p>
<h3 id="querying-strings"><a class="header" href="#querying-strings">Querying Strings</a></h3>
<p>You can parse through large amounts of data quickly by querying strings. We'll talk about some basic operations which can speed up a workflow and help for software interoperability.</p>
<p>The image below considers a string of data coming from an external spreadsheet. The string represents the vertices of a rectangle in the XY-Plane. Let's break down some string split operations in miniature exercise:</p>
<p><img src="5_essential_nodes_and_concepts/5-3_the-building-blocks-of-programs/../images/5-3/4/strings-queryingstrings01.jpg" alt="" /></p>
<blockquote>
<ol>
<li>The &quot;;&quot; separator splits each vertex of the rectangle. This creates a list with 3 items for each vertex.</li>
</ol>
</blockquote>
<p><img src="5_essential_nodes_and_concepts/5-3_the-building-blocks-of-programs/../images/5-3/4/strings-queryingstrings02.jpg" alt="" /></p>
<blockquote>
<ol>
<li>By hitting the &quot;<em>+</em>&quot; in the middle of the Node, we create new separator.</li>
<li>Add a &quot;<em>,</em>&quot; string to the canvas and plug in to the new separator input.</li>
<li>Our result is now a list of ten items. The Node first splits based on <em>separator0</em>, then based on <em>separator1</em>.</li>
</ol>
</blockquote>
<p>While the list of items above may look like numbers, they are still regarded as individual strings in Dynamo. In order to create points, their data type needs to be converted from a string to a number. This is done with the <strong>String.ToNumber</strong> Node</p>
<p><img src="5_essential_nodes_and_concepts/5-3_the-building-blocks-of-programs/../images/5-3/4/strings-queryingstrings03.jpg" alt="" /></p>
<blockquote>
<ol>
<li>This Node is straightforward. Plug the <strong>String.Split</strong> results into the input. The output doesn't look different, but the data type is now a <em>number</em> instead of a <em>string</em>.</li>
</ol>
</blockquote>
<p>With some basic additional operations, we now have a triangle drawn at the origin based on the original string input.</p>
<p><img src="5_essential_nodes_and_concepts/5-3_the-building-blocks-of-programs/../images/5-3/4/strings-queryingstrings04.jpg" alt="" /></p>
<h3 id="manipulating-strings"><a class="header" href="#manipulating-strings">Manipulating Strings</a></h3>
<p>Since a string is a generic text object, they host a wide range of applications. Let's take a look at some of the major actions in the Core&gt;String Category in Dynamo:</p>
<p>This is a method of merging two strings together in order. This takes each literal string in a list and creates one merged string.</p>
<p>The following represents the concatenation of three strings:</p>
<p><img src="5_essential_nodes_and_concepts/5-3_the-building-blocks-of-programs/../images/5-3/4/strings-manipulatingstrings01.jpg" alt="Concatenate" /></p>
<blockquote>
<ol>
<li>Add or subtract strings to the concatenation by clicking the +/- buttons in the center of the Node.</li>
<li>The output gives one concatenated string, with spaces and punctuation included.</li>
</ol>
</blockquote>
<p>The join method is very similar to concatenate, except it has an added layer of punctuation.</p>
<p>If you've worked in Excel, you may have come across a CSV file. This stands for comma-separated values. One could use a comma (or in this case, two dashes) as the separator with the <strong>String.Join</strong> node in order to create a similar data structure.</p>
<p>The following image represents the joining of two strings:</p>
<p><img src="5_essential_nodes_and_concepts/5-3_the-building-blocks-of-programs/../images/5-3/4/strings-manipulatingstrings02.jpg" alt="" /></p>
<blockquote>
<ol>
<li>The separator input allows one to create a string which divides the joined strings.</li>
</ol>
</blockquote>
<h3 id="working-with-strings"><a class="header" href="#working-with-strings">Working with Strings</a></h3>
<p>In this exercise, we're going to use methods of querying and manipulating strings to deconstruct the final stanza of Robert Frost's <a href="http://www.poetryfoundation.org/poem/171621">Stopping By Woods on a Snowy Evening</a>. Not the most practical application, but it will help us to grasp conceptual string actions as we apply them to legible lines of rhythm and rhyme.</p>
<p>Let's begin with a basic string split of the stanza. We first notice that the writing is formatted based on commas. We'll use this format to separate each line into individual items.</p>
<p><img src="5_essential_nodes_and_concepts/5-3_the-building-blocks-of-programs/../images/5-3/4/strings-workingwithstrings01.jpg" alt="" /></p>
<blockquote>
<ol>
<li>The base string is pasted into a <strong>String</strong> Node.</li>
<li>Another <strong>String</strong> Node is used to denote the separator. In this case, we're using a comma.</li>
<li>A <strong>String.Split</strong> Node is added to the canvas and connected to the two strings.</li>
<li>The output shows that we've now separated the lines into individual elements.</li>
</ol>
</blockquote>
<p>Now, let's get to the good part of the poem: the last two lines. The original stanza was one item of data. We separated this data into individual items in the first step. Now we need to do a search for the text we're looking for. And while we <em>can</em> do this by selecting the last two items of the list, if this were an entire book, we wouldn't want to read through everything and manually isolate the elements.</p>
<p><img src="5_essential_nodes_and_concepts/5-3_the-building-blocks-of-programs/../images/5-3/4/strings-workingwithstrings02.jpg" alt="" /></p>
<blockquote>
<ol>
<li>Instead of manually searching, we use a <strong>String.Contains</strong> Node to perform a search for a set of characters. This is the similar to doing the &quot;Find&quot; command in a word processor. In this case, we get a return of &quot;true&quot; or &quot;false&quot; if that substring is found within the item.</li>
<li>In the <em>searchFor</em> input, we define a substring that we're looking for within the stanza. Let's use a <strong>String</strong> Node with the text &quot;And miles&quot;.</li>
<li>The output gives us a list of falses and trues. We'll use this boolean logic to filter the elements in the next step.</li>
</ol>
</blockquote>
<p><img src="5_essential_nodes_and_concepts/5-3_the-building-blocks-of-programs/../images/5-3/4/strings-workingwithstrings03.jpg" alt="Split" /></p>
<blockquote>
<ol>
<li><strong>List.FilterByBoolMask</strong> is the Node we want to use to cull out the falses and trues. The &quot;in&quot; output return the statements with a &quot;mask&quot; input of &quot;true, while the &quot;out&quot; output return those which are &quot;false&quot;.</li>
<li>Our output from the &quot;in&quot; is as expected, giving us the final two lines of the stanza.</li>
</ol>
</blockquote>
<p>Now, we want to drive home the repetition of the stanza by merging the two lines together. When viewing the output of the previous step, we notice that there are two items in the list:</p>
<p><img src="5_essential_nodes_and_concepts/5-3_the-building-blocks-of-programs/../images/5-3/4/strings-workingwithstrings04.jpg" alt="" /></p>
<blockquote>
<ol>
<li>Using two <strong>List.GetItemAtIndex</strong> Nodes, we can isolate the items using the values of 0 and 1 as the index input.</li>
<li>The output for each node gives us, in order, the final two lines.</li>
</ol>
</blockquote>
<p>To merge these two items into one, we use the <strong>String.Join</strong> Node:</p>
<p><img src="5_essential_nodes_and_concepts/5-3_the-building-blocks-of-programs/../images/5-3/4/strings-workingwithstrings05.jpg" alt="Split String" /></p>
<blockquote>
<ol>
<li>After adding the <strong>String.Join</strong> Node, we notice that we need a separator.</li>
<li>To create the separator, we add a <strong>String</strong> Node to the canvas and type in a comma.</li>
<li>The final output has merged the last two items into one.</li>
</ol>
</blockquote>
<p>This may seem like a lot of work to isolate the last two lines; and it's true, string operations often require some up front work. But they are scalable, and they can be applied to large datasets with relative ease. If you are working parametrically with spreadsheets and interoperability, be sure to keep string operations in mind.</p>
<div style="break-before: page; page-break-before: always;"></div><h1 id="color-1"><a class="header" href="#color-1">Color</a></h1>
<p>Color is a great data type for creating compelling visuals as well as for rendering difference in the output from your Visual Program. When working with abstract data and varying numbers, sometimes it's difficult to see what's changing and to what degree. This is a great application for colors.</p>
<h3 id="creating-colors"><a class="header" href="#creating-colors">Creating Colors</a></h3>
<p>Colors in Dynamo are created using ARGB inputs.This corresponds to the Alpha, Red, Green, and Blue channels. The alpha represents the <em>transparency</em> of the color, while the other three are used as primary colors to generate the whole spectrum of color in concert.</p>
<div class="table-wrapper"><table><thead><tr><th>Icon</th><th>Name (Syntax)</th><th>Inputs</th><th>Outputs</th></tr></thead><tbody>
<tr><td><img src="5_essential_nodes_and_concepts/5-3_the-building-blocks-of-programs/../images/5-3/5/ColorbyARGB.jpg" alt="" /></td><td>ARGB Color (<strong>Color.ByARGB</strong>)</td><td>A,R,G,B</td><td>color</td></tr>
</tbody></table>
</div>
<h3 id="querying-color-values"><a class="header" href="#querying-color-values">Querying Color Values</a></h3>
<p>The colors in the table below query the properties used to define the color: Alpha, Red, Green, and Blue. Note that the Color.Components Node gives us all four as different outputs, which makes this Node preferable for querying the properties of a color.</p>
<div class="table-wrapper"><table><thead><tr><th>Icon</th><th>Name (Syntax)</th><th>Inputs</th><th>Outputs</th></tr></thead><tbody>
<tr><td><img src="5_essential_nodes_and_concepts/5-3_the-building-blocks-of-programs/../images/5-3/5/ColorAlpha.jpg" alt="" /></td><td>Alpha (<strong>Color.Alpha</strong>)</td><td>color</td><td>A</td></tr>
<tr><td><img src="5_essential_nodes_and_concepts/5-3_the-building-blocks-of-programs/../images/5-3/5/ColorRed.jpg" alt="" /></td><td>Red (<strong>Color.Red</strong>)</td><td>color</td><td>R</td></tr>
<tr><td><img src="5_essential_nodes_and_concepts/5-3_the-building-blocks-of-programs/../images/5-3/5/ColorGreen.jpg" alt="" /></td><td>Green (<strong>Color.Green</strong>)</td><td>color</td><td>G</td></tr>
<tr><td><img src="5_essential_nodes_and_concepts/5-3_the-building-blocks-of-programs/../images/5-3/5/ColorBlue.jpg" alt="" /></td><td>Blue (<strong>Color.Blue</strong>)</td><td>color</td><td>B</td></tr>
<tr><td><img src="5_essential_nodes_and_concepts/5-3_the-building-blocks-of-programs/../images/5-3/5/ColorComponent.jpg" alt="" /></td><td>Components (<strong>Color.Components</strong>)</td><td>color</td><td>A, R, G, B</td></tr>
</tbody></table>
</div>
<p>The colors in the table below correspond to the <strong>HSB color space</strong>. Dividing the color into hue, saturation, and brightness is arguably more intuitive for how we interpret color: What color should it be? How colorful should it be? And how light or dark should the color be? This is the breakdown of hue, saturation, and brightness respectively.</p>
<div class="table-wrapper"><table><thead><tr><th>Icon</th><th>Name (Syntax)</th><th>Inputs</th><th>Outputs</th></tr></thead><tbody>
<tr><td><img src="5_essential_nodes_and_concepts/5-3_the-building-blocks-of-programs/../images/5-3/5/ColorHue.jpg" alt="" /></td><td>Hue (<strong>Color.Hue</strong>)</td><td>color</td><td>Hue</td></tr>
<tr><td><img src="5_essential_nodes_and_concepts/5-3_the-building-blocks-of-programs/../images/5-3/5/ColorSaturation.jpg" alt="" /></td><td>Saturation (<strong>Color.Saturation</strong>)</td><td>color</td><td>Saturation</td></tr>
<tr><td><img src="5_essential_nodes_and_concepts/5-3_the-building-blocks-of-programs/../images/5-3/5/ColorBrightness.jpg" alt="" /></td><td>Brightness (<strong>Color.Brightness</strong>)</td><td>color</td><td>Brightness</td></tr>
</tbody></table>
</div>
<h3 id="color-range"><a class="header" href="#color-range">Color Range</a></h3>
<p>The color range is similar to the <strong>Remap Range</strong> Node from the <a href="5_essential_nodes_and_concepts/5-3_the-building-blocks-of-programs/3-logic.html#part-ii-from-logic-to-geometry" title="mention">#part-ii-from-logic-to-geometry</a>exercise: it remaps a list of numbers into another domain. But instead of mapping to a <em>number</em> domain, it maps to a <em>color gradient</em> based on input numbers ranging from 0 to 1.</p>
<p>The current Node works well, but it can be a little awkward to get everything working the first time around. The best way to become familiar with the color gradient is to test it out interactively. Let's do a quick exercise to review how to setup a gradient with output colors corresponding to numbers.</p>
<p><img src="5_essential_nodes_and_concepts/5-3_the-building-blocks-of-programs/../images/5-3/5/color-colorrange.jpg" alt="" /></p>
<blockquote>
<ol>
<li>Define three colors: Using a <strong>Code Block</strong> node, define <em>red, green</em>, and <em>blue</em> by plugging in the appropriate combinations of <em>0</em> and <em>255</em>.</li>
<li><strong>Create list:</strong> Merge the three colors into one list.</li>
<li>Define Indices: Create a list to define the grip positions of each color (ranging from 0 to 1). Notice the value of 0.75 for green. This places the green color 3/4 of the way across the horizontal gradient in the color range slider.</li>
<li><strong>Code Block</strong>: Input values (between 0 and 1) to translate to colors.</li>
</ol>
</blockquote>
<h3 id="color-preview"><a class="header" href="#color-preview">Color Preview</a></h3>
<p>The <strong>Display.ByGeometry</strong> Node gives us the ability to color geometry in the Dynamo viewport. This is helpful for separating different types of geometry, demonstrating a parametric concept, or defining an analysis legend for simulation. The inputs are simple: geometry and color. To create a gradient like the image above, the color input is connected to the <strong>Color</strong> <strong>Range</strong> Node.</p>
<p><img src="5_essential_nodes_and_concepts/5-3_the-building-blocks-of-programs/../images/5-3/5/color-colorpreview.jpg" alt="" /></p>
<h3 id="color-on-surfaces"><a class="header" href="#color-on-surfaces">Color On Surfaces</a></h3>
<p>The <strong>Display.BySurfaceColors</strong> node gives us the ability to map data across a surface using color! This functionality introduces some exciting possibilities for visualizing data obtained through discrete analysis like solar, energy, and proximity. Applying color to a surface in Dynamo is similar to applying a texture to a material in other CAD environments. Let's demonstrate how to use this tool in the brief exercise below.</p>
<p><img src="5_essential_nodes_and_concepts/5-3_the-building-blocks-of-programs/../images/5-3/5/12(1).jpg" alt="" /></p>
<h2 id="exercise-1"><a class="header" href="#exercise-1">Exercise</a></h2>
<h3 id="basic-helix-with-colors"><a class="header" href="#basic-helix-with-colors">Basic Helix with Colors</a></h3>
<blockquote>
<p>Download the example file by clicking on the link below.</p>
<p>A full list of example files can be found in the Appendix.</p>
</blockquote>
<p>{% file src=&quot;../datasets/5-3/5/Building Blocks of Programs - Color.dyn&quot; %}</p>
<p>This exercise focuses on controlling color parametrically in parallel with geometry. The geometry is a basic helix, which we define below using the <strong>Code Block</strong>. This is a quick and easy way to create a parametric function; and since our focus is on color (rather than geometry), we use the code block to efficiently create the helix without cluttering the canvas. We will use the code block more frequently as the primer moves to more advanced material.</p>
<p><img src="5_essential_nodes_and_concepts/5-3_the-building-blocks-of-programs/../images/5-3/5/color-basichelixwithcolors01.jpg" alt="" /></p>
<blockquote>
<ol>
<li><strong>Code Block:</strong> Define the two code blocks with the formulas above. This is a quick parametric method for creating a spiral.</li>
<li><strong>Point.ByCoordinates</strong>: Plug the three outputs from the code block into the coordinates for the Node.</li>
</ol>
</blockquote>
<p>We now see an array of points creating a helix. The next step is to create a curve through the points so that we can visualize the helix.</p>
<p><img src="5_essential_nodes_and_concepts/5-3_the-building-blocks-of-programs/../images/5-3/5/color-basichelixwithcolors02.jpg" alt="" /></p>
<blockquote>
<ol>
<li><strong>PolyCurve.ByPoints:</strong> Connect the <strong>Point.ByCoordinates</strong> output into the <em>points</em> input for the Node. We get a helical curve.</li>
<li><strong>Curve.PointAtParameter:</strong> Connect the <strong>PolyCurve.ByPoints</strong> output into the <em>curve</em> input. The purpose of this step is to create a parametric attractor point which slides along the curve. Since the curve is evaluating a point at parameter, we'll need to input a <em>param</em> value between 0 and 1.</li>
<li><strong>Number Slider:</strong> After adding to the canvas, change the <em>min</em> value to <em>0.0</em>, the <em>max</em> value to <em>1.0</em>, and the <em>step</em> value to <em>.01</em>. Plug the slider output into the <em>param</em> input for <strong>Curve.PointAtParameter</strong>. We now see a point along the length of the helix, represented by a percentage of the slider (0 at the start point, 1 at the end point).</li>
</ol>
</blockquote>
<p>With the reference point created, we now compare the distance from the reference point to the original points defining the helix. This distance value will drive geometry as well as color.</p>
<p><img src="5_essential_nodes_and_concepts/5-3_the-building-blocks-of-programs/../images/5-3/5/color-basichelixwithcolors03.jpg" alt="" /></p>
<blockquote>
<ol>
<li><strong>Geometry.DistanceTo:</strong> Connect <strong>Curve.PointAtParameter</strong> output into the <em>input</em>. Connect <strong>Point.ByCoordinates</strong> into the geometry input.</li>
<li><strong>Watch:</strong> The resultant output shows a list of distances from each helical point to the reference point along the curve.</li>
</ol>
</blockquote>
<p>Our next step is to drive parameters with the list of distances from the helical points to the reference point. We use these distance values to define the radii of a series of spheres along the curve. In order to keep the spheres a suitable size, we need to <em>remap</em> the values for distance.</p>
<p><img src="5_essential_nodes_and_concepts/5-3_the-building-blocks-of-programs/../images/5-3/5/color-basichelixwithcolors04.jpg" alt="" /></p>
<blockquote>
<ol>
<li><strong>Math.RemapRange:</strong> Connect <strong>Geometry.DistanceTo</strong> output into the numbers input.</li>
<li><strong>Code Block:</strong> connect a code block with a value of <em>0.01</em> into the <em>newMin</em> input and a code block with a value of <em>1</em> into the <em>newMax</em> input.</li>
<li><strong>Watch:</strong> connect the <strong>Math.RemapRange</strong> output into one node and the <strong>Geometry.DistanceTo</strong> output into another. Compare the results.</li>
</ol>
</blockquote>
<p>This step has remapped the list of distance to be a smaller range. We can edit the <em>newMin</em> and <em>newMax</em> values however we see fit. The values will remap and will have the same <em>distribution ratio</em> across the domain.</p>
<p><img src="5_essential_nodes_and_concepts/5-3_the-building-blocks-of-programs/../images/5-3/5/color-basichelixwithcolors05.jpg" alt="" /></p>
<blockquote>
<ol>
<li><strong>Sphere.ByCenterPointRadius:</strong> connect the <strong>Math.RemapRange</strong> output into the <em>radius</em> input and the original <strong>Point.ByCoordinates</strong> output into the <em>centerPoint</em> input.</li>
</ol>
</blockquote>
<p>Change the value of the number slider and watch the size of the spheres update. We now have a parametric jig</p>
<p><img src="5_essential_nodes_and_concepts/5-3_the-building-blocks-of-programs/../images/5-3/5/color-basichelixwithcolors06.gif" alt="" /></p>
<p>The size of the spheres demonstrates the parametric array defined by a reference point along the curve. Let's use the same concept for the sphere radius to drive their color.</p>
<p><img src="5_essential_nodes_and_concepts/5-3_the-building-blocks-of-programs/../images/5-3/5/color-basichelixwithcolors07.jpg" alt="" /></p>
<blockquote>
<ol>
<li><strong>Color Range:</strong> Add top the canvas. When hovering over the <em>value</em> input, we notice that the numbers requested are between 0 and 1. We need to remap the numbers from the <strong>Geometry.DistanceTo</strong> output so that they are compatible with this domain.</li>
<li><strong>Sphere.ByCenterPointRadius:</strong> For the time being, let's disable the preview on this node (<em>Right Click &gt; Preview</em>)</li>
</ol>
</blockquote>
<p><img src="5_essential_nodes_and_concepts/5-3_the-building-blocks-of-programs/../images/5-3/5/color-basichelixwithcolors08.jpg" alt="" /></p>
<blockquote>
<ol>
<li><strong>Math.RemapRange:</strong> This process should look familiar. Connect the <strong>Geometry.DistanceTo</strong> output into the numbers input.</li>
<li><strong>Code Block:</strong> Similar to an earlier step, create a value of <em>0</em> for the <em>newMin</em> input and a value of <em>1</em> for the <em>newMax</em> input. Notice that we are able to define two outputs from one code block in this case.</li>
<li><strong>Color Range:</strong> Connect the <strong>Math.RemapRange</strong> output into the <em>value</em> input.</li>
</ol>
</blockquote>
<p><img src="5_essential_nodes_and_concepts/5-3_the-building-blocks-of-programs/../images/5-3/5/color-basichelixwithcolors09.jpg" alt="" /></p>
<blockquote>
<ol>
<li><strong>Color.ByARGB:</strong> This is what we'll do to create two colors. While this process may look awkward, it's the same as RGB colors in another software, we're just using visual programming to do it.</li>
<li><strong>Code Block:</strong> create two values of <em>0</em> and <em>255</em>. Plug the two outputs into the two <strong>Color.ByARGB</strong> inputs in agreement with the image above (or create your favorite two colors).</li>
<li><strong>Color Range:</strong> The <em>colors</em> input requests a list of colors. We need to create this list from the two colors created in the previous step.</li>
<li><strong>List.Create:</strong> merge the two colors into one list. Plug the output into the <em>colors</em> input for <strong>Color Range</strong>.</li>
</ol>
</blockquote>
<p><img src="5_essential_nodes_and_concepts/5-3_the-building-blocks-of-programs/../images/5-3/5/color-basichelixwithcolors10.jpg" alt="" /></p>
<blockquote>
<ol>
<li><strong>Display.ByGeometryColor:</strong> Connect <strong>Sphere.ByCenterPointRadius</strong> into the <em>geometry</em> input and the <em>Color Range</em> into the <em>color</em> input. We now have a smooth gradient across the domain of the curve.</li>
</ol>
</blockquote>
<p>If we change the value of the <strong>Number Slider</strong> from earlier in the definition, the colors and sizes update. Colors and radius size are directly related in this case: we now have a visual link between two parameters!</p>
<p><img src="5_essential_nodes_and_concepts/5-3_the-building-blocks-of-programs/../images/5-3/5/color-basichelixwithcolors11.gif" alt="" /></p>
<h3 id="color-on-surfaces-exercise"><a class="header" href="#color-on-surfaces-exercise">Color on Surfaces Exercise</a></h3>
<blockquote>
<p>Download the example file by clicking on the link below.</p>
<p>A full list of example files can be found in the Appendix.</p>
</blockquote>
<p>{% file src=&quot;../datasets/5-3/5/BuildingBlocks of Programs - ColorOnSurface.zip&quot; %}</p>
<p>First, we need to create (or reference) a surface to use as an input for the <strong>Display.BySurfaceColors</strong> node. For this example we are lofting between a sine and cosine curve.</p>
<p><img src="5_essential_nodes_and_concepts/5-3_the-building-blocks-of-programs/../images/5-3/5/color-coloronsurface01.jpg" alt="" /></p>
<blockquote>
<ol>
<li>This group of nodes is creating points along the Z-axis then displacing them based on sine and cosine functions. The two point lists are then used to generate NURBS curves.</li>
<li><strong>Surface.ByLoft</strong>: generate an interpolated surface between the list of NURBS curves.</li>
</ol>
</blockquote>
<p><img src="5_essential_nodes_and_concepts/5-3_the-building-blocks-of-programs/../images/5-3/5/color-coloronsurface02.jpg" alt="" /></p>
<blockquote>
<ol>
<li><strong>File Path</strong>: select an image file to sample for pixel data downstream</li>
<li>use <strong>File.FromPath</strong> to convert the file path to a file then pass into <strong>Image.ReadFromFile</strong> to output an image for sampling</li>
<li><strong>Image.Pixels</strong>: input an image and provide a sample value to use along the x and y dimensions of the image.</li>
<li><strong>Slider</strong>: provide sample values for <strong>Image.Pixels</strong></li>
<li><strong>Display.BySurfaceColors</strong>: map array of color values across surface along X and Y respectively</li>
</ol>
</blockquote>
<p>Close-up preview of the output surface with resolution of 400x300 samples</p>
<p><img src="5_essential_nodes_and_concepts/5-3_the-building-blocks-of-programs/../images/5-3/5/color-coloronsurface03.jpg" alt="" /></p>
<div style="break-before: page; page-break-before: always;"></div><h1 id="designing-with-lists"><a class="header" href="#designing-with-lists">Designing with Lists</a></h1>
<p>Lists are the way we organize data. On your computer's operating system, you have files and folders. In Dynamo, we can regard these as items and lists, respectively. Like your operating system, there are many ways to create, modify, and query data. In this chapter, we'll break down how lists are managed in Dynamo.</p>
<p><img src="5_essential_nodes_and_concepts/5-4_designing-with-lists/../images/5-4/designingwithlists.jpg" alt="" /></p>
<div style="break-before: page; page-break-before: always;"></div><h1 id="whats-a-list"><a class="header" href="#whats-a-list">What's a List</a></h1>
<h3 id="whats-a-list-1"><a class="header" href="#whats-a-list-1">What's a List?</a></h3>
<p>A list is a collection of elements, or items. Take a bunch of bananas, for example. Each banana is an item within the list (or bunch). It's easier to pick up a bunch of bananas rather than each banana individually, and the same holds for grouping elements by parametric relationships in a data structure.</p>
<p><img src="5_essential_nodes_and_concepts/5-4_designing-with-lists/../images/5-4/1/Bananas_white_background_DS.jpg" alt="Bananas" /></p>
<blockquote>
<p>Photo by <a href="https://commons.wikimedia.org/wiki/File:Bananas_white_background_DS.jpg?fastcci_from=11404890&amp;c1=11404890&amp;d1=15&amp;s=200&amp;a=list">Augustus Binu</a>.</p>
</blockquote>
<p>When we buy groceries, we put all of the purchased items into a bag. This bag is also a list. If we're making banana bread, we need 3 bunches of bananas (we're making a <em>lot</em> of banana bread). The bag represents a list of banana bunches and each bunch represents a list of bananas. The bag is a list of lists (two-dimensional) and the banana bunch is a list (one-dimensional).</p>
<p>In Dynamo, list data is ordered, and the first item in each list has an index &quot;0&quot;. Below, we'll discuss how lists are defined in Dynamo and how multiple lists relate to one another.</p>
<h3 id="zero-based-indices"><a class="header" href="#zero-based-indices">Zero-Based Indices</a></h3>
<p>One thing that might seem odd at first is that the first index of a list is always 0; not 1. So, when we talk about the first item of a list, we actually mean the item that corresponds to index 0.</p>
<p>For example, if you were to count the number of fingers we have on our right hand, chances are that you would have counted from 1 to 5. However, if you were to put your fingers in a list, Dynamo would have given them indices from 0 to 4. While this may seem a little strange to programming beginners, the zero-based index is standard practice in most computation systems.</p>
<p>Note that we still have 5 items in the list; its just that the list is using a zero-based counting system. And the items being stored in the list dont just have to be numbers. They can be any data type that Dynamo supports, such as points, curves, surfaces, families, etc.</p>
<p><img src="5_essential_nodes_and_concepts/5-4_designing-with-lists/../images/5-4/1/what&#x27;salist-zerobasedindices.jpg" alt="" /></p>
<blockquote>
<p>a. Index</p>
<p>b. Point</p>
<p>c. Item</p>
</blockquote>
<p>Often times the easiest way to take a look at the type of data stored in a list is to connect a watch node to another node's output. By default, the watch node automatically shows all indices to the left side of the list and displays the data items on the right.</p>
<p>These indices are a crucial element when working with lists.</p>
<h3 id="inputs-and-outputs"><a class="header" href="#inputs-and-outputs">Inputs and Outputs</a></h3>
<p>Pertaining to lists, inputs and outputs vary depending on the Dynamo node being used. As an example, let's use a list of 5 points and connect this output to two different Dynamo nodes: <strong>PolyCurve.ByPoints</strong> and <strong>Circle.ByCenterPointRadius</strong>:</p>
<p><img src="5_essential_nodes_and_concepts/5-4_designing-with-lists/../images/5-4/1/what&#x27;salist-inputsandoutputs.jpg" alt="Input Examples" /></p>
<blockquote>
<ol>
<li>The <em>points</em> input for <strong>PolyCurve.ByPoints</strong> is looking for <em>&quot;Point[]&quot;</em>. This represents a list of points</li>
<li>The output for <strong>PolyCurve.ByPoints</strong> is a single polycurve created from a list of five point.</li>
<li>The <em>centerPoint</em> input for <strong>Circle.ByCenterPointRadius</strong> asks for <em>&quot;Point&quot;</em>.</li>
<li>The output for <strong>Circle.ByCenterPointRadius</strong> is a list of five circles, whose centers correspond to the original list of points.</li>
</ol>
</blockquote>
<p>The input data for <strong>PolyCurve.ByPoints</strong> and <strong>Circle.ByCenterPointRadius</strong> are the same, however the <strong>Polycurve.ByPoints</strong> node gives us one polycurve while the <strong>Circle.ByCenterPointRadius</strong> node gives us 5 circles with centers at each point. Intuitively this makes sense: the polycurve is drawn as a curve connecting the 5 points, while the circles create a different circle at each point. So what's happening with the data?</p>
<p>Hovering over the <em>points</em> input for <strong>Polycurve.ByPoints</strong>, we see that the input is looking for <em>&quot;Point[]&quot;</em>. Notice the brackets at the end. This represents a list of points, and to create a polycurve, the input needs to be a list for each polycurve. This node will therefore condense each list into one polycurve.</p>
<p>On the other hand, the <em>centerPoint</em> input for <strong>Circle.ByCenterPointRadius</strong> asks for <em>&quot;Point&quot;</em>. This node looks for one point, as an item, to define the center point of the circle. This is why we get five circles from the input data. Recognizing these difference with inputs in Dynamo helps to better understand how the nodes are operating when managing data.</p>
<h3 id="lacing"><a class="header" href="#lacing">Lacing</a></h3>
<p>Data matching is a problem without a clean solution. It occurs when a node has access to differently sized inputs. Changing the data matching algorithm can lead to vastly different results.</p>
<p>Imagine a node which creates line segments between points (<strong>Line.ByStartPointEndPoint</strong>). It will have two input parameters which both supply point coordinates:</p>
<h4 id="shortest-list"><a class="header" href="#shortest-list">Shortest List</a></h4>
<p>The simplest way is to connect the inputs one-on-one until one of the streams runs dry. This is called the Shortest List algorithm. This is the default behavior for Dynamo nodes:</p>
<p><img src="5_essential_nodes_and_concepts/5-4_designing-with-lists/../images/5-4/1/what&#x27;salist-lacing-shortest.jpg" alt="" /></p>
<h4 id="longest-list"><a class="header" href="#longest-list">Longest List</a></h4>
<p>The Longest List algorithm keeps connecting inputs, reusing elements, until all streams run dry:</p>
<p><img src="5_essential_nodes_and_concepts/5-4_designing-with-lists/../images/5-4/1/what&#x27;salist-lacing-longest.jpg" alt="" /></p>
<h4 id="cross-product"><a class="header" href="#cross-product">Cross Product</a></h4>
<p>Finally, the Cross Product method makes all possible connections:</p>
<p><img src="5_essential_nodes_and_concepts/5-4_designing-with-lists/../images/5-4/1/what&#x27;salist-lacing-cross.jpg" alt="" /></p>
<p>As you can see there are different ways in which we can draw lines between these sets of points. Lacing options are found by right-clicking the center of a node and choosing the &quot;Lacing&quot; menu.</p>
<p><img src="5_essential_nodes_and_concepts/5-4_designing-with-lists/../images/5-4/1/what&#x27;salist-rightclicklacingopt.jpg" alt="" /></p>
<h2 id="exercise-2"><a class="header" href="#exercise-2">Exercise</a></h2>
<blockquote>
<p>Download the example file by clicking on the link below.</p>
<p>A full list of example files can be found in the Appendix.</p>
</blockquote>
<p>{% file src=&quot;../datasets/5-4/1/Lacing.dyn&quot; %}</p>
<p>To demonstrate the lacing operations below, we'll use this base file to define shortest list, longest list, and cross product.</p>
<p>We'll change the lacing on <strong>Point.ByCoordinates</strong>, but won't change anything else about the graph above.</p>
<h3 id="shortest-list-1"><a class="header" href="#shortest-list-1">Shortest List</a></h3>
<p>Choosing <em>shortest list</em> as the lacing option (also the default option), we get a basic diagonal line composed of five points. Five points is the length of the lesser list, so the shortest list lacing stops after it reaches the end of one list.</p>
<p><img src="5_essential_nodes_and_concepts/5-4_designing-with-lists/../images/5-4/1/what&#x27;salist-lacingexercise01.jpg" alt="Input Examples" /></p>
<h3 id="longest-list-1"><a class="header" href="#longest-list-1"><strong>Longest List</strong></a></h3>
<p>By changing the lacing to <em>longest list</em>, we get a diagonal line which extends vertically. By the same method as the concept diagram, the last item in the list of 5 items will be repeated to reach the length of the longer list.</p>
<p><img src="5_essential_nodes_and_concepts/5-4_designing-with-lists/../images/5-4/1/what&#x27;salist-lacingexercise02.jpg" alt="Input Examples" /></p>
<h3 id="cross-product-1"><a class="header" href="#cross-product-1"><strong>Cross Product</strong></a></h3>
<p>By changing the lacing to <em>Cross Product</em>, we get every combination between each list, giving us a 5x10 grid of points. This is an equivalent data structure to the cross product as shown in the concept diagram above, except our data is now a list of lists. By connecting a polycurve, we can see that each list is defined by its X-Value, giving us a row of vertical lines.</p>
<p><img src="5_essential_nodes_and_concepts/5-4_designing-with-lists/../images/5-4/1/what&#x27;salist-lacingexercise03.jpg" alt="Input Examples" /></p>
<div style="break-before: page; page-break-before: always;"></div><h1 id="working-with-lists"><a class="header" href="#working-with-lists">Working with Lists</a></h1>
<h3 id="working-with-lists-1"><a class="header" href="#working-with-lists-1">Working with Lists</a></h3>
<p>Now that we've established what a list is, let's talk about operations we can perform on it. Imagine a list as a deck of playing cards. A deck is the list and each playing card represents an item.</p>
<p><img src="5_essential_nodes_and_concepts/5-4_designing-with-lists/../images/5-4/2/Playing_cards_modified.jpg" alt="cards" /></p>
<blockquote>
<p>Photo by <a href="https://commons.wikimedia.org/wiki/File:Playing_cards_modified.jpg">Christian Gidlf</a></p>
</blockquote>
<h3 id="query"><a class="header" href="#query">Query</a></h3>
<p>What <strong>queries</strong> can we make from the list? This accesses existing properties.</p>
<ul>
<li>Number of cards in the deck? 52.</li>
<li>Number of suits? 4.</li>
<li>Material? Paper.</li>
<li>Length? 3.5&quot; or 89mm.</li>
<li>Width? 2.5&quot; or 64mm.</li>
</ul>
<h3 id="action"><a class="header" href="#action">Action</a></h3>
<p>What <strong>actions</strong> can we perform on the list? This changes the list based on a given operation.</p>
<ul>
<li>We can shuffle the deck.</li>
<li>We can sort the deck by value.</li>
<li>We can sort the deck by suit.</li>
<li>We can split the deck.</li>
<li>We can partition the deck by dealing out individual hands.</li>
<li>We can select a specific card in the deck.</li>
</ul>
<p>All of the operations listed above have analogous Dynamo nodes for working with lists of generic data. The lessons below will demonstrate some of the fundamental operations we can perform on lists.</p>
<h2 id="exercise-3"><a class="header" href="#exercise-3"><strong>Exercise</strong></a></h2>
<h3 id="list-operations"><a class="header" href="#list-operations"><strong>List Operations</strong></a></h3>
<blockquote>
<p>Download the example file by clicking on the link below.</p>
<p>A full list of example files can be found in the Appendix.</p>
</blockquote>
<p>{% file src=&quot;../datasets/5-4/2/List-Operations.dyn&quot; %}</p>
<p>The image below is the base graph which we are drawing lines between two circles to represent basic list operations. We'll explore how to manage data within a list and demonstrate the visual results through the list actions below.</p>
<p><img src="5_essential_nodes_and_concepts/5-4_designing-with-lists/../images/5-4/2/workingwithlist-listoperation.jpg" alt="" /></p>
<blockquote>
<ol>
<li>Begin with a <strong>Code Block</strong> with a value of <code>500;</code></li>
<li>Plug into the x input of a <strong>Point.ByCoordinates</strong> node.</li>
<li>Plug the node from the previous step into the origin input of a <strong>Plane.ByOriginNormal</strong> node.</li>
<li>Using a <strong>Circle.ByPlaneRadius</strong> node, plug the node from the previous step into the plane input.</li>
<li>Using <strong>Code Block</strong>, designate a value of <code>50;</code> for the radius. This is the first circle we'll create.</li>
<li>With a <strong>Geometry.Translate</strong> node, move the circle up 100 units in the Z direction.</li>
<li>With a <strong>Code Block</strong> node, define a range of ten numbers between 0 and 1 with this line of code: <code>0..1..#10;</code></li>
<li>Plug the code block from the previous step into the <em>param</em> input of two <strong>Curve.PointAtParameter</strong> nodes. Plug <strong>Circle.ByPlaneRadius</strong> into the curve input of the top node, and <strong>Geometry.Translate</strong> into the curve input of the node beneath it.</li>
<li>Using a <strong>Line.ByStartPointEndPoint</strong>, connect the two <strong>Curve.PointAtParamete</strong><em>r</em> nodes.</li>
</ol>
</blockquote>
<h3 id="listcount"><a class="header" href="#listcount">List.Count</a></h3>
<blockquote>
<p>Download the example file by clicking on the link below.</p>
<p>A full list of example files can be found in the Appendix.</p>
</blockquote>
<p>{% file src=&quot;../datasets/5-4/2/List-Count.dyn&quot; %}</p>
<p>The <em>List.Count</em> node is straightforward: it counts the number of values in a list and returns that number. This node gets more nuanced as we work with lists of lists, but we'll demonstrate that in the coming sections.</p>
<p><img src="5_essential_nodes_and_concepts/5-4_designing-with-lists/../images/5-4/2/workingwithlist-listoperation-listcount.jpg" alt="Count" /></p>
<blockquote>
<ol>
<li>The **List.Count **<em>****</em> node returns the number of lines in the <strong>Line.ByStartPointEndPoint</strong> node. The value is 10 in this case, which agrees with the number of points created from the original <strong>Code Block</strong> node.</li>
</ol>
</blockquote>
<h3 id="listgetitematindex"><a class="header" href="#listgetitematindex">List.GetItemAtIndex</a></h3>
<blockquote>
<p>Download the example file by clicking on the link below.</p>
<p>A full list of example files can be found in the Appendix.</p>
</blockquote>
<p>{% file src=&quot;../datasets/5-4/2/List-GetItemAtIndex.dyn&quot; %}</p>
<p><strong>List.GetItemAtIndex</strong> is a fundamental way to query an item in the list.</p>
<p><img src="5_essential_nodes_and_concepts/5-4_designing-with-lists/../images/5-4/2/workingwithlist-getitemindex01.jpg" alt="Exercise" /></p>
<blockquote>
<ol>
<li>First, Right click on <strong>Line.ByStartPointEndPoint</strong> node to switch off its preview.</li>
<li>Using the <strong>List.GetItemAtIndex</strong> node, we are selecting index <em>&quot;0&quot;</em>, or the first item in the list of lines.</li>
</ol>
</blockquote>
<p>Change slider value between 0 and 9 to select different item using <strong>List.GetItemAtIndex</strong>.</p>
<p><img src="5_essential_nodes_and_concepts/5-4_designing-with-lists/../images/5-4/2/workingwithlist-getitemindex02.gif" alt="" /></p>
<h3 id="listreverse"><a class="header" href="#listreverse">List.Reverse</a></h3>
<blockquote>
<p>Download the example file by clicking on the link below.</p>
<p>A full list of example files can be found in the Appendix.</p>
</blockquote>
<p>{% file src=&quot;../datasets/5-4/2/List-Reverse.dyn&quot; %}</p>
<p><em>List.Reverse</em> reverses the order of all of the items in a list.</p>
<p><img src="5_essential_nodes_and_concepts/5-4_designing-with-lists/../images/5-4/2/workingwithlist-listreverse.jpg" alt="Exercise" /></p>
<blockquote>
<ol>
<li>To properly visualize the reversed list of lines, create more lines by changing the <strong>Code Block</strong> to <code>0..1..#50;</code></li>
<li>Duplicate the <strong>Line.ByStartPointEndPoint</strong> node, insert a List.Reverse node in between <strong>Curve.PointAtParameter</strong> and the second <strong>Line.ByStartPointEndPoint</strong></li>
<li>Use <strong>Watch3D</strong> nodes to preview two different results. The first one shows the result without a reversed list. The lines connect vertically to neighboring points. The reversed list, however, will connect all of the points to the opposing order in the other list.</li>
</ol>
</blockquote>
<h3 id="listshiftindices"><a class="header" href="#listshiftindices">List.ShiftIndices <a href="5_essential_nodes_and_concepts/5-4_designing-with-lists/2-working-with-lists.html#listshiftindices" id="listshiftindices"></a></a></h3>
<blockquote>
<p>Download the example file by clicking on the link below.</p>
<p>A full list of example files can be found in the Appendix.</p>
</blockquote>
<p>{% file src=&quot;../datasets/5-4/2/List-ShiftIndices.dyn&quot; %}</p>
<p><strong>List.ShiftIndices</strong> is a good tool for creating twists or helical patterns, or any other similar data manipulation. This node shifts the items in a list a given number of indices.</p>
<p><img src="5_essential_nodes_and_concepts/5-4_designing-with-lists/../images/5-4/2/workingwithlist-shiftIndices01.jpg" alt="Exercise" /></p>
<blockquote>
<ol>
<li>In the same process as the reverse list, insert a <strong>List.ShiftIndices</strong> into the <strong>Curve.PointAtParameter</strong> and <strong>Line.ByStartPointEndPoint</strong>.</li>
<li>Using a <strong>Code Block</strong>, designated a value of &quot;1&quot; to shift the list one index.</li>
<li>Notice that the change is subtle, but all of the lines in the lower <strong>Watch3D</strong> node have shifted one index when connecting to the other set of points.</li>
</ol>
</blockquote>
<p>By changing to <strong>Code Block</strong> to a larger value, <em>&quot;30&quot;</em> for example, we notice a significant difference in the diagonal lines. The shift is working like a camera's iris in this case, creating a twist in the original cylindrical form.</p>
<p><img src="5_essential_nodes_and_concepts/5-4_designing-with-lists/../images/5-4/2/workingwithlist-shiftIndices02.jpg" alt="" /></p>
<h3 id="listfilterbybooleanmask"><a class="header" href="#listfilterbybooleanmask">List.FilterByBooleanMask <a href="5_essential_nodes_and_concepts/5-4_designing-with-lists/2-working-with-lists.html#listfilterbybooleanmask" id="listfilterbybooleanmask"></a></a></h3>
<blockquote>
<p>Download the example file by clicking on the link below.</p>
<p>A full list of example files can be found in the Appendix.</p>
</blockquote>
<p>{% file src=&quot;../datasets/5-4/2/List-FilterByBooleanMask.dyn&quot; %}</p>
<p><img src="5_essential_nodes_and_concepts/5-4_designing-with-lists/../images/5-4/2/ListFilterBool.png" alt="" /></p>
<p><strong>List.FilterByBooleanMask</strong> will remove certain items based on a list of booleans, or values reading &quot;true&quot; or &quot;false&quot;.</p>
<p><img src="5_essential_nodes_and_concepts/5-4_designing-with-lists/../images/5-4/2/workingwithlist-filterbyboolmask.jpg" alt="Exercise" /></p>
<p>In order to create a list of values reading &quot;true&quot; or &quot;false&quot;, we need to a little more work...</p>
<blockquote>
<ol>
<li>Using a <strong>Code Block</strong>, define an expression with the syntax: <code>0..List.Count(list);</code>. Connect the <strong>Curve.PointAtParameter</strong> node to the <em>list</em> input. We'll walk through this setup more in the code block chapter, but the line of code in this case is giving us a list representing each index of the <strong>Curve.PointAtParameter</strong> node.</li>
<li>Using a <em><strong>%</strong></em>** (modulus)** node, connect the output of the <em>code block</em> into the <em>x</em> input, and a value of <em>4</em> into the <em>y</em> input. This will give us the remainder when dividing the list of indices by 4. Modulus is a really helpful node for pattern creation. All values will read as the possible remainders of 4: 0, 1, 2, 3.</li>
<li>From the  <em><strong>%</strong></em>** (modulus)** node, we know that a value of 0 means that the index is divisible by 4 (0,4,8,etc...). By using a <strong>==</strong> node, we can test for the divisibility by testing it against a value of <em>&quot;0&quot;</em>.</li>
<li>The <strong>Watch</strong> node reveals just this: we have a true/false pattern which reads: <em>true,false,false,false...</em>.</li>
<li>Using this true/false pattern, connect to the mask input of two <strong>List.FilterByBooleanMask</strong> nodes.</li>
<li>Connect the <strong>Curve.PointAtParameter</strong> node into each list input for the <strong>List.FilterByBooleanMask</strong>.</li>
<li>The output of <strong>Filter.ByBooleanMask</strong> reads <em>&quot;in&quot;</em> and <em>&quot;out&quot;</em>. <em>&quot;In&quot;</em> represents values which had a mask value of <em>&quot;true&quot;</em> while <em>&quot;out&quot;</em> represents values which had a value of <em>&quot;false&quot;</em>. By plugging the <em>&quot;in&quot;</em> outputs into the <em>startPoint</em> and <em>endPoint</em> inputs of a <strong>Line.ByStartPointEndPoint</strong> node, we've created a filtered list of lines.</li>
<li>The <strong>Watch3D</strong> node reveals that we have fewer lines than points. We've selected only 25% of the nodes by filtering only the true values!</li>
</ol>
</blockquote>
<div style="break-before: page; page-break-before: always;"></div><h1 id="lists-of-lists"><a class="header" href="#lists-of-lists">Lists of Lists</a></h1>
<h3 id="lists-of-lists-1"><a class="header" href="#lists-of-lists-1">Lists of Lists</a></h3>
<p>Let's add one more tier to the hierarchy. If we take the deck of cards from the original example and create a box which contains multiple decks, the box now represents a list of decks, and each deck represents a list of cards. This is a list of lists. For the analogy in this section, the image below contains a list of coin rolls, and each roll contains a list of pennies.</p>
<p><img src="5_essential_nodes_and_concepts/5-4_designing-with-lists/../images/5-4/3/coins-521245_640.jpg" alt="Coins" /></p>
<blockquote>
<p>Photo by <a href="https://commons.wikimedia.org/wiki/File:Stack_of_coins_0214.jpg">Dori</a>.</p>
</blockquote>
<h3 id="query-1"><a class="header" href="#query-1">Query</a></h3>
<p>What <strong>queries</strong> can we make from the list of lists? This accesses existing properties.</p>
<ul>
<li>Number of coin types? 2.</li>
<li>Coin type values? $0.01 and $0.25.</li>
<li>Material of quarters? 75% copper and 25% nickel.</li>
<li>Material of pennies? 97.5% zinc and 2.5% copper.</li>
</ul>
<h3 id="action-1"><a class="header" href="#action-1">Action</a></h3>
<p>What <strong>actions</strong> can we perform on the list of lists? This changes the list of lists based on a given operation.</p>
<ul>
<li>Select a specific stack of quarters or pennies.</li>
<li>Select a specific quarter or penny.</li>
<li>Rearrange the stacks of quarters and pennies.</li>
<li>Shuffle the stacks together.</li>
</ul>
<p>Again, Dynamo has an analogous node for each one of the operations above. Since we're working with abstract data and not physical objects, we need a set of rules to govern how we move up and down the data hierarchy.</p>
<p>When dealing with lists of lists, the data is layered and complex, but this provides an opportunity to do some awesome parametric operations. Let's break down the fundamentals and discuss a few more operations in the lessons below.</p>
<h2 id="exercise-4"><a class="header" href="#exercise-4">Exercise</a></h2>
<h3 id="top-down-hierarchy"><a class="header" href="#top-down-hierarchy">Top-Down Hierarchy</a></h3>
<blockquote>
<p>Download the example file by clicking on the link below.</p>
<p>A full list of example files can be found in the Appendix.</p>
</blockquote>
<p>{% file src=&quot;../datasets/5-4/3/Top-Down-Hierarchy.dyn&quot; %}</p>
<p>The fundamental concept to learn from this section: <strong>Dynamo treats lists as objects in and of themselves</strong>. This top-down hierarchy is developed with object-oriented programming in mind. Rather than selecting sub-elements with a command like <strong>List.GetItemAtIndex</strong>, Dynamo will select that index of the main list in the data structure. And that item can be another list. Let's break it down with an example image:</p>
<p><img src="5_essential_nodes_and_concepts/5-4_designing-with-lists/../images/5-4/3/listsoflists-topdownhierachy.jpg" alt="top-down" /></p>
<blockquote>
<ol>
<li>With <strong>Code Block</strong>, we've defined two ranges: <code>0..2; 0..3;</code></li>
<li>These ranges are connected to a <strong>Point.ByCoordinates</strong> node with lacing set to <em>&quot;Cross Product&quot;</em>. This creates a grid of points, and also returns a list of lists as an output.</li>
<li>Notice that the <strong>Watch</strong> node gives 3 lists with 4 items in each list.</li>
<li>When using <strong>List.GetItemAtIndex</strong>, with an index of 0, Dynamo selects the first list and all of its contents. Other programs may select the first item of every list in the data structure, but Dynamo employs a top-down hierarchy when dealing with data.</li>
</ol>
</blockquote>
<h3 id="listflatten"><a class="header" href="#listflatten">List.Flatten</a></h3>
<blockquote>
<p>Download the example file by clicking on the link below.</p>
<p>A full list of example files can be found in the Appendix.</p>
</blockquote>
<p>{% file src=&quot;../datasets/5-4/3/Flatten.dyn&quot; %}</p>
<p>Flatten removes all tiers of data from a data structure. This is helpful when the data hierarchies are not necessary for your operation, but it can be risky because it removes information. The example below shows the result of flattening a list of data.</p>
<p><img src="5_essential_nodes_and_concepts/5-4_designing-with-lists/../images/5-4/3/listsoflists-flatten01.jpg" alt="Exercise" /></p>
<blockquote>
<ol>
<li>Insert one line of code to define a range in <strong>Code Block</strong>: <code>-250..-150..#4;</code></li>
<li>Plugging the <em>code block</em> into the <em>x</em> and <em>y</em> input of a <strong>Point.ByCoordinates</strong> node, we set the lacing to <em>&quot;Cross Product&quot;</em> to get a grid of points.</li>
<li>The <strong>Watch</strong> node shows that we have a list of lists.</li>
<li>A <strong>PolyCurve.ByPoints</strong> node will reference each list and create a respective polycurve. Notice in the Dynamo preview that we have four polycurves representing each row in the grid.</li>
</ol>
</blockquote>
<p><img src="5_essential_nodes_and_concepts/5-4_designing-with-lists/../images/5-4/3/listsoflists-flatten02.jpg" alt="Exercise" /></p>
<blockquote>
<ol>
<li>By inserting a <em>flatten</em> before the polycurve node, we've created one single list for all of the points. The <strong>PolyCurve.ByPoints</strong> node references a list to create one curve, and since all of the points are on one list, we get one zig-zag polycurve which runs throughout the entire list of points.</li>
</ol>
</blockquote>
<p>There are also options for flattening isolated tiers of data. Using the <strong>List.Flatten</strong> node, you can define a set number of data tiers to flatten from the top of the hierarchy. This is a really helpful tool if you're struggling with complex data structures which are not necessarily relevant to your workflow. And another option is to use the flatten node as a function in <strong>List.Map</strong>. We'll discuss more about <strong>List.Map</strong> below.</p>
<h3 id="chop"><a class="header" href="#chop">Chop</a></h3>
<blockquote>
<p>Download the example file by clicking on the link below.</p>
<p>A full list of example files can be found in the Appendix.</p>
</blockquote>
<p>{% file src=&quot;../datasets/5-4/3/Chop.dyn&quot; %}</p>
<p>When parametric modeling, there are also times where you'll want to modify the data structure to an existing list. There are many nodes available for this as well, and chop is the most basic version. With chop, we can partition a list into sublists with a set number of items.</p>
<p>The chop command divides lists based on a given list length. In some ways, chop is the opposite of flatten: rather than removing data structure, it adds new tiers to it. This is a helpful tool for geometric operations like the example below.</p>
<p><img src="5_essential_nodes_and_concepts/5-4_designing-with-lists/../images/5-4/3/listsoflists-chop.jpg" alt="Exercise" /></p>
<h3 id="listmap"><a class="header" href="#listmap">List.Map</a></h3>
<blockquote>
<p>Download the example file by clicking on the link below.</p>
<p>A full list of example files can be found in the Appendix.</p>
</blockquote>
<p>{% file src=&quot;../datasets/5-4/3/Map.dyn&quot; %}</p>
<p>A <strong>List.Map/Combine</strong> applies a set function to an input list, but one step down in the hierarchy. Combinations are the same as Maps, except combinations can have multiple inputs corresponding to the input of a given function.</p>
<p><em>Note: This exercise was created with a previous version of Dynamo. Much of the</em> <strong>List.Map</strong> <em>functionality has been resolved with the addition of the</em> <strong>List@Level</strong> <em>feature. For more information, see</em> <a href="5_essential_nodes_and_concepts/5-4_designing-with-lists/6-3_lists-of-lists.html#listlevel"><em>List@Level</em></a> <em>below.</em></p>
<p>As a quick introduction, let's review the <strong>List.Count</strong> node from a previous section.</p>
<p>The <strong>List.Count</strong> node counts all of the items in a list. We'll use this to demonstrate how <strong>List.Map</strong> works.</p>
<p><img src="5_essential_nodes_and_concepts/5-4_designing-with-lists/../images/5-4/3/listsoflists-map01.jpg" alt="" /></p>
<blockquote>
<ol>
<li>
<p>Insert two lines of code into the <strong>Code Block</strong>: <code>-50..50..#Nx; -50..50..#Ny;</code></p>
<p>After typing in this code, the code block will create two inputs for Nx and Ny.</p>
</li>
<li>
<p>With two <em>integer sliders</em>, define the <em>Nx</em> and <em>Ny</em> values by connecting them to the <strong>Code Block</strong>.</p>
</li>
<li>
<p>Connect each line of the code block into the respective <em>X</em> and <em>Y</em> inputs of a <strong>Point.ByCoordinates</strong> node. Right click the node, select &quot;Lacing&quot;, and choose <em>&quot;Cross Product&quot;</em>. This creates a grid of points. Because we defined the range from -50 to 50, we are spanning the default Dynamo grid.</p>
</li>
<li>
<p>A <em><strong>Watch</strong></em> node reveals the points created. Notice the data structure. We've created a list of lists. Each list represents a row of points of the grid.</p>
</li>
</ol>
</blockquote>
<p><img src="5_essential_nodes_and_concepts/5-4_designing-with-lists/../images/5-4/3/listsoflists-map02(1).jpg" alt="Exercise" /></p>
<blockquote>
<ol>
<li>Attach a <strong>List.Count</strong> node to the output of the watch node from the previous step.</li>
<li>Connect a <strong>Watch</strong> node to the <strong>List.Count</strong> output.</li>
</ol>
</blockquote>
<p>Notice that the List.Count node gives a value of 5. This is equal to the &quot;Nx&quot; variable as defined in the code block. Why is this?</p>
<ul>
<li>First, the <strong>Point.ByCoordinates</strong> node uses the &quot;x&quot; input as the primary input for creating lists. When Nx is 5 and Ny is 3, we get a list of 5 lists, each with 3 items.</li>
<li>Since Dynamo treats lists as objects in and of themselves, a <strong>List.Count</strong> node is applied to the main list in the hierarchy. The result is a value of 5, or, the number of lists in the main list.</li>
</ul>
<p><img src="5_essential_nodes_and_concepts/5-4_designing-with-lists/../images/5-4/3/listsoflists-map03.jpg" alt="Exercise" /></p>
<blockquote>
<ol>
<li>By using a <strong>List.Map</strong> node, we take a step down in the hierarchy and perform a <em>&quot;function&quot;</em> at this level.</li>
<li>Notice that the <strong>List.Count</strong> node has no input. It is being used as a function, so the <strong>List.Count</strong> node will be applied to every individual list one step down in the hierarchy. The blank input of <strong>List.Count</strong> corresponds to the list input of <strong>List.Map</strong>.</li>
<li>The results of <strong>List.Count</strong> now gives a list of 5 items, each with a value of 3. This represents the length of each sublist.</li>
</ol>
</blockquote>
<h3 id="listcombine"><a class="header" href="#listcombine"><strong>List.Combine</strong></a></h3>
<p><em>Note: This exercise was created with a previous version of Dynamo. Much of the List.Combine functionality has been resolved with the addition of the</em> <strong>List@Level</strong> <em>feature. For more information, see</em> <a href="5_essential_nodes_and_concepts/5-4_designing-with-lists/6-3_lists-of-lists.html#listlevel"><em>List@Level</em></a> <em>below.</em></p>
<p>In this exercise, we will use <strong>List.Combine</strong> to demonstrate how it can be used to apply a function across separate lists of objects.</p>
<p>Start by setting up two lists of points.</p>
<p><img src="5_essential_nodes_and_concepts/5-4_designing-with-lists/../images/5-4/3/listsoflists-combined01.jpg" alt="Exercise" /></p>
<blockquote>
<ol>
<li>Use <strong>Sequence</strong> node to generate 10 values, each with a 10 step increment.</li>
<li>Connect the result to the x input of a <strong>Point.ByCoordinates</strong> node. This will create a list of points in Dynamo.</li>
<li>Add a second <strong>Point.ByCoordinates</strong> node to the workspace, use the same <strong>Sequence</strong> output as its x input, but use an <strong>Interger Slider</strong> as its y input, and set its value to 31 (it can be any value as long as they do not overlap with the first set of points) so the 2 sets of points are not overlapped on top of each other.</li>
</ol>
</blockquote>
<p>Next, we will use <strong>List.Combine</strong> to apply a function on objects in 2 separate lists. In this case, it will be a simple draw line function.</p>
<p><img src="5_essential_nodes_and_concepts/5-4_designing-with-lists/../images/5-4/3/listsoflists-combined02.jpg" alt="Exercise" /></p>
<blockquote>
<ol>
<li>Add <strong>List.Combine</strong> to the workspace and connect the 2 set of points as its list0 &amp; list1 input.</li>
<li>Use a <strong>Line.ByStartPointEndPoint</strong> as the input function for <strong>List.Combine</strong>.</li>
</ol>
</blockquote>
<p>Once completed, the 2 set of points are zipped/paired together through a <strong>Line.ByStartPointEndPoint</strong> function and returning 10 lines in Dynamo.</p>
<p>{% hint style=&quot;info&quot; %}
Refer to exercise in n-Dimensional Lists to see another example of using List.Combine.
{% endhint %}</p>
<h3 id="listlevel"><a class="header" href="#listlevel">List@Level</a></h3>
<blockquote>
<p>Download the example file by clicking on the link below.</p>
<p>A full list of example files can be found in the Appendix.</p>
</blockquote>
<p>{% file src=&quot;../datasets/5-4/3/Listatlevel.dyn&quot; %}</p>
<p>Preferred to <strong>List.Map</strong>, the <strong>List@Level</strong> feature allows you to directly select which level of list you want to work with right at the input port of the node. This feature can be applied to any incoming input of a node and will allow you access the levels of your lists quicker and easier than other methods. Just tell the node what level of the list you want to use as the input and let the node do the rest.</p>
<p>In this exercise, we will use the <strong>List@Level</strong> feature to isolate a specific level of data.</p>
<p><img src="5_essential_nodes_and_concepts/5-4_designing-with-lists/../images/5-4/3/listsoflists-listatlevel01.jpg" alt="List@Level" /></p>
<p>We will start with a simple 3D grid of points.</p>
<blockquote>
<ol>
<li>The grid is constructed with a Range for X, Y and Z, we know that the data is structured with 3 tiers: an X List, Y List and Z List.</li>
<li>These tiers exist at different <strong>Levels</strong>. The Levels are indicated at the bottom of the Preview Bubble. The list Levels columns correspond to the list data above to help identify which level to work within.</li>
<li>The list levels are organized in reverse order so that the lowest level data is always in L1. This will help ensure that your graphs will work as planned, even if anything is changed upstream.</li>
</ol>
</blockquote>
<p><img src="5_essential_nodes_and_concepts/5-4_designing-with-lists/../images/5-4/3/listsoflists-listatlevel02.jpg" alt="List@Level" /></p>
<blockquote>
<ol>
<li>To use the <strong>List@Level</strong> function, click '&gt;'. Inside this menu, you will see two checkboxes.</li>
<li><strong>Use Levels</strong> - This enables the <strong>List@Level</strong> functionality. After clicking on this option, you will be able to click through and select the input list levels you want the node to use. With this menu, you can quickly try out different level options by clicking up or down.</li>
<li><em>Keep list structure</em>  If enabled, you will have the option to keep that inputs level structure. Sometimes, you may have purposefully organized your data into sublists. By checking this option, you can keep your list organization intact and not lose any information.</li>
</ol>
</blockquote>
<p>With our simple 3D grid, we can access and visualize the list structure by toggling through the List Levels. Each list level and index combination will return a different set of points from our original 3D set.</p>
<p><img src="5_essential_nodes_and_concepts/5-4_designing-with-lists/../images/5-4/3/listsoflists-listatlevel03.jpg" alt="" /></p>
<blockquote>
<ol>
<li>@L2 in DesignScript allows us to select only the List at Level 2. The List at Level 2 with the index 0 includes only the first set of Y points, returning only the XZ grid.</li>
<li>If we change the Level filter to L1, we will be able to see everything in the first List Level. The List at Level 1 with the index 0 includes all of our 3D points in a flat list.</li>
<li>If we try the same for L3 we will see only the third List Level points. The List at Level 3 with the index 0 includes only the first set of Z points, returning only an XY grid.</li>
<li>If we try the same for L4 we will see only the third List Level points. The List at Level 4 with the index 0 includes only the first set of X points, returning only an YZ grid.</li>
</ol>
</blockquote>
<p>Although this particular example can also be created with <strong>List.Map</strong>, <strong>List@Level</strong> greatly simplifies the interaction, making it easy to access the node data. Take a look below at a comparison between a <strong>List.Map</strong> and <strong>List@Level</strong> methods:</p>
<p><img src="5_essential_nodes_and_concepts/5-4_designing-with-lists/../images/5-4/3/listsoflists-listatlevel04.jpg" alt="" /></p>
<blockquote>
<ol>
<li>Although both methods will give us access to the same points, the <strong>List@Level</strong> method allows us to easily toggle between layers of data within a single node.</li>
<li>To access a point grid with <strong>List.Map</strong>, we will need a <strong>List.GetItemAtIndex</strong> node alongside the <strong>List.Map</strong>. For every list level that we are stepping down, we will need to use an additional <strong>List.Map</strong> node. Depending on the complexity of your lists, this could require you to add a significant amount of <strong>List.Map</strong> Nodes to your graph to access the right level of information.</li>
<li>In this example, a <strong>List.GetItemAtIndex</strong> node with a <strong>List.Map</strong> node returns the same set of points with the same list structure as the <strong>List.GetItemAtIndex</strong> with '@L3' selected.</li>
</ol>
</blockquote>
<h3 id="transpose"><a class="header" href="#transpose">Transpose</a></h3>
<blockquote>
<p>Download the example file by clicking on the link below.</p>
<p>A full list of example files can be found in the Appendix.</p>
</blockquote>
<p>{% file src=&quot;../datasets/5-4/3/Transpose.dyn&quot; %}</p>
<p>Transpose is a fundamental function when dealing with lists of lists. Just as in spreadsheet programs, a transpose flips the columns and rows of a data structure. We'll demonstrate this with a basic matrix below, and in the following section, we'll demonstrate how a transpose can be use to create geometric relationships.</p>
<p><img src="5_essential_nodes_and_concepts/5-4_designing-with-lists/../images/5-4/3/transpose1.jpg" alt="Transpose" /></p>
<p>Let's delete the <strong>List.Count</strong> nodes from the previous exercise and move on to some geometry to see how the data structured.</p>
<p><img src="5_essential_nodes_and_concepts/5-4_designing-with-lists/../images/5-4/3/listsoflists-transpose01.jpg" alt="" /></p>
<blockquote>
<ol>
<li>Connect a <strong>PolyCurve.ByPoints</strong> to the output of the watch node from <strong>Point.ByCoordinates</strong>.</li>
<li>The output shows 5 polycurves, and we can see the curves in our Dynamo preview. The Dynamo node is looking for a list of points (or a list of lists of points in this case) and creating a single polycurve from them. Essentially, each list has converted to a curve in the data structure.</li>
</ol>
</blockquote>
<p><img src="5_essential_nodes_and_concepts/5-4_designing-with-lists/../images/5-4/3/listsoflists-transpose02.jpg" alt="" /></p>
<blockquote>
<ol>
<li>A <strong>List.Transpose</strong> node will switch all of the items with all of the lists in a list of lists. This sounds complicated, but it's the same logic as transpose in Microsoft Excel: switching columns with rows in a data structure.</li>
<li>Notice the abstract result: the transpose changed the list structure from a 5 lists with 3 items each to 3 lists with 5 items each.</li>
<li>Notice the geometric result: using <strong>PolyCurve.ByPoints</strong>, we get 3 polycurves in the perpendicular direction to the original curves.</li>
</ol>
</blockquote>
<h2 id="code-block-for-list-creation"><a class="header" href="#code-block-for-list-creation">Code Block for List Creation</a></h2>
<p>Code block shorthand uses &quot;[]&quot; to define a list. This is a much faster and more fluid way to create list than the <strong>List.Create</strong> node. <strong>Code block</strong> is discussed in more detail in <a href="5_essential_nodes_and_concepts/5-4_designing-with-lists/../../8_coding_in_dynamo/8-1_code-blocks-and-design-script/">Code Blocks and DesignScript</a>. Reference the image below to note how a list with multiple expressions can be defined with code block.</p>
<p><img src="5_essential_nodes_and_concepts/5-4_designing-with-lists/../images/5-4/3/listsoflists-codeblockforlistcreation01.jpg" alt="" /></p>
<h4 id="code-block-query"><a class="header" href="#code-block-query">Code Block Query</a></h4>
<p><strong>Code block</strong> shorthand uses &quot;[]&quot; as a quick and easy way to select specific items that you want from a complex data structure. <strong>Code blocks</strong> are discussed in more detail in <a href="5_essential_nodes_and_concepts/5-4_designing-with-lists/../../8_coding_in_dynamo/8-1_code-blocks-and-design-script/">Code Block and DesignScript chapter</a>. Reference the image below to note how a list with multiple data types can be queried with code block.</p>
<p><img src="5_essential_nodes_and_concepts/5-4_designing-with-lists/../images/5-4/3/listsoflists-codeblockforlistcreation02.jpg" alt="" /></p>
<h2 id="exercise---querying-and-inserting-data"><a class="header" href="#exercise---querying-and-inserting-data">Exercise - Querying and Inserting Data</a></h2>
<blockquote>
<p>Download the example file by clicking on the link below.</p>
<p>A full list of example files can be found in the Appendix.</p>
</blockquote>
<p>{% file src=&quot;../datasets/5-4/3/ReplaceItems.dyn&quot; %}</p>
<p>This exercise uses some of the logic established in the previous one to edit a surface. Our goal here is intuitive, but the data structure navigation will be more involved. We want to articulate a surface by moving a control point.</p>
<p>Begin with the string of nodes above. We are creating a basic surface which spans the default Dynamo grid.</p>
<p><img src="5_essential_nodes_and_concepts/5-4_designing-with-lists/../images/5-4/3/listoflists-exercisecbinsert&amp;query01.jpg" alt="" /></p>
<blockquote>
<ol>
<li>Using <strong>Code Block</strong>, insert these two lines of code and connect to the <em>u</em> and <em>v</em> inputs of <strong>Surface.PointAtParameter</strong>, respectively: <code>-50..50..#3;</code> <code>-50..50..#5;</code></li>
<li>Be sure to set the Lacing of <strong>Surface.PointAtParameter</strong> to <em>&quot;Cross Product&quot;</em>.</li>
<li>The <strong>Watch</strong> node show that we have a list of 3 lists, each with 5 items.</li>
</ol>
</blockquote>
<p>In this step, we want to query the central point in the grid we've created. To do this we'll select the middle point in the middle list. Makes sense, right?</p>
<p><img src="5_essential_nodes_and_concepts/5-4_designing-with-lists/../images/5-4/3/listoflists-exercisecbinsert&amp;query02.jpg" alt="" /></p>
<blockquote>
<ol>
<li>To confirm that this is the correct point, we can also click through the watch node items to confirm that we're targeting the correct one.</li>
<li>Using <strong>Code Block</strong>, we'll write a basic line of code for querying a list of lists:<br />
<code>points[1][2];</code></li>
<li>Using <strong>Geometry.Translate</strong>, we'll move the selected point up in the <em>Z</em> direction by <em>20</em> units.</li>
</ol>
</blockquote>
<p><img src="5_essential_nodes_and_concepts/5-4_designing-with-lists/../images/5-4/3/listoflists-exercisecbinsert&amp;query03.jpg" alt="" /></p>
<blockquote>
<ol>
<li>Let's also select the middle row of points with a <strong>List.GetItemAtIndex</strong> node. Note: Similar to a previous step, we can also query the list with <strong>Code Block</strong>, using a line of <code>points[1];</code></li>
</ol>
</blockquote>
<p>So far we've successfully queried the center point and moved it upward. Now we want need to insert this moved point back into the original data structure.</p>
<p><img src="5_essential_nodes_and_concepts/5-4_designing-with-lists/../images/5-4/3/listoflists-exercisecbinsert&amp;query04.jpg" alt="" /></p>
<blockquote>
<ol>
<li>First, we want to replace the item of the list we isolated in a previous step.</li>
<li>Using <strong>List.ReplaceItemAtIndex</strong>, we'll replace the middle item by using and index of <em>&quot;2&quot;</em>, with the replacement item connected to the moved point (<strong>Geometry.Translate</strong>).</li>
<li>The output shows that we've input the moved point into the middle item of the list.</li>
</ol>
</blockquote>
<p>Now that we've modified the list, we need to insert this list back into the original data structure: the list of lists.</p>
<p><img src="5_essential_nodes_and_concepts/5-4_designing-with-lists/../images/5-4/3/listoflists-exercisecbinsert&amp;query05.jpg" alt="" /></p>
<blockquote>
<ol>
<li>Following the same logic, use <strong>List.ReplaceItemAtIndex</strong> to replace the middle list with the our modified list.</li>
<li>Notice that the <strong>Code Block</strong><em>s</em> defining the index for these two nodes are 1 and 2, which matches the original query from the <strong>Code Block</strong> (<em>points[1][2]</em>).</li>
<li>By selecting the list at <em>index 1</em>, we see the data structure highlighted in the Dynamo preview. We successfully merged the moved point into the original data structure.</li>
</ol>
</blockquote>
<p>There are many ways to make a surface from this set of points. In this case, we're going to create a surface by lofting curves together.</p>
<p><img src="5_essential_nodes_and_concepts/5-4_designing-with-lists/../images/5-4/3/listoflists-exercisecbinsert&amp;query06.jpg" alt="" /></p>
<blockquote>
<ol>
<li>Create a <strong>NurbsCurve.ByPoints</strong> node and connect the new data structure to create three nurbs curves.</li>
</ol>
</blockquote>
<p><img src="5_essential_nodes_and_concepts/5-4_designing-with-lists/../images/5-4/3/listoflists-exercisecbinsert&amp;query07.jpg" alt="" /></p>
<blockquote>
<ol>
<li>Connect a <strong>Surface.ByLoft</strong> to the output from <strong>NurbsCurve.ByPoints</strong>. We now have a modified surface. We can change the original <em>Z</em> value of Geometry. Translate and watch the geometry update!</li>
</ol>
</blockquote>
<div style="break-before: page; page-break-before: always;"></div><h1 id="n-dimensional-lists"><a class="header" href="#n-dimensional-lists">n-Dimensional Lists</a></h1>
<p>Further down the rabbit-hole, let's add even more tiers to hierarchy. Data structure can expand far beyond a two-dimensional list of lists. Since lists are items in and of themselves in Dynamo, we can create data with as many dimensions as possible.</p>
<p>The analogy we'll work with here are Russian Nesting Dolls. Each list can be regarded as one container holding multiple items. Each list has its own properties and is also regarded as its own object.</p>
<p><img src="5_essential_nodes_and_concepts/5-4_designing-with-lists/../images/5-4/4/145493363_fc9ff5164f_o.jpg" alt="Dolls" /></p>
<blockquote>
<p>A set of Russian Nesting Dolls (Photo by <a href="https://www.flickr.com/photos/beppezizzi/145493363">Zeta</a>) is an analogy for n-Dimensional lists. Each layer represents a list, and each list contains items within it. In Dynamo's case, each container can have multiple containers inside (representing the items of each list).</p>
</blockquote>
<p>n-Dimensional lists are difficult to explain visually, but we've set up a few exercises in this chapter which focus on working with lists which venture beyond two dimensions.</p>
<h3 id="mapping-and-combinations"><a class="header" href="#mapping-and-combinations">Mapping and Combinations</a></h3>
<p>Mapping is arguably the most complex part of data management in Dynamo, and is especially relevant when working with complex hierarchies of lists. With the series of exercises below, we'll demonstrate when to use mapping and combinations as data becomes multi-dimensional.</p>
<p>Preliminary introductions to <strong>List.Map</strong> and <strong>List.Combine</strong> can be found in the previous section. In the last exercise below, we'll use these nodes on a complex data structure.</p>
<h2 id="exercise---2d-lists---basic"><a class="header" href="#exercise---2d-lists---basic">Exercise - 2D Lists - Basic</a></h2>
<blockquote>
<p>Download the example file by clicking on the link below.</p>
<p>A full list of example files can be found in the Appendix.</p>
</blockquote>
<p>{% file src=&quot;../datasets/5-4/4/n-Dimensional-Lists.zip&quot; %}</p>
<p>This exercise is the first in a series of three which focuses on articulating imported geometry. Each part in this series of exercises will increase in the complexity of data structure.</p>
<p><img src="5_essential_nodes_and_concepts/5-4_designing-with-lists/../images/5-4/4/n-dimensionallists-2dlistsbasic01.jpg" alt="Exercise" /></p>
<blockquote>
<ol>
<li>Let's begin with the .sat file in the exercise file folder. We can grab this file using the <strong>File Path</strong> node.</li>
<li>With <strong>Geometry.ImportFromSAT</strong>, the geometry is imported into our Dynamo preview as two surfaces.</li>
</ol>
</blockquote>
<p>For this exercise, we want to keep it simple and work with one of the surfaces.</p>
<p><img src="5_essential_nodes_and_concepts/5-4_designing-with-lists/../images/5-4/4/n-dimensionallists-2dlistsbasic02.jpg" alt="" /></p>
<blockquote>
<ol>
<li>Let's select the index of 1 to grab the upper surface. We do this with <strong>List.GetItemAtIndex</strong> node.</li>
<li>Switch off the geometry preview from <strong>Geometry.ImportFromSAT</strong> preview.</li>
</ol>
</blockquote>
<p>The next step is to divide the surface into a grid of points.</p>
<p><img src="5_essential_nodes_and_concepts/5-4_designing-with-lists/../images/5-4/4/n-dimensionallists-2dlistsbasic03.jpg" alt="" /></p>
<blockquote>
<p>1. Using <strong>Code Block</strong>, insert these two lines of code: <code>0..1..#10;</code> <code>0..1..#5;</code></p>
<p>2. With the <strong>Surface.PointAtParameter</strong>, connect the two code block values to u and <em>v</em>. Change the <em>lacing</em> of this node to <em>&quot;Cross Product&quot;</em>.</p>
<p>3. The output reveals the data structure, which is also visible in the Dynamo preview.</p>
</blockquote>
<p>Next, used the Points from last step to generate ten curves along the surface.</p>
<p><img src="5_essential_nodes_and_concepts/5-4_designing-with-lists/../images/5-4/4/n-dimensionallists-2dlistsbasic04.jpg" alt="" /></p>
<blockquote>
<ol>
<li>To get a look at how the data structure is organized, let's connect a <strong>NurbsCurve.ByPoints</strong> to the output of <strong>Surface.PointAtParameter</strong>.</li>
<li>You may switch off the preview from the <strong>List.GetItemAtIndex</strong> Node for now for a clearer result.</li>
</ol>
</blockquote>
<p><img src="5_essential_nodes_and_concepts/5-4_designing-with-lists/../images/5-4/4/n-dimensionallists-2dlistsbasic05.jpg" alt="" /></p>
<blockquote>
<ol>
<li>A basic <strong>List.Transpose</strong> will flip the columns and rows of a list of lists.</li>
<li>Connecting the output of <strong>List.Transpose</strong> to <strong>NurbsCurve.ByPoints</strong>, we now get five curves running horizontally across the surface.</li>
<li>You may switch off the preview from the <strong>NurbsCurve.ByPoints</strong> Node in the previous step to achieve the same result in the image.</li>
</ol>
</blockquote>
<h2 id="exercise---2d-lists---advanced"><a class="header" href="#exercise---2d-lists---advanced">Exercise - 2D Lists - Advanced</a></h2>
<p>Let's increase the complexity. Suppose we wanted to perform an operation on the curves created from the previous exercise. Perhaps we want to relate these curves to another surface and loft between them. This requires more attention to data structure, but the underlying logic is the same.</p>
<p><img src="5_essential_nodes_and_concepts/5-4_designing-with-lists/../images/5-4/4/n-dimensionallists-2dlistsadvance01.jpg" alt="" /></p>
<blockquote>
<ol>
<li>Begin with a step from the previous exercise, isolating the upper surface of the imported geometry with the <strong>List.GetItemAtIndex</strong> node.</li>
</ol>
</blockquote>
<p><img src="5_essential_nodes_and_concepts/5-4_designing-with-lists/../images/5-4/4/n-dimensionallists-2dlistsadvance02.jpg" alt="" /></p>
<blockquote>
<ol>
<li>Using <strong>Surface.Offset</strong>, offset the surface by a value of <em>10</em>.</li>
</ol>
</blockquote>
<p><img src="5_essential_nodes_and_concepts/5-4_designing-with-lists/../images/5-4/4/n-dimensionallists-2dlistsadvance03.jpg" alt="" /></p>
<blockquote>
<ol>
<li>In the same manner as the previous exercise, define a <em>code block</em> with these two lines of code: <code>0..1..#10;</code> <code>0..1..#5;</code></li>
<li>Connect these outputs to two <strong>Surface.PointAtParameter</strong> nodes, each with <em>lacing</em> set to <em>&quot;Cross Product&quot;</em>. One of these nodes is connected to the original surface, while the other is connected to the offset surface.</li>
</ol>
</blockquote>
<p><img src="5_essential_nodes_and_concepts/5-4_designing-with-lists/../images/5-4/4/n-dimensionallists-2dlistsadvance04.jpg" alt="" /></p>
<blockquote>
<ol>
<li>Switch off the preview of these Surfaces.</li>
<li>As in the previous exercise, connect the outputs to two <strong>NurbsCurve.ByPoints</strong> nodes. The result show curves corresponding to two surfaces.</li>
</ol>
</blockquote>
<p><img src="5_essential_nodes_and_concepts/5-4_designing-with-lists/../images/5-4/4/n-dimensionallists-2dlistsadvance05.jpg" alt="" /></p>
<blockquote>
<ol>
<li>By using <strong>List.Create</strong>, we can combine the two sets of curves into one list of lists.</li>
<li>Notice from the output, we have two lists with ten items each, representing each connect set of Nurbs curves.</li>
<li>By performing a <strong>Surface.ByLoft</strong>, we can visually make sense of this data structure. The node lofts all of the curves in each sublist.</li>
</ol>
</blockquote>
<p><img src="5_essential_nodes_and_concepts/5-4_designing-with-lists/../images/5-4/4/n-dimensionallists-2dlistsadvance06.jpg" alt="" /></p>
<blockquote>
<ol>
<li>Switch off the preview from <strong>Surface.ByLoft</strong> Node in previous step.</li>
<li>By using <strong>List.Transpose</strong>, remember, we are flipping all of the columns and rows. This node will transfer two lists of ten curves into ten lists of two curves. We now have each nurbs curve related to the neighboring curve on the other surface.</li>
<li>Using <strong>Surface.ByLoft</strong>, we arrive at a ribbed structure.</li>
</ol>
</blockquote>
<p>Next, we will demonstrate an alternative process to achieve this result</p>
<p><img src="5_essential_nodes_and_concepts/5-4_designing-with-lists/../images/5-4/4/n-dimensionallists-2dlistsadvance07.jpg" alt="" /></p>
<blockquote>
<ol>
<li>Before we start, switch off the <strong>Surface.ByLoft</strong> preview in previous step to avoid confusion.</li>
<li>An alternative to <strong>List.Transpose</strong> uses <strong>List.Combine</strong>. This will operate a <em>&quot;combinator&quot;</em> on each sublist.</li>
<li>In this case, we're using <strong>List.Create</strong> as the <em>&quot;combinator&quot;</em>, which will create a list of each item in the sublists.</li>
<li>Using the <strong>Surface.ByLoft</strong> node, we get the same surfaces as in the previous step. Transpose is easier to use in this case, but when the data structure becomes even more complex, <strong>List.Combine</strong> is more reliable.</li>
</ol>
</blockquote>
<p><img src="5_essential_nodes_and_concepts/5-4_designing-with-lists/../images/5-4/4/n-dimensionallists-2dlistsadvance08.jpg" alt="" /></p>
<blockquote>
<ol>
<li>Stepping back a few steps, if we want to switch the orientation of the curves in the ribbed structure, we want to use a <strong>List.Transpose</strong> before connect to <strong>NurbsCurve.ByPoints</strong>. This will flip the columns and rows, giving us 5 horizontal ribs.</li>
</ol>
</blockquote>
<h2 id="exercise---3d-lists"><a class="header" href="#exercise---3d-lists">Exercise - 3D Lists</a></h2>
<p>Now, we're going to go even one step further. In this exercise, we'll work with both imported surfaces, creating a complex data hierarchy. Still, our aim is to complete the same operation with the same underlying logic.</p>
<p>Begin with the imported file from previous exercise.</p>
<p><img src="5_essential_nodes_and_concepts/5-4_designing-with-lists/../images/5-4/4/n-Dimensional-Lists-3dlist01.jpg" alt="" /></p>
<p><img src="5_essential_nodes_and_concepts/5-4_designing-with-lists/../images/5-4/4/n-Dimensional-Lists-3dlist02.jpg" alt="" /></p>
<blockquote>
<ol>
<li>As in the previous exercise, use the <strong>Surface.Offset</strong> node to offset by a value of <em>10</em>.</li>
<li>Notice from the output, that we've created two surfaces with the offset node.</li>
</ol>
</blockquote>
<p><img src="5_essential_nodes_and_concepts/5-4_designing-with-lists/../images/5-4/4/n-Dimensional-Lists-3dlist03.jpg" alt="" /></p>
<blockquote>
<ol>
<li>In the same manner as the previous exercise, define a <strong>Code Block</strong> with these two lines of code: <code>0..1..#20;</code> <code>0..1..#20;</code></li>
<li>Connect these outputs to two <strong>Surface.PointAtParameter</strong> nodes, each with lacing set to <em>&quot;Cross Product&quot;</em>. One of these nodes is connected to the original surfaces, while the other is connected to the offset surfaces.</li>
</ol>
</blockquote>
<p><img src="5_essential_nodes_and_concepts/5-4_designing-with-lists/../images/5-4/4/n-Dimensional-Lists-3dlist04.jpg" alt="" /></p>
<blockquote>
<ol>
<li>As in the previous exercise, connect the outputs to two <strong>NurbsCurve.ByPoints</strong> nodes.</li>
<li>Looking at the output of the <strong>NurbsCurve.ByPoints,</strong> notice that this is a list of two lists, which is more complex than the previous exercise. The data is categorized by the underlying surface, so we've added another tier to the data structured.</li>
<li>Notice that things become more complex in the <strong>Surface.PointAtParameter</strong> node. In this case we have a list of lists of lists.</li>
</ol>
</blockquote>
<p><img src="5_essential_nodes_and_concepts/5-4_designing-with-lists/../images/5-4/4/n-Dimensional-Lists-3dlist05.jpg" alt="" /></p>
<blockquote>
<ol>
<li>Before we proceed, switch off the preview from the existing surfaces.</li>
<li>Using the <strong>List.Create</strong> node, we merge the Nurbs curves into one data structure, creating a list of lists of lists.</li>
<li>By connecting a <strong>Surface.ByLoft</strong> node, we get a version of the original surfaces, as they each remain in their own list as created from the original data structure.</li>
</ol>
</blockquote>
<p><img src="5_essential_nodes_and_concepts/5-4_designing-with-lists/../images/5-4/4/n-Dimensional-Lists-3dlist06.jpg" alt="" /></p>
<blockquote>
<ol>
<li>In the previous exercise, we were able to use a <strong>List.Transpose</strong> to create a ribbed structure. This won't work here. A transpose should be used on a two-dimensional list, and since we have a three-dimensional list, an operation of &quot;flipping columns and rows&quot; won't work as easily. Remember, lists are objects, so <strong>List.Transpose</strong> will flip our lists with out sublists, but won't flip the nurbs curves one list further down in the hierarchy.</li>
</ol>
</blockquote>
<p><img src="5_essential_nodes_and_concepts/5-4_designing-with-lists/../images/5-4/4/n-Dimensional-Lists-3dlist07.jpg" alt="" /></p>
<blockquote>
<ol>
<li><strong>List.Combine</strong> will work better for us here. We want to use <strong>List.Map</strong> and <strong>List.Combine</strong> nodes when we get to more complex data structures.</li>
<li>Using <strong>List.Create</strong> as the <em>&quot;combinator&quot;</em>, we create a data structure that will work better for us.</li>
</ol>
</blockquote>
<p><img src="5_essential_nodes_and_concepts/5-4_designing-with-lists/../images/5-4/4/n-Dimensional-Lists-3dlist08.jpg" alt="" /></p>
<blockquote>
<ol>
<li>The data structure still needs to be transposed at one step down on the hierarchy. To do this we'll use <strong>List.Map</strong>. This is working like <strong>List.Combine</strong>, except with one input list, rather than two or more.</li>
<li>The function we'll apply to <strong>List.Map</strong> is <strong>List.Transpose</strong>, which will flip the columns and rows of the sublists within our main list.</li>
</ol>
</blockquote>
<p><img src="5_essential_nodes_and_concepts/5-4_designing-with-lists/../images/5-4/4/n-Dimensional-Lists-3dlist09.jpg" alt="" /></p>
<blockquote>
<ol>
<li>Finally, we can loft the Nurbs curves together with a proper data hierarchy, giving us a ribbed structure.</li>
</ol>
</blockquote>
<p><img src="5_essential_nodes_and_concepts/5-4_designing-with-lists/../images/5-4/4/n-Dimensional-Lists-3dlist10.jpg" alt="" /></p>
<blockquote>
<ol>
<li>Let's add some depth to the geometry with a <strong>Surface.Thicken</strong> Node with the input settings as shown.</li>
</ol>
</blockquote>
<p><img src="5_essential_nodes_and_concepts/5-4_designing-with-lists/../images/5-4/4/n-Dimensional-Lists-3dlist11.jpg" alt="" /></p>
<blockquote>
<ol>
<li>It'll be nice to add a surface backing two this structure, so add another <strong>Surface.ByLoft</strong> node and use the first output of <strong>NurbsCurve.ByPoints</strong> from an earlier step as input.</li>
<li>As the preview is getting cluttered, switch off preview for these nodes by right clicking on each of them and uncheck 'preview' to see the result better.</li>
</ol>
</blockquote>
<p><img src="5_essential_nodes_and_concepts/5-4_designing-with-lists/../images/5-4/4/n-Dimensional-Lists-3dlist12.jpg" alt="" /></p>
<blockquote>
<ol>
<li>And thickening these selected surfaces, our articulation is complete.</li>
</ol>
</blockquote>
<p>Not the most comfortable rocking chair ever, but it's got a lot of data going on.</p>
<p><img src="5_essential_nodes_and_concepts/5-4_designing-with-lists/../images/5-4/4/n-Dimensional-Lists-3dlist13.jpg" alt="" /></p>
<p>Last step, let's reverse the direction of the striated members. As we used transpose in the previous exercise, we'll do something similar here.</p>
<p><img src="5_essential_nodes_and_concepts/5-4_designing-with-lists/../images/5-4/4/n-Dimensional-Lists-3dlist14.jpg" alt="" /></p>
<blockquote>
<ol>
<li>Since we have one more tier to the hierarchy, so we need to use <strong>List.Map</strong> with a <strong>List.Tranpose</strong> function to change the direction of our Nurbs curves.</li>
</ol>
</blockquote>
<p><img src="5_essential_nodes_and_concepts/5-4_designing-with-lists/../images/5-4/4/n-Dimensional-Lists-3dlist15.jpg" alt="" /></p>
<blockquote>
<ol>
<li>We may want to increase the number of treads, so we can change the <strong>Code Block</strong> to <code>0..1..#20;</code> <code>0..1..#30;</code></li>
</ol>
</blockquote>
<p>The first version of the rocking chair was sleek, so our second model offers an off-road, sport-utility version of recumbency.</p>
<p><img src="5_essential_nodes_and_concepts/5-4_designing-with-lists/../images/5-4/4/n-Dimensional-Lists-3dlist16.jpg" alt="" /></p>
<div style="break-before: page; page-break-before: always;"></div><h1 id="dictionaries-in-dynamo"><a class="header" href="#dictionaries-in-dynamo">Dictionaries in Dynamo</a></h1>
<p>Dictionaries represent a collection of data that is related to another piece of data known as a key. Dictionaries expose the ability to search for, delete and insert data into a collection.</p>
<p>Essentially, we can think of a dictionary as a really smart way to look something up.</p>
<p><em>While dictionary functionality has been available in Dynamo for some time, Dynamo 2.0 introduces a new way of managing this data type.</em></p>
<p><img src="5_essential_nodes_and_concepts/5-5_dictionaries-in-dynamo/../images/5-5/wildDictionary.png" alt="" /></p>
<p>Original image courtesy of: <a href="http://sixtysecondrevit.com/2018-01-22-new-dictionary-nodes-in-dynamobim-daily-build/"><em>sixtysecondrevit.com</em></a></p>
<div style="break-before: page; page-break-before: always;"></div><h1 id="what-is-a-dictionary"><a class="header" href="#what-is-a-dictionary">What is a Dictionary</a></h1>
<p>Dynamo 2.0 introduces the concept of separating the dictionary data type from the list data type. This change can pose some significant changes to how you create and work with data in your workflows. Prior to 2.0, dictionaries and lists were combined as a data type. In short, lists were actually dictionaries with integer keys.</p>
<h3 id="what-is-a-dictionary-1"><a class="header" href="#what-is-a-dictionary-1"><strong>What is a dictionary?</strong></a></h3>
<p>A dictionary is a data type composed of a collection of key-value pairs where each key is unique in each collection. A dictionary has no order and basically you can look things up using a key instead of an index value like in a list. <em>In Dynamo 2.0, keys can only be strings.</em></p>
<h3 id="what-is-a-list"><a class="header" href="#what-is-a-list"><strong>What is a list?</strong></a></h3>
<p>A list is a data type composed of a collection of ordered values. In Dynamo, lists use integers as index values.</p>
<h3 id="why-was-this-change-made-and-why-should-i-care"><a class="header" href="#why-was-this-change-made-and-why-should-i-care"><strong>Why was this change made and why should I care?</strong></a></h3>
<p>The separation of dictionaries from lists introduces dictionaries as a first-class citizen that you can use to quickly and easily store and lookup values without needing to remember an index value or maintain a strict list structure throughout your workflow. During user testing, we saw a significant reduction in graph size when dictionaries were utilized instead of several <code>GetItemAtIndex</code> nodes.</p>
<h3 id="what-are-the-changes"><a class="header" href="#what-are-the-changes"><strong>What are the changes?</strong></a></h3>
<ul>
<li>
<p><em>Syntax</em> changes have occurred that change how you will initialize and work with dictionaries and lists in code blocks.</p>
<ul>
<li>Dictionaries use the following syntax <code>{key:value}</code></li>
<li>Lists use the following syntax <code>[value,value,value]</code></li>
</ul>
</li>
<li>
<p><em>New nodes</em> have been introduced to the library to help you create, modify, and query dictionaries.</p>
</li>
<li>
<p>Lists created in v1.x code blocks will automatically be migrated on load of the script to the new list syntax that uses square brackets <code>[ ]</code> instead of curly brackets <code>{ }</code> \</p>
<hr />
</li>
</ul>
<p><img src="5_essential_nodes_and_concepts/5-5_dictionaries-in-dynamo/../images/5-5/1/whatisadictionary-whatarethechanges(1).jpg" alt="" /></p>
<hr />
<h3 id="why-should-i-care-what-would-you-use-these-for"><a class="header" href="#why-should-i-care-what-would-you-use-these-for"><strong>Why should I care? What would you use these for?</strong></a></h3>
<p>In computer science, Dictionaries - like lists- are collections of objects. While lists are in a specific order, dictionaries are <em>unordered</em> collections. They are not reliant on sequential numbers (indices), instead, they utilize <em>keys.</em></p>
<p>In the image below we demonstrate a potential use case of a dictionary. Often times dictionaries are used to relate two pieces of data that might not have a direct correlation. In our case, we are connecting the Spanish version of a word to the English version for later lookup.</p>
<p><img src="5_essential_nodes_and_concepts/5-5_dictionaries-in-dynamo/../images/5-5/1/whatisadictionary-whatwouldyouusethesefor.jpg" alt="" /></p>
<blockquote>
<ol>
<li>Build a dictionary to relate the two pieces of data.</li>
<li>Get the value with the given key.</li>
</ol>
</blockquote>
<div style="break-before: page; page-break-before: always;"></div><h1 id="dictionary-nodes"><a class="header" href="#dictionary-nodes">Dictionary Nodes</a></h1>
<p>Dynamo 2.0 exposes a variety of Dictionary nodes for our use. This includes <em>create, action, and query</em> nodes.</p>
<p><img src="5_essential_nodes_and_concepts/5-5_dictionaries-in-dynamo/../images/5-5/2/dictionarynodes-nodes.jpg" alt="" /></p>
<h4 id="create"><a class="header" href="#create">Create</a></h4>
<p>1.<code>Dictionary.ByKeysValues</code> will create a dictionary with the supplied values and keys. <em>(The number of entries will be whatever the shortest list input is)</em></p>
<h4 id="action-2"><a class="header" href="#action-2">Action</a></h4>
<p>2. <code>Dictionary.Components</code> will produce the components of the input dictionary. <em>(This is the reverse of the create node.)</em></p>
<p>3. <code>Dictionary.RemoveKeys</code> will produce a new dictionary object with the input keys removed.</p>
<p>4. <code>Dictionary.SetValueAtKeys</code> will produce a new dictionary based on the input keys and the values to replace the current value at the corresponding keys.</p>
<p>5. <code>Dictionary.ValueAtKey</code> will return the value at the input key.</p>
<h4 id="count"><a class="header" href="#count">Count</a></h4>
<p>6. <code>Dictionary.Count</code> will tell you how many key value pairs are in the dictionary.</p>
<p>7. <code>Dictionary.Keys</code> will return what keys are currently stored in the dictionary.</p>
<p>8. <code>Dictionary.Values</code> will return what values are currently stored in the dictionary.</p>
<p>Overall relating data with dictionaries is a magnificent alternative to the old method of working with indices and lists.</p>
<div style="break-before: page; page-break-before: always;"></div><h1 id="dictionaries-in-code-blocks"><a class="header" href="#dictionaries-in-code-blocks">Dictionaries in Code Blocks</a></h1>
<p>Not only does Dynamo 2.0 introduce the nodes previously discussed for dictionaries, there is new functionality in code blocks for this as well!</p>
<p>You can use syntax like below or DesignScript-based representations of the nodes.</p>
<p><img src="5_essential_nodes_and_concepts/5-5_dictionaries-in-dynamo/../images/5-5/3/dictionariesincb-syntax(1).jpg" alt="" /></p>
<p>Since a dictionary is an object type in Dynamo we can commit the following actions upon it.</p>
<p><img src="5_essential_nodes_and_concepts/5-5_dictionaries-in-dynamo/../images/5-5/3/dictionariesincb-actionswithcodeblocks.jpg" alt="" /></p>
<p>Maintaining these sort of interactions becomes especially useful when relating Revit data to strings. Next, we will look at some Revit use-cases.</p>
<div style="break-before: page; page-break-before: always;"></div><h1 id="revit-use-cases"><a class="header" href="#revit-use-cases">Revit Use-Cases</a></h1>
<p>Have you ever wanted to look up something in Revit by a piece of data that it has?</p>
<p>Chances are if you have you've done something like the following example.</p>
<p>In the image below we are collecting all of the rooms in the Revit model, getting the index of the room we want (by room number), and finally grabbing the room at the index.</p>
<p><img src="5_essential_nodes_and_concepts/5-5_dictionaries-in-dynamo/../images/5-5/4/dictionary-collectroominrevitmodel.jpg" alt="" /></p>
<blockquote>
<ol>
<li>Collect all rooms in the model.</li>
<li>Room number to find.</li>
<li>Get the room number and find what index it is at.</li>
<li>Obtain the room at the index.</li>
</ol>
</blockquote>
<h2 id="exercise--room-dictionary"><a class="header" href="#exercise--room-dictionary">Exercise : Room Dictionary</a></h2>
<h3 id="part-i-creating-room-dictionary"><a class="header" href="#part-i-creating-room-dictionary">Part I: Creating Room Dictionary</a></h3>
<blockquote>
<p>Download the example file by clicking on the link below.</p>
<p>A full list of example files can be found in the Appendix.</p>
</blockquote>
<p>{% file src=&quot;../datasets/5-5/4/roomDictionary.dyn&quot; %}</p>
<p>Now let's recreate this idea using dictionaries. First we need to collect all of the rooms in our Revit model.</p>
<p><img src="5_essential_nodes_and_concepts/5-5_dictionaries-in-dynamo/../images/5-5/4/dictionary-exerciseI-01.jpg" alt="" /></p>
<blockquote>
<ol>
<li>We choose the Revit category we want to work with, (In this case, we are working with rooms).</li>
<li>We tell Dynamo to collect all of those elements</li>
</ol>
</blockquote>
<p>Next, we need to decide what keys we are going to use to look up this data by. (Information on keys can be found on the section, <a href="5_essential_nodes_and_concepts/5-5_dictionaries-in-dynamo/9-1_what-is-a-dictionary.html">What is a dictionary?</a>).</p>
<p><img src="5_essential_nodes_and_concepts/5-5_dictionaries-in-dynamo/../images/5-5/4/dictionary-exerciseI-02.jpg" alt="" /></p>
<blockquote>
<ol>
<li>The data that we will use is the room number.</li>
</ol>
</blockquote>
<p>Now we will create the dictionary with the given keys and elements.</p>
<p><img src="5_essential_nodes_and_concepts/5-5_dictionaries-in-dynamo/../images/5-5/4/dictionary-exerciseI-03.jpg" alt="" /></p>
<blockquote>
<ol>
<li>The node, <strong>Dictionary.ByKeysValues</strong> will create a dictionary given the appropriate inputs.</li>
<li><code>Keys</code> need to be a string, while <code>values</code> can be a variety of object types.</li>
</ol>
</blockquote>
<p>Lastly, we can retrieve a room from the dictionary with its room number now.</p>
<p><img src="5_essential_nodes_and_concepts/5-5_dictionaries-in-dynamo/../images/5-5/4/dictionary-exerciseI-04.jpg" alt="" /></p>
<blockquote>
<ol>
<li><code>String</code> will be the key that we are using to look up an object from the dictionary.</li>
<li><strong>Dictionary.ValueAtKey</strong> will obtain the object from the dictionary now.</li>
</ol>
</blockquote>
<h3 id="part-ii-values-look-up"><a class="header" href="#part-ii-values-look-up">Part II: Values Look Up</a></h3>
<p>Using this same dictionary logic, we can create dictionaries with grouped objects as well. If we wanted to look up all rooms at a given level we can modify the above graph as follows.</p>
<p><img src="5_essential_nodes_and_concepts/5-5_dictionaries-in-dynamo/../images/5-5/4/dictionary-exerciseII-01.jpg" alt="" /></p>
<blockquote>
<ol>
<li>Rather than using the room number as the key, we can now use a parameter value, (in this case we will use level).</li>
</ol>
</blockquote>
<p><img src="5_essential_nodes_and_concepts/5-5_dictionaries-in-dynamo/../images/5-5/4/dictionary-exerciseII-02.jpg" alt="" /></p>
<blockquote>
<ol>
<li>Now, we can group the rooms by the level that they reside on.</li>
</ol>
</blockquote>
<p><img src="5_essential_nodes_and_concepts/5-5_dictionaries-in-dynamo/../images/5-5/4/dictionary-exerciseII-03.jpg" alt="" /></p>
<blockquote>
<ol>
<li>With the elements grouped by the level, we can now use the shared keys (unique keys) as our key for our dictionary, and the lists of rooms as the elements.</li>
</ol>
</blockquote>
<p><img src="5_essential_nodes_and_concepts/5-5_dictionaries-in-dynamo/../images/5-5/4/dictionary-exerciseII-04.jpg" alt="" /></p>
<blockquote>
<ol>
<li>Lastly, using the levels in the Revit model, we can look up which rooms reside on that level in the dictionary. <code>Dictionary.ValueAtKey</code> will take the level name and return the room objects at that level.</li>
</ol>
</blockquote>
<p>The opportunities for Dictionary use are really endless. The ability to relate your BIM data in Revit to the element itself poses a variety of use cases.</p>
<div style="break-before: page; page-break-before: always;"></div><h1 id="custom-nodes--packages"><a class="header" href="#custom-nodes--packages">Custom Nodes &amp; Packages</a></h1>
<p>Out of the box, Dynamo has a lot of functionality stored in its Library of Nodes. For those frequently used routines or that special graph you want to share with the community, Custom Nodes &amp; Packages are a great way to extend Dynamo even further.</p>
<p><img src="6_custom_nodes_and_packages/./images/customNodes_cover01.jpg" alt="" /></p>
<div style="break-before: page; page-break-before: always;"></div><h1 id="custom-nodes"><a class="header" href="#custom-nodes">Custom Nodes</a></h1>
<p>Dynamo offers many Core Nodes for a wide range of visual programming tasks. Sometimes a quicker, more elegant, or more easily shared solution is to build your own Nodes. These can be reused among different projects, they make your graphs clearer and cleaner, and they can be pushed to the package manager and shared with the global Dynamo community.</p>
<p><img src="6_custom_nodes_and_packages/6-1_custom-nodes/../images/6-1/customNodes1(1).png" alt="" /></p>
<div style="break-before: page; page-break-before: always;"></div><h1 id="custom-node-introduction"><a class="header" href="#custom-node-introduction">Custom Node Introduction</a></h1>
<p>Custom Nodes are constructed by nesting other nodes and custom nodes inside of a &quot;Dynamo Custom Node,&quot; which we can think of conceptually as a container. When this container node is executed in your graph, everything inside it will be executed to allow you to reuse and share a useful combination of nodes.</p>
<h3 id="adapting-to-change"><a class="header" href="#adapting-to-change">Adapting to Change</a></h3>
<p>When you have multiple copies of a custom node in your graph, you can update all of them by editing the base custom node. This allows you to update your graph seamlessly by adapting to any changes that may occur in workflow or design.</p>
<h3 id="work-sharing"><a class="header" href="#work-sharing">Work Sharing</a></h3>
<p>Arguably the best feature of custom nodes is their work sharing capabilities. If a &quot;power user&quot; creates a complex Dynamo graph and hands it off to a designer who is new to Dynamo, he/she can condense the graph to the bare essentials for design interaction. The custom node can be opened to edit the internal graph, but the &quot;container&quot; can be kept simple. With this process, custom nodes allow Dynamo users to design a graph that is clean and intuitive.</p>
<p><img src="6_custom_nodes_and_packages/6-1_custom-nodes/../images/6-1/1/customnodeintro-worksharing01.jpg" alt="" /></p>
<h3 id="many-ways-to-build-a-node"><a class="header" href="#many-ways-to-build-a-node">Many Ways to Build a Node</a></h3>
<p>There are a wide variety of ways to build custom nodes in Dynamo. In the examples in this chapter, we'll create custom nodes directly from the Dynamo UI. If you are a programmer and you are interested in C# or Zero-Touch formatting, you can reference <a href="https://github.com/DynamoDS/Dynamo/wiki/How-To-Create-Your-Own-Nodes">this page </a>on the Dynamo Wiki for a more in-depth review.</p>
<h3 id="custom-node-environment--create-your-first-custom-node"><a class="header" href="#custom-node-environment--create-your-first-custom-node">Custom Node Environment &amp; Create Your First Custom Node</a></h3>
<p>Let's jump into the custom node environment and make a simple node to calculate a percentage. The custom node environment is different from the Dynamo graph environment, but the interaction is fundamentally the same. With that said, let's create our first custom node!</p>
<p>To create a Custom Node from scratch, Launch Dynamo and select Custom Node, or type Ctrl + Shift + N from the canvas.</p>
<p><img src="6_custom_nodes_and_packages/6-1_custom-nodes/../images/6-1/1/customnodeintro-customnodeenvironment01.jpg" alt="" /></p>
<p>Assign a name, description, and category in the Custom Node Properties dialog.</p>
<p><img src="6_custom_nodes_and_packages/6-1_custom-nodes/../images/6-1/1/customnodeintro-customnodeenvironment02.jpg" alt="" /></p>
<blockquote>
<ol>
<li><strong>Name:</strong> Percentage</li>
<li><strong>Description</strong>: Calculate the percentage of one value in relation to another.</li>
<li><strong>Category:</strong> Math.Functions</li>
</ol>
</blockquote>
<p>This will open a canvas with a yellow background, indicating that you are working inside a custom node. In this canvas you have access to all of the core Dynamo nodes, as well as the Input and Output nodes, which label the data flowing into and out of the custom node. They can be found in Input&gt;Basic.</p>
<p><img src="6_custom_nodes_and_packages/6-1_custom-nodes/../images/6-1/1/customnodeintro-customnodeenvironment03.jpg" alt="" /></p>
<p><img src="6_custom_nodes_and_packages/6-1_custom-nodes/../images/6-1/1/customnodeintro-customnodeenvironment04.jpg" alt="" /></p>
<blockquote>
<ol>
<li><strong>Inputs:</strong> Input nodes create input ports on the custom node. The syntax for an input node is <em>input_name : datatype = default_value(optional).</em></li>
<li><strong>Outputs:</strong> Similar to inputs, these will create and name output ports on the custom node. Consider adding a <strong>Custom Comment</strong> to your Input and Output ports to hint at the Input and Output types. This is discussed in more detail in the <a href="6_custom_nodes_and_packages/6-1_custom-nodes/2-creating.html">Creating Custom Nodes section</a>.</li>
</ol>
</blockquote>
<p>You can save this custom node as a .dyf (as opposed to the standard .dyn) file and it will automatically be added to your session and future sessions. You will find the custom node in your library from the Add-ons section.</p>
<p><img src="6_custom_nodes_and_packages/6-1_custom-nodes/../images/6-1/1/customnodeintro-customnodeenvironment05.jpg" alt="" /></p>
<h3 id="moving-forward"><a class="header" href="#moving-forward">Moving Forward</a></h3>
<p>Now that we've created our first custom node, the next sections will dive deeper into custom node functionality and how to publish generic workflows. In the following section, we'll look at developing a custom node that transfers geometry from one surface to another.</p>
<div style="break-before: page; page-break-before: always;"></div><h1 id="creating-a-custom-node"><a class="header" href="#creating-a-custom-node">Creating a Custom Node</a></h1>
<p>Dynamo offers several different methods for creating custom nodes. You can build custom nodes from scratch, from an existing graph, or explicitly in C#. In this section we will cover building a custom node in the Dynamo UI from an existing graph. This method is ideal for cleaning up the workspace, as well as packaging a sequence of nodes to reuse elsewhere.</p>
<h2 id="exercise-custom-nodes-for-uv-mapping"><a class="header" href="#exercise-custom-nodes-for-uv-mapping">Exercise: Custom Nodes for UV Mapping</a></h2>
<h3 id="part-i-start-with-a-graph"><a class="header" href="#part-i-start-with-a-graph">Part I: Start with a Graph</a></h3>
<p>In the image below, we map a point from one surface to another using UV coordinates. We'll use this concept to create a panelized surface which references curves in the XY plane. We'll create quad panels for our panelization here, but using the same logic, we can create a wide variety of panels with UV mapping. This is a great opportunity for custom node development because we will be able to repeat a similar process more easily in this graph or in other Dynamo workflows.</p>
<p><img src="6_custom_nodes_and_packages/6-1_custom-nodes/../images/6-1/2/customnodeforuvmappingptI-01.jpg" alt="" /></p>
<blockquote>
<p>Download the example file by clicking on the link below.</p>
<p>A full list of example files can be found in the Appendix.</p>
</blockquote>
<p>{% file src=&quot;../datasets/6-1/2/UV-CustomNode.zip&quot; %}</p>
<p>Lets start by creating a graph that we want to nest into a custom node. In this example, we will create a graph that maps polygons from a base surface to a target surface, using UV coordinates. This UV mapping process is something we use frequently, making it a good candidate for a custom node. For more information on surfaces and UV space, refer to the <a href="6_custom_nodes_and_packages/6-1_custom-nodes/../../5_essential_nodes_and_concepts/5-2_geometry-for-computational-design/5-surfaces.html">Surface </a>page. The complete graph is <em>UVmapping_Custom-Node.dyn</em> from the .zip file downloaded above.</p>
<p><img src="6_custom_nodes_and_packages/6-1_custom-nodes/../images/6-1/2/customnodeforuvmappingptI-02.jpg" alt="" /></p>
<blockquote>
<ol>
<li><strong>Code Block:</strong> Use this line to create a range of 10 numbers between -45 and 45 <code>45..45..#10;</code></li>
<li><strong>Point.ByCoordinates:</strong> Connect the output of the <strong>Code Block</strong> to the x and y inputs and set the lacing to cross-reference. You should now have a grid of points.</li>
<li><strong>Plane.ByOriginNormal:</strong> Connect the <em>Point</em> output to the <em>origin</em> input to create a plane at each of the points. The default normal vector of (0,0,1) will be used.</li>
<li><strong>Rectangle.ByWidthLength:</strong> Connect the planes from the previous step into the <em>plane</em> input, and use a <strong>Code Block</strong> with a value of <em>10</em> to specify the width and length.</li>
</ol>
</blockquote>
<p>You should now see a grid of rectangles. Lets map these rectangles to a target surface using UV coordinates.</p>
<p><img src="6_custom_nodes_and_packages/6-1_custom-nodes/../images/6-1/2/customnodeforuvmappingptI-03.jpg" alt="" /></p>
<blockquote>
<ol>
<li><strong>Polygon.Points:</strong> Connect the <strong>Rectangle.ByWidthLength</strong> output from the previous step to the <em>polygon</em> input to extract the corner points of each rectangle. These are the points that we will map to the target surface.</li>
<li><strong>Rectangle.ByWidthLength:</strong> Use a <strong>Code Block</strong> with a value of <em>100</em> to specify the width and length of a rectangle. This will be the boundary of our base surface.</li>
<li><strong>Surface.ByPatch:</strong> Connect the <strong>Rectangle.ByWidthLength</strong> from the previous step to the <em>closedCurve</em> input to create a base surface.</li>
<li><strong>Surface.UVParameterAtPoint:</strong> Connect the <em>Point</em> output of the <strong>Polygon.Points</strong> node and the <em>Surface</em> output of the <strong>Surface.ByPatch</strong> node to return the UV parameter at each point.</li>
</ol>
</blockquote>
<p>Now that we have a base surface and a set of UV coordinates, we can import a target surface and map the points between surfaces.</p>
<p><img src="6_custom_nodes_and_packages/6-1_custom-nodes/../images/6-1/2/customnodeforuvmappingptI-04.jpg" alt="" /></p>
<blockquote>
<ol>
<li><strong>File Path:</strong> Select the file path of the surface you want to import. The file type should be .SAT. Click the <em>&quot;Browse...&quot;</em> button and navigate to the <em>UVmapping_srf.sat</em> file from the .zip file downloaded above.</li>
<li><strong>Geometry.ImportFromSAT:</strong> Connect the file path to import the surface. You should see the imported surface in the geometry preview.</li>
<li><strong>UV:</strong> Connect the UV parameter output to a <em>UV.U</em> and a <em>UV.V</em> node.</li>
<li><strong>Surface.PointAtParameter:</strong> Connect the imported surface as well as the u and v coordinates. You should now see a grid of 3D points on the target surface.</li>
</ol>
</blockquote>
<p>The final step is to use the 3D points to construct rectangular surface patches.</p>
<p><img src="6_custom_nodes_and_packages/6-1_custom-nodes/../images/6-1/2/customnodeforuvmappingptI-05.jpg" alt="" /></p>
<blockquote>
<ol>
<li><strong>PolyCurve.ByPoints:</strong> Connect the points on the surface to construct a polycurve through the points.</li>
<li><strong>Boolean:</strong> Add a <strong>Boolean</strong> to the workspace and connect it to the <em>connectLastToFirst</em> input and toggle to True to close the polycurves. You should now see rectangles mapped to the surface.</li>
<li><strong>Surface.ByPatch:</strong> Connect the polycurves to the <em>closedCurve</em> input to construct surface patches.</li>
</ol>
</blockquote>
<h3 id="part-ii-from-graph-to-custom-node"><a class="header" href="#part-ii-from-graph-to-custom-node">Part II: From Graph to Custom Node</a></h3>
<p>Now lets select the nodes that we want to nest into a Custom Node, thinking about what we want to be the inputs and outputs of our node. We want our Custom Node to be as flexible as possible, so it should be able to map any polygons, not just rectangles.</p>
<p>Select the following Nodes (beginning with Polygon.Points), right click on the workspace and select Create Custom Node.</p>
<p><img src="6_custom_nodes_and_packages/6-1_custom-nodes/../images/6-1/2/customnodeforuvmappingptII-01.jpg" alt="" /></p>
<p>In the Custom Node Properties dialog, assign a name, description, and category to the Custom Node.</p>
<p><img src="6_custom_nodes_and_packages/6-1_custom-nodes/../images/6-1/2/customnodeforuvmappingptII-02.jpg" alt="" /></p>
<blockquote>
<ol>
<li>Name: MapPolygonsToSurface</li>
<li>Description: Map polygon(s) from a base to target surface</li>
<li>Add-ons Category: Geometry.Curve</li>
</ol>
</blockquote>
<p>The Custom Node has considerably cleaned up the workspace. Notice that the inputs and outputs have been named based on the original nodes. Lets edit the Custom Node to make the names more descriptive.</p>
<p><img src="6_custom_nodes_and_packages/6-1_custom-nodes/../images/6-1/2/customnodeforuvmappingptII-03.jpg" alt="" /></p>
<p>Double click the Custom Node to edit it. This will open a workspace with a yellow background representing the inside of the node.</p>
<p><img src="6_custom_nodes_and_packages/6-1_custom-nodes/../images/6-1/2/customnodeforuvmappingptII-04.jpg" alt="" /></p>
<blockquote>
<ol>
<li><strong>Inputs:</strong> Change the input names to <em>baseSurface</em> and <em>targetSurface</em>.</li>
<li><strong>Outputs:</strong> Add an additional output for the mapped polygons.</li>
</ol>
</blockquote>
<p>Save the custom node and return to the home workspace. Notice the <strong>MapPolygonsToSurface</strong> node reflects the changes we just made.</p>
<p><img src="6_custom_nodes_and_packages/6-1_custom-nodes/../images/6-1/2/customnodeforuvmappingptII-05.jpg" alt="" /></p>
<p>We can also add to the robustness of the Custom Node by adding in <strong>Custom Comments</strong>. Comments can help to hint at the input and output types or explain the functionality of the node. Comments will appear when the user hovers over an input or output of a Custom Node.</p>
<p>Double click the Custom Node to edit it. This will re-open the yellow background workspace.</p>
<p><img src="6_custom_nodes_and_packages/6-1_custom-nodes/../images/6-1/2/customnodeforuvmappingptII-06.jpg" alt="" /></p>
<blockquote>
<ol>
<li>Begin editing the Input <strong>Code Block</strong>. To start a Comment, type &quot;//&quot; followed by the comment text. Type anything that may help to clarify the Node - Here we will describe the <em>targetSurface</em>.</li>
<li>Let's also set the default value for the <em>inputSurface</em> by setting the input type equal to a value. Here, we will set the default value to the original <strong>Surface.ByPatch</strong> set.</li>
</ol>
</blockquote>
<p>Comments can also be applied to the Outputs.</p>
<p><img src="6_custom_nodes_and_packages/6-1_custom-nodes/../images/6-1/2/customnodeforuvmappingptII-07.jpg" alt="" /></p>
<blockquote>
<p>Edit the text in the Output Code Block. Type &quot;//&quot; followed by the comment text. Here we will clarify the <em>Polygons</em> and the <em>surfacePatches</em> Outputs by adding a more in-depth description.</p>
</blockquote>
<p><img src="6_custom_nodes_and_packages/6-1_custom-nodes/../images/6-1/2/customnodeforuvmappingptII-08.jpg" alt="" /></p>
<blockquote>
<ol>
<li>Hover over the Custom Node Inputs to see the Comments.</li>
<li>With the default value set on our <em>inputSurface</em>, we can also run the definition without a surface input.</li>
</ol>
</blockquote>
<div style="break-before: page; page-break-before: always;"></div><h1 id="publishing-to-your-library"><a class="header" href="#publishing-to-your-library">Publishing to Your Library</a></h1>
<p>We've just created a custom node and applied it to a specific process in our Dynamo graph. And we like this node so much, we want to keep it in our Dynamo library to reference in other graphs. To do this, we'll publish the node locally. This is a similar process to publishing a package, which we'll walk through in more detail in the next chapter.</p>
<p>By publishing a node locally, the node will be accessible in your Dynamo library when you open a new session. Without publishing a node, a Dynamo graph which references a custom node must also have that custom node in its folder (or the custom node must be imported into Dynamo using <em>File&gt;Import Library</em>).</p>
<p>{% hint style=&quot;warning&quot; %}
Publishing Custom Node is only enabled in Dynamo for Revit and Dynamo for Civil 3d. Dynamo Sandbox does not have publishing functionality.
{% endhint %}</p>
<h2 id="exercise-publishing-a-custom-node-locally"><a class="header" href="#exercise-publishing-a-custom-node-locally">Exercise: Publishing a Custom Node Locally</a></h2>
<blockquote>
<p>Download the example file by clicking on the link below.</p>
<p>A full list of example files can be found in the Appendix.</p>
</blockquote>
<p>{% file src=&quot;../datasets/6-1/3/PointsToSurface.dyf&quot; %}</p>
<p>Let's move forward with the custom node that we created in the previous section. Once the PointsToSurface custom node is opened, we see the graph in the Dynamo Custom Node Editor. You can also open up a custom node by double clicking on it in the Dynamo Graph Editor.</p>
<p><img src="6_custom_nodes_and_packages/6-1_custom-nodes/../images/6-1/3/publishcustomnodelocally01.jpg" alt="" /></p>
<p>To Publish a custom node locally, simply right click on the canvas and select <em>&quot;Publish This Custom Node...&quot;</em></p>
<p><img src="6_custom_nodes_and_packages/6-1_custom-nodes/../images/6-1/3/publishcustomnodeexercise-02.jpg" alt="" /></p>
<p>Fill out the relevant information similar to the image above and select <em>&quot;Publish Locally&quot;.</em> Note that the Group field defines the main element accessible from the Dynamo menu.</p>
<p><img src="6_custom_nodes_and_packages/6-1_custom-nodes/../images/6-1/3/publishcustomnodeexercise-03.jpg" alt="" /></p>
<p>Choose a folder to house all of the custom nodes that you plan on publishing locally. Dynamo will check this folder each time it loads, so make sure the folder is in a permanent place. Navigate to this folder and choose <em>&quot;Select Folder&quot;.</em> Your Dynamo node is now published locally, and will remain in your Dynamo Toolbar each time you load the program!</p>
<p><img src="6_custom_nodes_and_packages/6-1_custom-nodes/../images/6-1/3/publishcustomnodeexercise-04.jpg" alt="" /></p>
<p>To check on the custom node folder location, go to <em>Dynamo &gt; Preferences &gt; Package Manager &gt; Node and Package Paths</em></p>
<p><img src="6_custom_nodes_and_packages/6-1_custom-nodes/../images/6-1/3/publishcustomnodeexercise-05.jpg" alt="" /></p>
<p>In this window we see a list of paths.</p>
<p><img src="6_custom_nodes_and_packages/6-1_custom-nodes/../images/6-1/3/publishcustomnodeexercise-06.jpg" alt="" /></p>
<blockquote>
<ol>
<li><em>Documents\DynamoCustomNodes...</em> refers to the location of custom nodes we've published locally.</li>
<li><em>AppData\Roaming\Dynamo...</em> refers to the default location of Dynamo Packages installed online.</li>
<li>You may want to move your local folder path down in the list order above (by selecting the folder path and clicking on the down arrow to the left of the path names). The top folder is the default path for package installs. So by keeping the default Dynamo package install path as the default folder, online packages will be separated from your locally published nodes.</li>
</ol>
</blockquote>
<p>We switched the order of the path names in order to have Dynamo's default path as the package install location.</p>
<p><img src="6_custom_nodes_and_packages/6-1_custom-nodes/../images/6-1/3/publishcustomnodeexercise-07.jpg" alt="" /></p>
<p>Navigating to this local folder, we can find the original custom node in the <em>&quot;.dyf&quot;</em> folder, which is the extension for a Dynamo Custom Node file. We can edit the file in this folder and the node will update in the UI. We can also add more nodes to the main <em>DynamoCustomNode</em> folder and Dynamo will add them to your library at restart!</p>
<p><img src="6_custom_nodes_and_packages/6-1_custom-nodes/../images/6-1/3/publishcustomnodeexercise-08.jpg" alt="" /></p>
<p>Dynamo will now load each time with &quot;PointsToSurface&quot; in the &quot;DynamoPrimer&quot; group of your Dynamo library.</p>
<p><img src="6_custom_nodes_and_packages/6-1_custom-nodes/../images/6-1/3/publishcustomnodeexercise-09.jpg" alt="" /></p>
<div style="break-before: page; page-break-before: always;"></div><h1 id="packages"><a class="header" href="#packages">Packages</a></h1>
<p>Once you have created a few Custom Nodes the very next step is to begin organizing and publishing them by way of Packages - a convenient way to store and share your nodes with the Dynamo Community.</p>
<p><img src="6_custom_nodes_and_packages/6-2_packages/../images/6-2/packagescover.jpg" alt="IMAGE" /></p>
<div style="break-before: page; page-break-before: always;"></div><h1 id="package-introduction"><a class="header" href="#package-introduction">Package Introduction</a></h1>
<p>In short, a Package is a collection of Custom Nodes. The Dynamo Package Manager is a portal for the community to download any package which has been published online. These toolsets are developed by third parties in order to extend Dynamo's core functionality, accessible to all, and ready to download at the click of the button.</p>
<p><img src="6_custom_nodes_and_packages/6-2_packages/../images/6-2/1/dpm.jpg" alt="Package Manager Site" /></p>
<p>An open-source project such as Dynamo thrives on this type of community involvement. With dedicated third-party developers, Dynamo is able to extend its reach to workflows across a range of industries. For this reason, the Dynamo team has made concerted efforts to streamline package development and publishing (which will be discussed in more detail in the following sections).</p>
<h3 id="installing-a-package"><a class="header" href="#installing-a-package">Installing a Package</a></h3>
<p>The easiest way to install a package is by using the Packages toolbar in your Dynamo interface. Let's jump right into it and install one now. In this quick example, we'll install a popular package for creating quad panels on a grid.</p>
<p>In Dynamo, go to <em>Packages&gt;Search For a Package...</em></p>
<p><img src="6_custom_nodes_and_packages/6-2_packages/../images/6-2/1/packageintroduction-installingapackage01.jpg" alt="" /></p>
<p>In the search bar, let's search for &quot;quads from rectangular grid&quot;. After a few moments, you should see all of the packages which match this search query. We want to select the first package with the matching name.</p>
<p>Click on nstall to add this package to your library. Done!</p>
<p><img src="6_custom_nodes_and_packages/6-2_packages/../images/6-2/1/packageintroduction-installingapackage02.jpg" alt="" /></p>
<p>Notice that we now have another group in our Dynamo library called &quot;buildz&quot;. This name refers to the developer of the package, and the custom node is placed in this group. We can begin to use this right away.</p>
<p><img src="6_custom_nodes_and_packages/6-2_packages/../images/6-2/1/packageintroduction-installingapackage03.jpg" alt="" /></p>
<p>Use <strong>Code Block</strong> to quickly define a rectangular grid, output the result to a <strong>Polygon.ByPoints</strong> Node, subsequently a <strong>Surface.ByPatch</strong> Node to view the list of rectangular panels you have just created.</p>
<p><img src="6_custom_nodes_and_packages/6-2_packages/../images/6-2/1/packageintroduction-installingapackage04.jpg" alt="" /></p>
<h3 id="installing-package-folder---dynamounfold"><a class="header" href="#installing-package-folder---dynamounfold">Installing Package Folder - DynamoUnfold</a></h3>
<p>The example above focuses on a package with one custom node, but you use the same process for downloading packages with several custom nodes and supporting data files. Let's demonstrate that now with a more comprehensive package: Dynamo Unfold.</p>
<p>As in the example above, begin by selecting <em>Packages&gt;Search for a Package...</em>.</p>
<p>This time, we'll search for <em>&quot;DynamoUnfold&quot;</em>, one word, minding the caps. When we see the packages, download by clicking on Install to add Dynamo Unfold to your Dynamo Library.</p>
<p><img src="6_custom_nodes_and_packages/6-2_packages/../images/6-2/1/packageintroduction-installingpackagefolder01.jpg" alt="" /></p>
<p>In the Dynamo Library, we have a <em>DynamoUnfold</em> Group with multiple categories and custom nodes.</p>
<p><img src="6_custom_nodes_and_packages/6-2_packages/../images/6-2/1/packageintroduction-installingpackagefolder02.jpg" alt="" /></p>
<p>Now, let's take a look at the package's file structure. First, select Dynamo &gt; Preferences</p>
<p><img src="6_custom_nodes_and_packages/6-2_packages/../images/6-2/1/packageintroduction-installingpackagefolder03.jpg" alt="" /></p>
<p>From the Preferences pop-up, open Package Manager &gt; next to DynamoUnfold, select the vertical dots menu <img src="6_custom_nodes_and_packages/6-2_packages/../images/6-2/1/packageintroduction-verticaldotsmenu.jpg" alt="" /> &gt; Show Root Directory to open root folder for this package.</p>
<p><img src="6_custom_nodes_and_packages/6-2_packages/../images/6-2/1/packageintroduction-installingpackagefolder04.jpg" alt="" /></p>
<p>This will take us to the package's root directory. Notice that we have 3 folders and a file.</p>
<p><img src="6_custom_nodes_and_packages/6-2_packages/../images/6-2/1/packageintroduction-installingpackagefolder05.jpg" alt="" /></p>
<blockquote>
<ol>
<li>The <em>bin</em> folder houses .dll files. This Dynamo package was developed using Zero-Touch, so the custom nodes are held in this folder.</li>
<li>The <em>dyf</em> folder houses the custom nodes. This package was not developed using Dynamo custom nodes, so this folder is empty for this package.</li>
<li>The extra folder houses all additional files, including our example files.</li>
<li>The pkg file is a basic text file defining the package settings. We can ignore this for now.</li>
</ol>
</blockquote>
<p>Opening the &quot;extra&quot; folder, we see a bunch of example files that were downloaded with the install. Not all packages have example files, but this is where you can find them if they are part of a package.</p>
<p>Let's open up &quot;SphereUnfold&quot;.</p>
<p><img src="6_custom_nodes_and_packages/6-2_packages/../images/6-2/1/rd2.jpg" alt="" /></p>
<p>After opening the file and hitting &quot;Run&quot; on the solver, we have an unfolded sphere! Example files like these are helpful for learning how to work with a new Dynamo package.</p>
<p><img src="6_custom_nodes_and_packages/6-2_packages/../images/6-2/1/packageintroduction-installingpackagefolder07.jpg" alt="" /></p>
<h3 id="dynamo-package-manager"><a class="header" href="#dynamo-package-manager">Dynamo Package Manager</a></h3>
<p>Another way to discover Dynamo packages is to explore the <a href="http://dynamopackages.com">Dynamo Package Manager</a> online. This is a good way to browse for packages, since the repository sorts packages in order of download count and popularity. Also, it's an easy way to gather information on recent updates for packages, as some Dynamo packages are subjected to versioning and dependencies of Dynamo builds.</p>
<p>By clicking on <em>&quot;Quads from Rectangular Grid&quot;</em> in the Dynamo Package Manager, you can see its descriptions, versions, the developer, and possible dependencies.</p>
<p><img src="6_custom_nodes_and_packages/6-2_packages/../images/6-2/1/dpm2.jpg" alt="" /></p>
<p>You can also download the package files from the Dynamo Package Manager, but doing so directly from Dynamo is a more seamless process.</p>
<h3 id="where-are-packages-files-stored-locally"><a class="header" href="#where-are-packages-files-stored-locally">Where are Packages Files Stored Locally?</a></h3>
<p>If you do download files from the Dynamo package manager, or if you would like to see where all of your package files are kept, click on Dynamo &gt; Package Manager &gt; Node and Package Paths, you can find your current root folder directory from here.</p>
<p><img src="6_custom_nodes_and_packages/6-2_packages/../images/6-2/1/packageintroduction-installingpackagefolder08.jpg" alt="" /></p>
<p>By default, packages are installed in a location similar to this folder path: <em>C:/Users/[username]/AppData/Roaming/Dynamo/[Dynamo Version]</em>.</p>
<h3 id="going-further-with-packages"><a class="header" href="#going-further-with-packages">Going Further with Packages</a></h3>
<p>The Dynamo community is constantly growing and evolving. By exploring the Dynamo Package Manager from time to time, you'll find some exciting new developments. In the following sections, we'll take a more in-depth look at packages, from the end-user perspective to authorship of your own Dynamo Package.</p>
<div style="break-before: page; page-break-before: always;"></div><h1 id="package-case-study---mesh-toolkit"><a class="header" href="#package-case-study---mesh-toolkit">Package Case Study - Mesh Toolkit</a></h1>
<p>The Dynamo Mesh Toolkit provides tools to import meshes from external file formats, create a mesh from Dynamo geometry objects, and manually build meshes by their vertices and indices. The library also provides tools to modify meshes, repair meshes, or extract horizontal slices for use in fabrication.</p>
<p><img src="6_custom_nodes_and_packages/6-2_packages/../images/6-2/2/meshToolkitcasestudy01.jpg" alt="" /></p>
<p>The Dynamo Mesh Toolkit is part of Autodesk's ongoing mesh research, and as such will continue to grow over the coming years. Expect new methods to appear on the toolkit frequently, and feel free to reach out to the Dynamo team with comments, bugs, and suggestions for new features.</p>
<h3 id="meshes-vs-solids"><a class="header" href="#meshes-vs-solids">Meshes vs. Solids</a></h3>
<p>The exercise below demonstrates some basic mesh operations using the Mesh Toolkit. In the exercise, we intersect a mesh with a series of planes, which can be computationally expensive using solids. Unlike a solid, a mesh has a set &quot;resolution&quot; and is not defined mathematically, but topologically, and we can define this resolution based on the task at hand. For more details on mesh to solid relationships, you can reference the<a href="6_custom_nodes_and_packages/6-2_packages/../../a-closer-look-at-dynamo-essential-nodes-and-concepts/5_geometry-for-computational-design/"> Geometry For Computation Design</a> chapter in this primer. For a more thorough examination of Mesh Toolkit, you can reference the <a href="https://github.com/DynamoDS/Dynamo/wiki/Dynamo-Mesh-Toolkit">Dynamo Wiki page.</a> Let's jump into the package in the exercise below.</p>
<h3 id="install-mesh-toolkit"><a class="header" href="#install-mesh-toolkit">Install Mesh Toolkit</a></h3>
<p>In Dynamo, go to <em>Packages &gt; Search for Packages...</em> in the top menu bar. In the search field, type <em>&quot;MeshToolkit&quot;</em>, all one word, minding the caps. Click Install to start the download. Simple as that!</p>
<p><img src="6_custom_nodes_and_packages/6-2_packages/../images/6-2/2/meshToolkitcasestudy-installpackage.jpg" alt="" /></p>
<h2 id="exercise-intersect-mesh"><a class="header" href="#exercise-intersect-mesh">Exercise: Intersect Mesh</a></h2>
<blockquote>
<p>Download the example file by clicking on the link below.</p>
<p>A full list of example files can be found in the Appendix.</p>
</blockquote>
<p>{% file src=&quot;../datasets/6-2/2/MeshToolkit.zip&quot; %}</p>
<p>In this example, we will look at the Intersect node in the mesh toolkit. We will import a mesh and intersect it with a series of input planes to create slices. This is the starting point for preparing the model for fabrication on a laser cutter, waterjet cutter, or CNC mill.</p>
<p>Begin by opening <em>Mesh-Toolkit_Intersect-Mesh.dyn in Dynamo.</em></p>
<p><img src="6_custom_nodes_and_packages/6-2_packages/../images/6-2/2/meshToolkitcasestudy-exercise01.jpg" alt="" /></p>
<blockquote>
<ol>
<li><strong>File Path:</strong> Locate the mesh file to import (<em>stanford_bunny_tri.obj</em>). Supported file types are .mix and .obj</li>
<li><strong>Mesh.ImportFile:</strong> Connect the file path to import the mesh</li>
</ol>
</blockquote>
<p><img src="6_custom_nodes_and_packages/6-2_packages/../images/6-2/2/meshToolkitcasestudy-exercise02.jpg" alt="" /></p>
<blockquote>
<ol>
<li><strong>Point.ByCoordinates:</strong> Construct a point  this will be the center of an arc.</li>
<li><strong>Arc.ByCenterPointRadiusAngle:</strong> Construct an arc around the point. This curve will be used to position a series of planes. __ The settings are as follow: __ <code>radius: 40, startAngle: -90, endAngle:0</code></li>
</ol>
</blockquote>
<p>Create a series of planes oriented along the arc.</p>
<p><img src="6_custom_nodes_and_packages/6-2_packages/../images/6-2/2/meshToolkitcasestudy-exercise03.jpg" alt="" /></p>
<blockquote>
<ol>
<li><strong>Code Block</strong>: Create 25 numbers between 0 and 1.</li>
<li><strong>Curve.PointAtParameter:</strong> Connect the arc to the <em>curve</em> input and the code block output to the <em>param</em> input to extract a series of points along the curve.</li>
<li><strong>Curve.TangentAtParameter:</strong> Connect the same inputs as the previous node.</li>
<li><strong>Plane.ByOriginNormal:</strong> Connect the points to the <em>origin</em> input and the vectors to the <em>normal</em> input to create a series of planes at each point.</li>
</ol>
</blockquote>
<p>Next, we will use these planes to intersect the mesh.</p>
<p><img src="6_custom_nodes_and_packages/6-2_packages/../images/6-2/2/meshToolkitcasestudy-exercise04.jpg" alt="" /></p>
<blockquote>
<ol>
<li><strong>Mesh.Intersect:</strong> Intersect the planes with the imported mesh, creating a series of polycurve contours. Right click on Node and set the lacing to longest</li>
<li><strong>PolyCurve.Curves:</strong> Break the polycurves into their curve fragments.</li>
<li><strong>Curve.EndPoint:</strong> Extract the end points of each curve.</li>
<li><strong>NurbsCurve.ByPoints:</strong> Use the points to construct a nurbs curve. Use a Boolean node set to <em>True</em> to close the curves.</li>
</ol>
</blockquote>
<p>Before we continue, switch off the preview for some of the Nodes such as: Mesh.ImportFile, Curve.EndPoint, Plane.ByOriginNormal &amp; Arc.ByCenterPointRadiusAngle to see the result better.</p>
<p><img src="6_custom_nodes_and_packages/6-2_packages/../images/6-2/2/meshToolkitcasestudy-exercise05.jpg" alt="" /></p>
<blockquote>
<ol>
<li><strong>Surface.ByPatch:</strong> Construct surface patches for each contour to create slices of the mesh.</li>
</ol>
</blockquote>
<p>Add a second set of slices for a waffle/egg-crate effect.</p>
<p><img src="6_custom_nodes_and_packages/6-2_packages/../images/6-2/2/meshToolkitcasestudy-exercise06.jpg" alt="" /></p>
<p>You may have noticed that the intersection operations calculate faster with a mesh vs. a comparable solid. Workflows such as the one demonstrated in this exercise lend themselves well to working with meshes.</p>
<div style="break-before: page; page-break-before: always;"></div><h1 id="developing-a-package"><a class="header" href="#developing-a-package">Developing a Package</a></h1>
<p>Dynamo offers a variety of ways to create a package for your personal use or for sharing with the Dynamo community. In the case study below, we'll walk through how a package is set up by deconstructing an existing one. This case study builds on lessons from the previous chapter, providing a set of custom nodes for mapping geometry, by UV coordinates, from one Dynamo surface to another.</p>
<h2 id="maptosurface-package"><a class="header" href="#maptosurface-package">MapToSurface Package</a></h2>
<p>We're going to work with a sample package which demonstrates the UV mapping of points from one surface to another. We've already built the fundamentals of the tool in the <a href="6_custom_nodes_and_packages/6-2_packages/../10_custom-nodes/10-2_creating.html">Creating a Custom Node</a> section of this primer. The files below demonstrate how we can take the concept of UV Mapping and develop a set of tools for a publishable library.</p>
<p>In this image, we map a point from one surface to another using UV coordinates. The package is based on this concept, but with more complex geometry.</p>
<p><img src="6_custom_nodes_and_packages/6-2_packages/../images/6-2/3/uvMap.jpg" alt="" /></p>
<h3 id="installing-the-package"><a class="header" href="#installing-the-package">Installing the Package</a></h3>
<p>In the previous chapter, we explored ways for panelizing a surface in Dynamo based on curves defined in the XY plane. This case study extends these concepts for more dimensions of geometry. We're going to install this package as built in order to demonstrate how it was developed. In the next section, we'll demonstrate how this package was published.</p>
<p>In Dynamo, click _Packages&gt;Search for a Package... and s_earch for the package &quot;MapToSurface&quot; (all one word). Click Install to start the download and add the package to your library.</p>
<p><img src="6_custom_nodes_and_packages/6-2_packages/../images/6-2/3/developpackage-installpackage01.jpg" alt="" /></p>
<p>After installing, the custom nodes should be available under the Add-ons &gt; Dynamo Primer section.</p>
<p><img src="6_custom_nodes_and_packages/6-2_packages/../images/6-2/3/developpackage-installpackage02(1)(1).jpg" alt="" /></p>
<p>With the package now installed, let's walk through how it's set up.</p>
<h3 id="custom-nodes-1"><a class="header" href="#custom-nodes-1">Custom Nodes</a></h3>
<p>The package we're creating uses five custom nodes that we've built for reference. Let's walk through what each node does below. Some custom nodes build off of other custom nodes, and the graphs have a layout for other users to understand in a straightforward manner.</p>
<p>This is a simple package with five custom nodes. In the steps below, we'll briefly talk about each custom node's setup.</p>
<p><img src="6_custom_nodes_and_packages/6-2_packages/../images/6-2/3/developpackage-customnodes01(1)(1).jpg" alt="" /></p>
<h4 id="pointstosurface"><a class="header" href="#pointstosurface"><strong>PointsToSurface</strong></a></h4>
<p>This is a basic custom node, and one from which all of the other mapping nodes are based. Simply put, the node maps a point from a source surface UV coordinate to the location of the target surface UV coordinate. And since points are the most primitive geometry, from which more complex geometry is built, we can use this logic to map 2D, and even 3D geometry from one surface to another.</p>
<p><img src="6_custom_nodes_and_packages/6-2_packages/../images/6-2/3/developpackage-pointToSurface.jpg" alt="" /></p>
<h4 id="polygonstosurface"><a class="header" href="#polygonstosurface"><strong>PolygonsToSurface</strong></a></h4>
<p>The logic of extending mapped points from 1D geometry to 2D geometry is demonstrated simply with polygons here. Notice that we have nested the <em>&quot;PointsToSurface&quot;</em> node into this custom node. This way we can map the points of each polygon to the surface, and then regenerate the polygon from those mapped points. By maintaining the proper data structure (a list of lists of points), we're able to keep the polygons separate after they're reduced to a set of points.</p>
<p><img src="6_custom_nodes_and_packages/6-2_packages/../images/6-2/3/developpackage-polygonsToSurface.jpg" alt="" /></p>
<h4 id="nurbscrvtosurface"><a class="header" href="#nurbscrvtosurface"><strong>NurbsCrvtoSurface</strong></a></h4>
<p>The same logic applies here as in the <em>&quot;PolygonsToSurface&quot;</em> node. But instead of mapping polygonal points, we're mapping control points of a nurbs curve.</p>
<p><img src="6_custom_nodes_and_packages/6-2_packages/../images/6-2/3/developpackage-nurbsCrvtoSurface.jpg" alt="" /></p>
<p><strong>OffsetPointsToSurface</strong></p>
<p>This node gets a little more complex, but the concept is simple: like the <em>&quot;PointsToSurface&quot;</em> node, this node maps points from one surface to another. However, it also considers points which are not on the original source surface, gets their distance to the closest UV parameter, and maps this distance to the target surface normal at the corresponding UV coordinate. This will make more sense when looking at the example files.</p>
<p><img src="6_custom_nodes_and_packages/6-2_packages/../images/6-2/3/developpackage-OffsetPointsToSurface.jpg" alt="" /></p>
<h4 id="samplesrf"><a class="header" href="#samplesrf"><strong>SampleSrf</strong></a></h4>
<p>This is a simple node which creates a parametric surface to map from the source grid to an undulating surface in the example files.</p>
<p><img src="6_custom_nodes_and_packages/6-2_packages/../images/6-2/3/developpackage-sampleSrf.jpg" alt="" /></p>
<h3 id="example-files"><a class="header" href="#example-files">Example Files</a></h3>
<p>The example files can be found in the package's root folder. Click Dynamo &gt; Preferences &gt; Package Manager</p>
<p>Next to MapToSurface, click verticle dots menu &gt; Show Root Directory</p>
<p><img src="6_custom_nodes_and_packages/6-2_packages/../images/6-2/3/developpackage-examplefiles01.jpg" alt="" /></p>
<p>Next, open the <em>&quot;extra&quot;</em> folder, which houses all of the files in the package which are not custom nodes. This is where examples files (if they exist) are stored for Dynamo packages. The screenshots below discuss the concepts demonstrated in each example file.</p>
<h4 id="01-panelingwithpolygons"><a class="header" href="#01-panelingwithpolygons"><strong>01-PanelingWithPolygons</strong></a></h4>
<p>This example file demonstrates how <em>&quot;PointsToSurface&quot;</em> may be used to panelize a surface based on a grid of rectangles. This should look familiar, as we demonstrated a similar workflow in the <a href="6_custom_nodes_and_packages/6-2_packages/../10_custom-nodes/10-2_creating.html">previous chapter</a>.</p>
<p><img src="6_custom_nodes_and_packages/6-2_packages/../images/6-2/3/developpackage-samplefile01.jpg" alt="" /></p>
<h4 id="02-panelingwithpolygons-ii"><a class="header" href="#02-panelingwithpolygons-ii"><strong>02-PanelingWithPolygons-II</strong></a></h4>
<p>Using a similar workflow, this exercise file shows a setup for mapping circles (or polygons representing circles) from one surface to another. This uses the <em>&quot;PolygonsToSurface&quot;</em> node.</p>
<p><img src="6_custom_nodes_and_packages/6-2_packages/../images/6-2/3/developpackage-samplefile02.jpg" alt="" /></p>
<h4 id="03-nurbscrvsandsurface"><a class="header" href="#03-nurbscrvsandsurface"><strong>03-NurbsCrvsAndSurface</strong></a></h4>
<p>This example file adds some complexity by working with the &quot;NurbsCrvToSurface&quot; node. The target surface is offset a given distance and the nurbs curve is mapped to the original target surface and the offset surface. From there, the two mapped curves are lofted to create a surface, which is then thickened. This resulting solid has an undulation that is representative of the target surface normals.</p>
<p><img src="6_custom_nodes_and_packages/6-2_packages/../images/6-2/3/developpackage-samplefile03.jpg" alt="" /></p>
<h4 id="04-pleatedpolysurface-offsetpoints"><a class="header" href="#04-pleatedpolysurface-offsetpoints"><strong>04-PleatedPolysurface-OffsetPoints</strong></a></h4>
<p>This example file demonstrates how to map a pleated polysurface from a source surface to a target surface. The source and target surface are a rectangular surface spanning the grid and a revolved surface, respectively.</p>
<p><img src="6_custom_nodes_and_packages/6-2_packages/../images/6-2/3/developpackage-samplefile04a.jpg" alt="" /></p>
<p>The source polysurface mapped from the source surface to the target surface.</p>
<p><img src="6_custom_nodes_and_packages/6-2_packages/../images/6-2/3/developpackage-samplefile04b.jpg" alt="" /></p>
<h4 id="05-svg-import"><a class="header" href="#05-svg-import"><strong>05-SVG-Import</strong></a></h4>
<p>Since the custom nodes are able to map different types of curves, this last file references an SVG file exported from Illustrator and maps the imported curves to a target surface.</p>
<p><img src="6_custom_nodes_and_packages/6-2_packages/../images/6-2/3/developpackage-samplefile05a.jpg" alt="" /></p>
<p>By parsing through the syntax of a .svg file, curves are translated from .xml format to Dynamo polycurves.</p>
<p><img src="6_custom_nodes_and_packages/6-2_packages/../images/6-2/3/developpackage-samplefile05b.jpg" alt="" /></p>
<p>The imported curves are mapped to a target surface. This allows us to explicitly (point-and-click) design a panelization in Illustrator, import into Dynamo, and apply to a target surface.</p>
<p><img src="6_custom_nodes_and_packages/6-2_packages/../images/6-2/3/developpackage-samplefile05c.jpg" alt="" /></p>
<div style="break-before: page; page-break-before: always;"></div><h1 id="publishing-a-package"><a class="header" href="#publishing-a-package">Publishing a Package</a></h1>
<p>In the previous sections, we dove into the details of how our <em>MapToSurface</em> package is set up with custom nodes and example files. But how do we publish a package that has been developed locally? This case study demonstrates how to publish a package from a set of files in a local folder.</p>
<p><img src="6_custom_nodes_and_packages/6-2_packages/../images/6-2/4/publishapackage-customnodes01.jpg" alt="" /></p>
<p>There are many ways to publish a package. Below is the process that we advise: <strong>publish locally, develop locally and then publish online</strong>. We'll start with a folder containing all of the files in the package.</p>
<h3 id="uninstalling-a-package"><a class="header" href="#uninstalling-a-package">Uninstalling a Package</a></h3>
<p>Before we jump into publishing the MapToSurface package, if you installed the package from the previous lesson, uninstall it so that you're not working with identical packages.</p>
<p>Begin by going to Dynamo &gt; Preferences &gt; Package Manager &gt; next to MapToSurface click on vertical dots menu &gt; delete</p>
<p><img src="6_custom_nodes_and_packages/6-2_packages/../images/6-2/4/publishapackage-deletepackage.jpg" alt="" /></p>
<p>Then restart Dynamo. When reopening, when you check the <em>&quot;Manage Packages&quot;</em> window, the <em>MapToSurface</em> should no longer be there. Now we're ready to start from the beginning!</p>
<h3 id="publishing-a-package-locally"><a class="header" href="#publishing-a-package-locally">Publishing a Package Locally</a></h3>
<p>{% hint style=&quot;warning&quot; %}
Dynamo package publication is only enabled in Dynamo for Revit and Dynamo for Civil 3d. Dynamo Sandbox does not have publishing functionality.
{% endhint %}</p>
<blockquote>
<p>Download the example file by clicking on the link below.</p>
<p>A full list of example files can be found in the Appendix.</p>
</blockquote>
<p>{% file src=&quot;../datasets/6-2/4/MapToSurface.zip&quot; %}</p>
<p>This is the first submission for our package, and we've placed all of the example files and custom nodes into one folder. With this folder prepared, we're ready to upload to the Dynamo Package Manager.</p>
<p><img src="6_custom_nodes_and_packages/6-2_packages/../images/6-2/4/publishapackage-publishlocally01.jpg" alt="" /></p>
<blockquote>
<ol>
<li>This folder contains five custom nodes (.dyf).</li>
<li>This folder also contains five example files (.dyn) and one imported vector file (.svg). These files will serve as introductory exercises to show the user how to work with the custom nodes.</li>
</ol>
</blockquote>
<p>In Dynamo, begin by clicking <em>Packages&gt;Publish New Package...</em></p>
<p><img src="6_custom_nodes_and_packages/6-2_packages/../images/6-2/4/publishapackage-publishlocally02.jpg" alt="" /></p>
<p>In the <em>&quot;Publish a Dynamo Package&quot;</em> window, filled out the relevant forms on the left of the window.</p>
<p><img src="6_custom_nodes_and_packages/6-2_packages/../images/6-2/4/publishapackage-publishlocally03.jpg" alt="" /></p>
<blockquote>
<ol>
<li>By clicking <em>&quot;Add File&quot;</em>, we've also added the files from the folder structure on the right side of the screen (to add files which are not .dyf files, be sure to change your file type in the browser window to <strong>&quot;All Files(</strong><em><strong>.</strong></em><strong>)&quot;</strong>. Notice that we've added every file, custom node (.dyf) or example file (.dyn), indiscriminately. Dynamo will categories these items when we publish the package.</li>
<li>The &quot;Group&quot; field defines which group to find the custom nodes in the Dynamo UI.</li>
<li>Publish by clicking &quot;Publish Locally&quot;. If you're following along, be certain to click <em>&quot;Publish Locally&quot;</em> and <strong>not</strong> <em>&quot;Publish Online&quot;</em>; we don't want a bunch of duplicate packages on the Package Manager.</li>
</ol>
</blockquote>
<p>After publishing, the custom nodes should be available under the &quot;DynamoPrimer&quot; group or your Dynamo Library.</p>
<p><img src="6_custom_nodes_and_packages/6-2_packages/../images/6-2/4/publishapackage-publishlocally04.jpg" alt="" /></p>
<p>Now let's look at the root directory to see how Dynamo has formatted the package we just created. Do this by clicking Dynamo &gt; Preferences &gt; Package Manager &gt; next to MapToSurface click on the vertical dots menu &gt; select Show Root Directory</p>
<p><img src="6_custom_nodes_and_packages/6-2_packages/../images/6-2/4/publishapackage-publishlocally05.jpg" alt="" /></p>
<p>Notice that the root directory is in the local location of your package (remember, we published the package &quot;locally&quot;). Dynamo is currently referencing this folder to read custom nodes. It's therefore important to locally publish the directory to a permanent folder location (ie: not your desktop). Here is the Dynamo package folder breakdown.</p>
<p><img src="6_custom_nodes_and_packages/6-2_packages/../images/6-2/4/publishapackage-publishlocally06.jpg" alt="" /></p>
<blockquote>
<ol>
<li>The <em>bin</em> folder houses .dll files created with C# or Zero-Touch libraries. We don't have any for this package so this folder is blank for this example.</li>
<li>The <em>dyf</em> folder houses the custom nodes. Opening this will reveal all of the custom nodes (.dyf files) for this package.</li>
<li>The extra folder houses all additional files. These files are likely to be Dynamo Files (.dyn) or any additional files required (.svg, .xls, .jpeg, .sat, etc.).</li>
<li>The pkg file is a basic text file defining the package settings. This is automated in Dynamo, but can be edited if you want to get into the details.</li>
</ol>
</blockquote>
<h3 id="publishing-a-package-online"><a class="header" href="#publishing-a-package-online">Publishing a Package Online</a></h3>
<p>{% hint style=&quot;warning&quot; %}
Note: please do not follow along with this step unless you are actually publishing a package of your own!
{% endhint %}</p>
<p><img src="6_custom_nodes_and_packages/6-2_packages/../images/6-2/4/publishapackage-publishonline01.jpg" alt="" /></p>
<blockquote>
<ol>
<li>When you're ready to publish, in the Preferences &gt; Package Manager window, select the button the right of MapToSurface and choose <em>Publish...</em></li>
<li>If you're updating a package that has already been published, choose &quot;Publish Version&quot; and Dynamo will update your package online based on the new files in that package's root directory. Simple as that!</li>
</ol>
</blockquote>
<h3 id="publish-version"><a class="header" href="#publish-version">Publish Version...</a></h3>
<p>When you update the files in your published package's root folder, you can publish a new version of the package by selecting <em>&quot;Publish Version...&quot;</em> in the <em>Manage Packages</em> window. This is a seamless way to make necessary updates to your content and share with the community. <em>Publish Version</em> will only work if you're the maintainer of the package.</p>
<div style="break-before: page; page-break-before: always;"></div><h1 id="zero-touch-importing"><a class="header" href="#zero-touch-importing">Zero-Touch Importing</a></h1>
<h3 id="what-is-zero-touch"><a class="header" href="#what-is-zero-touch">What is Zero-Touch?</a></h3>
<p>Zero-Touch Importing refers to a simple point-and-click method for importing C# libraries. Dynamo will read the public methods of a <em>.dll</em> file and convert them to Dynamo nodes. You can use Zero-Touch to develop your own custom nodes and packages, and to import external libraries into the Dynamo environment.</p>
<p><img src="6_custom_nodes_and_packages/6-2_packages/../images/6-2/5/zero-touchimporting01.jpg" alt="" /></p>
<blockquote>
<ol>
<li>.dll files</li>
<li>Dynamo Nodes</li>
</ol>
</blockquote>
<p>With Zero-Touch, you can actually import a library which was not necessarily developed for Dynamo and create a suite of new nodes. The current Zero-Touch functionality demonstrates the cross-platform mentality of the Dynamo Project.</p>
<p>This section demonstrates how to use Zero-Touch to import a third party library. For information on developing your own Zero-Touch Library, reference the <a href="https://github.com/DynamoDS/Dynamo/wiki/Zero-Touch-Plugin-Development">Dynamo wiki page</a>.</p>
<h3 id="zero-touch-packages"><a class="header" href="#zero-touch-packages">Zero-Touch Packages</a></h3>
<p>Zero-touch packages are a good complement to user-defined custom nodes. A few packages which use C# libraries are listed in the table below. For more detailed information on packages, visit the <a href="6_custom_nodes_and_packages/6-2_packages/../../a_appendix/a-3_packages.html">Packages section </a>in the Appendix.</p>
<div class="table-wrapper"><table><thead><tr><th><strong>Logo/Image</strong></th><th><strong>Name</strong></th></tr></thead><tbody>
<tr><td><img src="6_custom_nodes_and_packages/6-2_packages/../images/6-2/5/meshToolkitcasestudy01%20(1).jpg" alt="" /></td><td><a href="https://github.com/DynamoDS/Dynamo/wiki/Dynamo-Mesh-Toolkit">Mesh Toolkit</a></td></tr>
<tr><td><img src="6_custom_nodes_and_packages/6-2_packages/../images/6-2/5/packageintroduction-installingpackagefolder07%20(1).jpg" alt="" /></td><td><a href="http://dynamobim.com/dynamounfold/">Dynamo Unfold</a></td></tr>
<tr><td><img src="6_custom_nodes_and_packages/6-2_packages/../images/6-2/5/rhynamo.jpg" alt="" /></td><td><a href="http://www.case-inc.com/blog/what-is-rhynamo">Rhynamo</a></td></tr>
<tr><td><img src="6_custom_nodes_and_packages/6-2_packages/../images/6-2/5/optimo.jpg" alt="" /></td><td><a href="https://github.com/BPOpt/Optimo">Optimo</a></td></tr>
</tbody></table>
</div>
<h2 id="case-study---importing-aforge"><a class="header" href="#case-study---importing-aforge">Case Study - Importing AForge</a></h2>
<p>In this case study, we'll show how to import the <a href="http://www.aforgenet.com">AForge</a> external <em>.dll</em> library. AForge is a robust library which offers a range of functionality from image processing to artificial intelligence. We'll reference the imaging class in AForge to do a few image processing exercises below.</p>
<p>Let's begin by downloading AForge. On the <a href="http://www.aforgenet.com/framework/downloads.html">AForge download page</a>, select <em>[Download Installer]</em> and install after download has completed.</p>
<p>In Dynamo, create a new file and select <em>File &gt; Import Library...</em></p>
<p><img src="6_custom_nodes_and_packages/6-2_packages/../images/6-2/5/casestudyaforge01.jpg" alt="" /></p>
<p>Next, locate the dll file.</p>
<p><img src="6_custom_nodes_and_packages/6-2_packages/../images/6-2/5/casestudyaforge02.jpg" alt="" /></p>
<blockquote>
<ol>
<li>In the pop-up window, navigate to the release folder in your AForge install. This will likely be in a folder similar to this one: <em>C:\Program Files (x86)\AForge.NET\Framework\Release</em>.</li>
<li><strong>AForge.Imaging.dll:</strong> We only want to use this one file from the AForge library for this case study. Select this <em>.dll</em> and hit <em>&quot;Open&quot;.</em></li>
</ol>
</blockquote>
<p>Back in Dynamo, you should see an <strong>AForge</strong> group of nodes added to your Library. We now have access to the AForge imaging library from our visual program!</p>
<p><img src="6_custom_nodes_and_packages/6-2_packages/../images/6-2/5/casestudyaforge03.jpg" alt="" /></p>
<h3 id="exercise-1---edge-detection"><a class="header" href="#exercise-1---edge-detection">Exercise 1 - Edge Detection</a></h3>
<blockquote>
<p>Download the example file by clicking on the link below.</p>
<p>A full list of example files can be found in the Appendix.</p>
</blockquote>
<p>{% file src=&quot;../datasets/6-2/5/ZeroTouchImages.zip&quot; %}</p>
<p>Now that the library is imported, we'll start off simple with this first exercise (<em>01-EdgeDetection.dyn</em>). We'll do some basic image processing on a sample image to show how AForge image filters. We'll use the <em>&quot;Watch Image&quot;</em> node to show our results and apply filters in Dynamo similar to those in Photoshop</p>
<p>To import an image, add a <strong>File Path</strong> node to the canvas and select &quot;soapbubbles.jpg&quot; from the exercise folder (photo cred: <a href="https://www.flickr.com/photos/wwworks/667298782">flickr</a>).</p>
<p><img src="6_custom_nodes_and_packages/6-2_packages/../images/6-2/5/casestudyaforgeexercise1-01.jpg" alt="" /></p>
<p>The File Path node simply provides a String of the path to the image we've selected. Next, we need to convert it into a usable image file in Dynamo.</p>
<p><img src="6_custom_nodes_and_packages/6-2_packages/../images/6-2/5/casestudyaforgeexercise1-02.jpg" alt="" /></p>
<blockquote>
<ol>
<li>Use <strong>File From Path</strong> to convert the file path item into an image in the Dynamo environment.</li>
<li>Connect the <strong>File Path</strong> node to the <strong>File.FromPath</strong> node.</li>
<li>To convert this File into an Image, we'll use the <strong>Image.ReadFromFile</strong> node.</li>
<li>Last, let's see the result! Drop a <strong>Watch Image</strong> node onto the canvas and connect to <strong>Image.ReadFromFile</strong>. We haven't used AForge yet, but we've successfully imported an image into Dynamo.</li>
</ol>
</blockquote>
<p>Under AForge.Imaging.AForge.Imaging.Filters (in the navigation menu), you'll notice that there is a wide array of filters available. We're going to use one of these filters now to desaturate an image based on threshold values.</p>
<p><img src="6_custom_nodes_and_packages/6-2_packages/../images/6-2/5/casestudyaforgeexercise1-03.jpg" alt="" /></p>
<blockquote>
<ol>
<li>Drop three sliders onto the canvas, change their ranges to be from 0 to 1 and their step values to be 0.01.</li>
<li>Add the <strong>Grayscale.Grayscale</strong> node to the canvas. This is an AForge filter which applies a grayscale filter to an image. Connect the three sliders from step 1 into cr, cg, and cb. Change the top and bottom sliders to have a value of 1 and the middle slider to have a value of 0.</li>
<li>In order to apply the Grayscale filter, we need an action to perform on our image. For this, we use <strong>BaseFilter.Apply</strong>. Connect the image into the image input and <strong>Grayscale.Grayscale</strong> into the baseFilter input.</li>
<li>Plugging into a <strong>Watch Image</strong> node, we get a desaturated image.</li>
</ol>
</blockquote>
<p>We can have control over how to desaturate this image based on threshold values for red, green, and blue. These are defined by the inputs to the <strong>Grayscale.Grayscale</strong> node. Notice that the image looks pretty dim - this is because the green value is set to 0 from our slider.</p>
<p><img src="6_custom_nodes_and_packages/6-2_packages/../images/6-2/5/casestudyaforgeexercise1-04.jpg" alt="" /></p>
<blockquote>
<ol>
<li>Change the top and bottom sliders to have a value of 0 and the middle slider to have a value of 1. This way we get a more legible desaturated image.</li>
</ol>
</blockquote>
<p>Let's use the desaturated image, and apply another filter on top of it. The desaturated image has some contrast, so we we're going to test some edge detection.</p>
<p><img src="6_custom_nodes_and_packages/6-2_packages/../images/6-2/5/casestudyaforgeexercise1-05.jpg" alt="" /></p>
<blockquote>
<ol>
<li>Add a <strong>SobelEdgeDetector.SobelEdgeDetector</strong> node to the canvas.</li>
<li>Connect this to a <strong>BaseUsingCopyPartialFilter.Apply</strong> and connect the desaturated image to the image input of this node.</li>
<li>The Sobel Edge Detector has highlighted the edges in a new image.</li>
</ol>
</blockquote>
<p>Zooming in, the edge detector has called out the outlines of the bubbles with pixels. The AForge library has tools to take results like this and create Dynamo geometry. We'll explore that in the next exercise.</p>
<p><img src="6_custom_nodes_and_packages/6-2_packages/../images/6-2/5/casestudyaforgeexercise1-06.jpg" alt="" /></p>
<h3 id="exercise-2---rectangle-creation"><a class="header" href="#exercise-2---rectangle-creation">Exercise 2 - Rectangle Creation</a></h3>
<p>Now that we're introduced to some basic image processing, let's use an image to drive Dynamo geometry! On an elementary level, in this exercise we're aiming to do a <em>&quot;Live Trace&quot;</em> of an image using AForge and Dynamo. We're going to keep it simple and extract rectangles from a reference image, but there are tools available in AForge for more complex operations. We'll be working with <em>02-RectangleCreation.dyn</em> from the downloaded exercise files.</p>
<p><img src="6_custom_nodes_and_packages/6-2_packages/../images/6-2/5/casestudyaforgeexercise2-01.jpg" alt="" /></p>
<blockquote>
<ol>
<li>With the File Path node, navigate to grid.jpg in the exercise folder.</li>
<li>Connect the remaining series of nodes above to reveal a course parametric grid.</li>
</ol>
</blockquote>
<p>In this next step, we want to reference the white squares in the image and convert them to actual Dynamo geometry. AForge has a lot of powerful Computer Vision tools, and here we're going to use a particularly important one for the library called <a href="http://www.aforgenet.com/framework/docs/html/d7d5c028-7a23-e27d-ffd0-5df57cbd31a6.htm">BlobCounter</a>.</p>
<p><img src="6_custom_nodes_and_packages/6-2_packages/../images/6-2/5/casestudyaforgeexercise2-02.jpg" alt="" /></p>
<blockquote>
<ol>
<li>Add a BlobCounter to the canvas, then we need a way to process the image (similar to the <strong>BaseFilter.Apply</strong> tool in the previous exercise).</li>
</ol>
</blockquote>
<p>Unfortunately the &quot;Process Image&quot; node is not immediately visible in the Dynamo library. This is because the function may not be visible in the AForge source code. In order to fix this, we'll need to find a work-around.</p>
<p><img src="6_custom_nodes_and_packages/6-2_packages/../images/6-2/5/casestudyaforgeexercise2-03.jpg" alt="" /></p>
<blockquote>
<ol>
<li>Add a Python node to the canvas and add the following code to the Python node. This code imports the AForge library and then processes the imported image.</li>
</ol>
</blockquote>
<pre><code>import sys
import clr
clr.AddReference('AForge.Imaging')
from AForge.Imaging import *

bc= BlobCounter()
bc.ProcessImage(IN[0])
OUT=bc
</code></pre>
<p>Connecting the image output to the Python node input, we get an AForge.Imaging.BlobCounter result from the Python node.</p>
<p><img src="6_custom_nodes_and_packages/6-2_packages/../images/6-2/5/casestudyaforgeexercise2-04.jpg" alt="" /></p>
<p>The next steps will do some tricks that demonstrate familiarity with the <a href="http://www.aforgenet.com/framework/docs/html/d087503e-77da-dc47-0e33-788275035a90.htm">AForge Imaging API</a>. It's not necessary to learn all of this for Dynamo work. This is more of a demonstration of working with external libraries within the flexibility of the Dynamo environment.</p>
<p><img src="6_custom_nodes_and_packages/6-2_packages/../images/6-2/5/casestudyaforgeexercise2-05.jpg" alt="" /></p>
<blockquote>
<ol>
<li>Connect the output of the Python script to BlobCounterBase.GetObjectRectangles. This reads objects in an image, based on a threshold value, and extracts quantified rectangles from the pixel space.</li>
</ol>
</blockquote>
<p><img src="6_custom_nodes_and_packages/6-2_packages/../images/6-2/5/casestudyaforgeexercise2-06.jpg" alt="" /></p>
<blockquote>
<ol>
<li>Adding another Python node to the canvas, connect to the GetObjectRectangles, and input the code below. This will create an organized list of Dynamo objects.</li>
</ol>
</blockquote>
<pre><code>OUT = []
for rec in IN[0]:
	subOUT=[]
	subOUT.append(rec.X)
	subOUT.append(rec.Y)
	subOUT.append(rec.Width)
	subOUT.append(rec.Height)
	OUT.append(subOUT)
</code></pre>
<p><img src="6_custom_nodes_and_packages/6-2_packages/../images/6-2/5/casestudyaforgeexercise2-07.jpg" alt="" /></p>
<blockquote>
<ol>
<li>Transpose the output of the Python node from the previous step. This creates 4 lists, each representing X,Y, Width, and Height for each rectangle.</li>
<li>Using Code Block, we organize the data into a structure that accommodates the Rectangle.ByCornerPoints node (code below).</li>
</ol>
</blockquote>
<pre><code>recData;
x0=List.GetItemAtIndex(recData,0);
y0=List.GetItemAtIndex(recData,1);
width=List.GetItemAtIndex(recData,2);
height=List.GetItemAtIndex(recData,3);
x1=x0+width;y1=y0+height;
p0=Autodesk.Point.ByCoordinates(x0,y0);
p1=Autodesk.Point.ByCoordinates(x0,y1);
p2=Autodesk.Point.ByCoordinates(x1,y1);
p3=Autodesk.Point.ByCoordinates(x1,y0);
</code></pre>
<p>We have an array of rectangles representing the white squares in the image. Through programming, we've done something (roughly) similar to a live trace in Illustrator!</p>
<p>We still need some cleanup, however. Zooming in, we can see that we have a bunch of small, unwanted rectangles.</p>
<p><img src="6_custom_nodes_and_packages/6-2_packages/../images/6-2/5/casestudyaforgeexercise2-08.jpg" alt="" /></p>
<p>Next, we are going to write codes to get rid of unwanted rectangles.</p>
<p><img src="6_custom_nodes_and_packages/6-2_packages/../images/6-2/5/casestudyaforgeexercise2-09.jpg" alt="" /></p>
<blockquote>
<ol>
<li>Insert a Python node in between the GetObjectRectangles node and another Python node. The node's code is below, and removes all rectangles which are below a given size.</li>
</ol>
</blockquote>
<pre><code>rectangles=IN[0]
OUT=[]
for rec in rectangles:
 if rec.Width&gt;8 and rec.Height&gt;8:
  OUT.append(rec)
</code></pre>
<p>With the superfluous rectangles gone, just for kicks, let's create a surface from these rectangles and extrude them by a distance based on their areas.</p>
<p><img src="6_custom_nodes_and_packages/6-2_packages/../images/6-2/5/casestudyaforgeexercise2-10.jpg" alt="" /></p>
<p>Last, change the both_sides input to false and we get an extrusion in one direction. Dip this baby in resin and you've got yourself one super nerdy table.</p>
<p><img src="6_custom_nodes_and_packages/6-2_packages/../images/6-2/5/casestudyaforgeexercise2-11.jpg" alt="" /></p>
<p>These are basic examples, but the concepts outlined here are transferable to exciting real-world applications. Computer vision can be used for a whole host of processes. To name a few: barcode readers, perspective matching, <a href="https://www.youtube.com/watch?v=XSR0Xady02o">projection mapping</a>, and <a href="http://aforgenet.com/aforge/articles/gratf_ar/">augmented reality</a>. For more advanced topics with AForge related to this exercise, have a read through <a href="http://aforgenet.com/articles/shape_checker/">this article</a>.</p>
<div style="break-before: page; page-break-before: always;"></div><h1 id="dynamo-for-revit"><a class="header" href="#dynamo-for-revit">Dynamo for Revit</a></h1>
<p>While Dynamo is a flexible environment, designed to port into a wide range of programs, it was originally created for use with Revit. A visual program creates robust options for a Building Information Model (BIM). Dynamo offers a whole suite of nodes specifically designed for Revit, as well as third-party libraries from a thriving AEC community. This chapter focuses on the basics of using Dynamo in Revit.</p>
<p><img src="7_dynamo_for_revit/./images/DynamoforRevit-01.jpg" alt="" /></p>
<div style="break-before: page; page-break-before: always;"></div><h1 id="the-revit-connection"><a class="header" href="#the-revit-connection">The Revit Connection</a></h1>
<p><img src="7_dynamo_for_revit/./images/1/revitconnectionlink.jpg" alt="" /></p>
<p>Dynamo for Revit extends building information modeling with the data and logic environment of a graphical algorithm editor. Its flexibility, coupled with a robust Revit database, offers a new perspective for BIM.</p>
<p>This chapter focuses on the Dynamo workflows for BIM. Sections are primarily exercise-based, since jumping right into a project is the best way to get familiar with a graphical algorithm editor for BIM. But first, let's talk about the beginnings of the program.</p>
<h3 id="revit-version-compatibility"><a class="header" href="#revit-version-compatibility">Revit Version Compatibility</a></h3>
<p>As both Revit and Dynamo continue to evolve, you may notice that the Revit version you are working with is not compatible with the Dynamo for Revit version you have installed on your machine. Below outlines which versions of Dynamo for Revit are compatible with Revit.</p>
<div class="table-wrapper"><table><thead><tr><th>Revit Version</th><th>First Stable Dynamo Version</th><th>Last Supported Dynamo for Revit Version</th></tr></thead><tbody>
<tr><td>2013</td><td><a href="http://dyn-builds-data.s3-us-west-2.amazonaws.com/DynamoInstall0.6.1.exe">0.6.1</a></td><td><a href="http://dyn-builds-data.s3-us-west-2.amazonaws.com/DynamoInstall0.6.3.exe">0.6.3</a></td></tr>
<tr><td>2014</td><td><a href="http://dyn-builds-data.s3-us-west-2.amazonaws.com/DynamoInstall0.6.1.exe">0.6.1</a></td><td><a href="http://dyn-builds-data.s3-us-west-2.amazonaws.com/DynamoInstall0.8.2.exe">0.8.2</a></td></tr>
<tr><td>2015</td><td><a href="http://dyn-builds-data.s3-us-west-2.amazonaws.com/DynamoInstall0.7.1.exe">0.7.1</a></td><td><a href="http://dyn-builds-data.s3-us-west-2.amazonaws.com/DynamoInstall1.2.1.exe">1.2.1</a></td></tr>
<tr><td>2016</td><td><a href="http://dyn-builds-data.s3-us-west-2.amazonaws.com/DynamoInstall0.7.2.exe">0.7.2</a></td><td><a href="http://dyn-builds-data.s3-us-west-2.amazonaws.com/DynamoInstall1.3.2.exe">1.3.2</a></td></tr>
<tr><td>2017</td><td><a href="http://dyn-builds-data.s3-us-west-2.amazonaws.com/DynamoInstall0.9.0.exe">0.9.0</a></td><td><a href="http://dyn-builds-data.s3-us-west-2.amazonaws.com/DynamoInstall1.3.4.exe">1.3.4</a> / <a href="https://dyn-builds-data.s3-us-west-2.amazonaws.com/DynamoInstall2.0.3.exe">2.0.3</a></td></tr>
<tr><td>2018</td><td><a href="http://dyn-builds-data.s3-us-west-2.amazonaws.com/DynamoInstall1.3.0.exe">1.3.0</a></td><td><a href="http://dyn-builds-data.s3-us-west-2.amazonaws.com/DynamoInstall1.3.4.exe">1.3.4</a> / <a href="https://dyn-builds-data.s3-us-west-2.amazonaws.com/DynamoInstall2.0.3.exe">2.0.3</a></td></tr>
<tr><td>2019</td><td><a href="http://dyn-builds-data.s3-us-west-2.amazonaws.com/DynamoInstall1.3.3.exe">1.3.3</a></td><td><a href="http://dyn-builds-data.s3-us-west-2.amazonaws.com/DynamoInstall1.3.4.exe">1.3.4</a> / <a href="https://dyn-builds-data.s3-us-west-2.amazonaws.com/DynamoInstall2.0.4.exe">2.0.4</a></td></tr>
<tr><td>2020+</td><td>2.1.0 - Revit 2020+ now includes Dynamo and receives updates as Revit does.)</td><td>N/A</td></tr>
</tbody></table>
</div>
<h3 id="history-of-dynamo"><a class="header" href="#history-of-dynamo">History of Dynamo</a></h3>
<p><img src="7_dynamo_for_revit/./images/1/earlyScreenshot.jpg" alt="History" /></p>
<p>With a dedicated team of developers and a passionate community, the project has come a long way from its humble beginnings.</p>
<p>Dynamo was originally created to streamline AEC workflows in Revit. While Revit creates a robust database for every project, it can be difficult for an average user to access this information outside of the constraints of the interface. Revit hosts a comprehensive API (Application Program Interface), allowing third-party developers to create custom tools. And programmers have been using this API for years, but text-based scripting isn't accessible to everyone. Dynamo seeks to democratize Revit data through an approachable graphical algorithm editor.</p>
<p>Using the core Dynamo nodes in tandem with custom Revit ones, a user can substantially expand parametric workflows for interoperability, documentation, analysis, and generation. With Dynamo, tedious workflows can be automated while design explorations can thrive.</p>
<h3 id="running-dynamo-in-revit"><a class="header" href="#running-dynamo-in-revit">Running Dynamo in Revit</a></h3>
<p>In a Revit project or family editor, navigate to Addins and click Dynamo.*</p>
<p>{% hint style=&quot;warning&quot; %}
*Dynamo will run only in the file in which it was opened.
{% endhint %}</p>
<p><img src="7_dynamo_for_revit/./images/1/launchdynamofromrevit.jpg" alt="" /></p>
<p>When opening Dynamo in Revit, there is a new category called &quot;Revit&quot;. This is a comprehensive addition to the UI which offers nodes specifically catering to Revit workflows.*</p>
<p>{% hint style=&quot;warning&quot; %}
*By using the Revit-specific family of nodes, the Dynamo graph will only work when opening in Dynamo for Revit. If a Dynamo for Revit graph is opened in Dynamo Sandbox for example, the Revit nodes will be missing.
{% endhint %}</p>
<p><img src="7_dynamo_for_revit/./images/1/revitconnection-runningdynamoinrevit02.jpg" alt="" /></p>
<h3 id="freezing-nodes"><a class="header" href="#freezing-nodes">Freezing Nodes</a></h3>
<p>Since Revit is a platform which provides robust project management, parametric operations in Dynamo can be complex and slow to calculate. If Dynamo is taking a long time to calculate nodes, you may want to use the &quot;freeze&quot; node functionality in order to pause the execution of Revit operations while you develop your graph. For more information on freezing nodes, check out the &quot;<a href="7_dynamo_for_revit/../essential-nodes-and-concepts/5_geometry-for-computational-design/5-6_solids.html#freezing">Freezing</a>&quot; section in the solids chapter.</p>
<h3 id="community--dynamo-blog"><a class="header" href="#community--dynamo-blog">Community &amp; Dynamo Blog</a></h3>
<p>Since Dynamo was originally created for AEC, its large and growing community is a great resource for learning from and connecting with experts in the industry. Dynamos community is made of architects, engineers, programmers, and designers who all have a passion for sharing and making.</p>
<p>Dynamo is an open-source project that is constantly evolving, and a lot of development is Revit-related. If you're new to the game, get on the discussion forum and start <a href="http://dynamobim.org/forums/forum/dyn/">posting questions</a>! If you're a programmer and want to get involved in Dynamo's development, check out the <a href="https://github.com/DynamoDS/Dynamo">github page</a>. Also, a great resource for third-party libraries is the <a href="http://dynamopackages.com">Dynamo package manager</a>. Many of these packages are made with AEC in mind, and we'll take a look at third-party packages for panelization in this chapter.</p>
<p>Dynamo also maintains an active blog. Read up on recent posts to learn about the latest developments!</p>
<p><img src="7_dynamo_for_revit/./images/1/blog.png" alt="Blog" /></p>
<div style="break-before: page; page-break-before: always;"></div><h1 id="selecting"><a class="header" href="#selecting">Selecting</a></h1>
<h3 id="select-revit-elements"><a class="header" href="#select-revit-elements">Select Revit Elements</a></h3>
<p>Revit is a data-rich environment. This gives us a range of selection abilities which expands far beyond &quot;point-and-click&quot;. We can query the Revit database and dynamically link Revit elements to Dynamo geometry while performing parametric operations.</p>
<p>The Revit library in the UI offers a &quot;Selection&quot; category which enables multiple ways to select geometry.</p>
<p><img src="7_dynamo_for_revit/../.gitbook/assets/select_revit_elements_01.jpg" alt="" /></p>
<h3 id="revit-hierarchy"><a class="header" href="#revit-hierarchy">Revit Hierarchy</a></h3>
<p>To select Revit elements properly, it's important to have a full-understanding of the Revit element hierarchy. Want to select all the walls in a project? Select by category. Want to select every Eames chair in your mid-century modern lobby? Select by family.</p>
<p>Let's do a quick review of the Revit hierarchy.</p>
<p><img src="7_dynamo_for_revit/images/2/hierarchy.png" alt="" /></p>
<p>Remember the taxonomy from Biology? Kingdom, Phylum, Class, Order, Family, Genus, Species? Revit elements are categorized in a similar manner. On a basic level, the Revit hierarchy can be broken down into Categories, Families, Types*, and Instances. An instance is an individual model element (with a unique ID) while a category defines a generic group (like &quot;walls&quot; or &quot;floors&quot;). With the Revit database organized in this manner, we can select one element and choose all similar elements based on a specified level in the hierarchy.</p>
<p>{% hint style=&quot;warning&quot; %}
*Types in Revit are defined differently from types in programming. In Revit, a type refers to a branch of the hierarchy, rather than a &quot;data type&quot;.
{% endhint %}</p>
<h3 id="database-navigation-with-dynamo-nodes"><a class="header" href="#database-navigation-with-dynamo-nodes">Database Navigation with Dynamo nodes</a></h3>
<p>The three images below breakdown the main categories for Revit element selection in Dynamo. These are great tools to use in combination, and we'll explore some of these in the following exercises.</p>
<p><em>Point-and-click</em> is the easiest way to directly select a Revit element. You can select a full model element, or parts of its topology (like a face or an edge). This remains dynamically linked to that Revit object, so when the Revit file updates its location or parameters, the referenced Dynamo element will update in the graph.</p>
<p><img src="7_dynamo_for_revit/../.gitbook/assets/selecting_database_navigation_with_dynamo_nodes_01.jpg" alt="" /></p>
<p><em>Dropdown menus</em> create a list of all accessible elements in a Revit project. You can use this to reference Revit elements which are not necessarily visible in a view. This is a great tool for querying existing elements or creating new ones in a Revit project or family editor.</p>
<p>![](../.gitbook/assets/selecting _database_navigation_with_dynamo_nodes_02.png)</p>
<p>You can also select Revit element by specific tiers in the <em>Revit hierarchy</em>. This is a powerful option for customizing large arrays of data in preparation for documentation or generative instantiation and customization.</p>
<p><img src="7_dynamo_for_revit/../.gitbook/assets/allelements.jpg" alt="UI" /></p>
<p>With the three images above in mind, let's dive into an exercise which selects elements from a basic Revit project in preparation for the parametric applications we'll create in the remaining sections of this chapter.</p>
<h2 id="exercise-5"><a class="header" href="#exercise-5">Exercise</a></h2>
<blockquote>
<p>Download the example file by clicking on the link below.</p>
<p>A full list of example files can be found in the Appendix.</p>
</blockquote>
<p>{% file src=&quot;datasets/2/Revit-Selecting.zip&quot; %}</p>
<p>In this example Revit file, we have three element types of a simple building. We're going to use this as an example for selecting Revit elements within the context of the Revit hierarchy.</p>
<p><img src="7_dynamo_for_revit/../.gitbook/assets/selecting_exercise_01.jpg" alt="" /></p>
<blockquote>
<ol>
<li>Building Mass</li>
<li>Beams (Structural Framing)</li>
<li>Trusses (Adaptive Components)</li>
</ol>
</blockquote>
<p>What conclusions can we draw from the elements currently in the Revit project view? And how far down the hierarchy do we need to go to select the appropriate elements? This will of course become a more complex task when working on a large project. There are a lot of options available: we can select elements by categories, levels, families, instances, etc.</p>
<h3 id="selecting-mass-and-surfaces"><a class="header" href="#selecting-mass-and-surfaces">Selecting Mass and Surfaces</a></h3>
<p><img src="7_dynamo_for_revit/../.gitbook/assets/selecting_exercise_02.jpg" alt="" /></p>
<blockquote>
<ol>
<li>Since we're working with a basic setup, let's select the building mass by choosing <em>&quot;Mass&quot;</em> in the Categories dropdown node. This can be found in the Revit&gt;Selection tab.</li>
<li>The output of the Mass category is just the category itself. We need to select the elements. To do this, we use the <em>&quot;All Elements of Category&quot;</em> node.</li>
</ol>
</blockquote>
<p>At this point, notice that we don't see any geometry in Dynamo. We've selected a Revit element, but have not converted the element into Dynamo geometry. This is an important separation. If you were to select a large number of elements, you don't want to preview all of them in Dynamo because this would slow everything down. Dynamo is a tool to manage a Revit project without necessarily performing geometry operations, and we'll look at that in the next section of this chapter.</p>
<p>In this case, we're working with simple geometry, so we want to bring the geometry into the Dynamo preview. The &quot;BldgMass&quot; in the watch node above has a green number next to it. This represents the element's ID and tells us that we are dealing with a Revit element, not Dynamo geometry. The next step is to convert this Revit element into geometry in Dynamo.</p>
<p><img src="7_dynamo_for_revit/../.gitbook/assets/selecting_exercise_03.jpg" alt="" /></p>
<blockquote>
<ol>
<li>Using the <em>Element.Faces</em> node, we get a list of surfaces representing each face of the Revit Mass. We can now see the geometry in the Dynamo viewport and start to reference the face for parametric operations.</li>
</ol>
</blockquote>
<p>Here's an alternative method. In this case, we're stepping away from selecting via the Revit Hierarchy <em>(&quot;All Elements of Category&quot;)</em> and electing to explicitly select geometry in Revit.</p>
<p><img src="7_dynamo_for_revit/../.gitbook/assets/selecting_exercise_04.jpg" alt="" /></p>
<blockquote>
<ol>
<li>Using the <em>&quot;Select Model Element&quot;</em> node, click the *&quot;select&quot; *(or <em>&quot;change&quot;</em>) button. In the Revit viewport, select the desired element. In this case, we're selecting the building mass.</li>
<li>Rather than <em>Element.Faces</em>, we can select the full mass as one solid geometry using <em>Element.Geometry</em>. This selects all of the geometry contained within that mass.</li>
<li>Using <em>Geometry.Explode,</em> we can get the list of surfaces again. These two nodes work the same as <em>Element.Faces</em> but offer alternative options for delving into the geometry of a Revit element.</li>
</ol>
</blockquote>
<p>Using some basic list operations, we can query a face of interest.</p>
<p>![](images/2/selecting - exercise 05.jpg)</p>
<blockquote>
<ol>
<li>First, output the selected elements from earlier to Element.Faces node.</li>
<li>Next, use the <em>List.Count</em> node reveals that we're working with 23 surfaces in the mass.</li>
<li>Referencing this number, we change the Maximum value of an *integer slider *to <em>&quot;22&quot;</em>.</li>
<li>Using <em>List.GetItemAtIndex</em>, we input the lists and the *integer slider *for the <em>index</em>. Sliding through with the selected, we stop when we get to <em>index 9</em> and have isolated the main facade hosts the trusses.</li>
</ol>
</blockquote>
<p>The previous step was a little cumbersome. We can do this much faster with the <em>&quot;Select Face&quot;</em> node. This allows us to isolate a face that is not an element itself in the Revit project. The same interaction applies as <em>&quot;Select Model Element&quot;</em>, except we select the surface rather than the full element.</p>
<p><img src="7_dynamo_for_revit/../.gitbook/assets/selecting_exercise_06.jpg" alt="" /></p>
<p>Suppose we want to isolate the main facade walls of the building. We can use the <em>&quot;Select Faces&quot;</em> node to do this. Click the &quot;Select&quot; button and then select the four main facades in Revit.</p>
<p><img src="7_dynamo_for_revit/../.gitbook/assets/selecting_exercise_07.jpg" alt="" /></p>
<p>After selecting the four walls, make sure you click the &quot;Finish&quot; button in Revit.</p>
<p><img src="7_dynamo_for_revit/../.gitbook/assets/selecting_exercise_08.jpg" alt="" /></p>
<p>The faces are now imported into Dynamo as surfaces.</p>
<p><img src="7_dynamo_for_revit/../.gitbook/assets/selecting_exercise_09.jpg" alt="" /></p>
<h3 id="selecting-beams"><a class="header" href="#selecting-beams">Selecting Beams</a></h3>
<p>Now, let's take a look at the beams over the atrium.</p>
<p><img src="7_dynamo_for_revit/../.gitbook/assets/selecting_exercise_10.jpg" alt="" /></p>
<blockquote>
<ol>
<li>Use the <em>&quot;Select Model Element&quot;</em> node, select one of the beams.</li>
<li>Plug the beam element into the <em>Element.Geometry</em> node and we now have the beam in the Dynamo viewport.</li>
<li>We can zoom in on the geometry with a <em>Watch3D</em> node (if you don't see the beam in Watch 3D, right click and hit &quot;zoom to fit&quot;).</li>
</ol>
</blockquote>
<p>A question that may come up often in Revit/Dynamo workflows: how do I select one element and get all similar elements? Since the selected Revit element contains all of its hierarchical information, we can query its family type and select all elements of that type.</p>
<p><img src="7_dynamo_for_revit/../.gitbook/assets/selecting_exercise_11.jpg" alt="" /></p>
<blockquote>
<ol>
<li>Plug the beam element into a <em>Element.ElementType</em> node.</li>
<li>The <em>Watch</em> node reveals that the output is now a family symbol rather than a Revit element.</li>
<li><em>Element.ElementType</em> is a simple query, so we can do this in the code block just as easily with <code>x.ElementType;</code> and get the same results.</li>
</ol>
</blockquote>
<p><img src="7_dynamo_for_revit/../.gitbook/assets/selecting_exercise_12.jpg" alt="" /></p>
<blockquote>
<ol>
<li>To select the remaining beams, we use the <em>&quot;All Elements of Family Type&quot;</em> node.</li>
<li>The watch node shows that we've selected five Revit elements.</li>
</ol>
</blockquote>
<p><img src="7_dynamo_for_revit/../.gitbook/assets/selecting_exercise_13.jpg" alt="" /></p>
<blockquote>
<ol>
<li>We can convert all of these five elements to Dynamo geometry too.</li>
</ol>
</blockquote>
<p>What if we had 500 beams? Converting all of these elements into Dynamo geometry would be really slow. If Dynamo is taking a long time to calculate nodes, you may want to use the &quot;freeze&quot; node functionality in order to pause the execution of Revit operations while you develop your graph. For more information on freezing nodes, check out the &quot;<a href="7_dynamo_for_revit/../essential-nodes-and-concepts/5_geometry-for-computational-design/5-6_solids.html#freezing">Freezing</a>&quot; section in the solids chapter.</p>
<p>In any case, if we were to import 500 beams, do we need all of the surfaces to perform the intended parametric operation? Or can we extract basic information from the beams and perform generative tasks with fundamental geometry? This is a question that we'll keep in mind as we walk through this chapter. For example, let's take a look at the truss system next.</p>
<h3 id="selecting-trusses"><a class="header" href="#selecting-trusses">Selecting Trusses</a></h3>
<p>Using the same graph of nodes, select the truss element rather than the beam element. Before doing this, delete the Element.Geometry from the previous step.</p>
<p><img src="7_dynamo_for_revit/../.gitbook/assets/selecting_exercise_14.jpg" alt="" /></p>
<p>Next we are ready to extract some basic information from trusses family type.</p>
<p><img src="7_dynamo_for_revit/../.gitbook/assets/selecting_exercise_15.jpg" alt="" /></p>
<blockquote>
<ol>
<li>In the <em>Watch</em> node, we can see that we have a list of adaptive components selected from Revit. We want to extract the basic information, so we're start with the adaptive points.</li>
<li>Plug the <em>&quot;All Elements of Family Type&quot;</em> node into the <em>&quot;AdaptiveComponent.Location&quot;</em> node. This gives us a list of lists, each with three points which represent the adaptive point locations.</li>
<li>Connecting a <em>&quot;Polygon.ByPoints&quot;</em> node returns a polycurve. We can see this in the Dynamo viewport. By this method, we've visualized the geometry of one element and abstracted the geometry of the remaining array of elements (which could be larger in number than this example).</li>
</ol>
</blockquote>
<p>{% hint style=&quot;info&quot; %}
Tip: if you click on the green number of a Revit element in Dynamo, the Revit viewport will zoom to that element.
{% endhint %}</p>
<div style="break-before: page; page-break-before: always;"></div><h1 id="editing"><a class="header" href="#editing">Editing</a></h1>
<p>A powerful feature of Dynamo is that you can edit parameters on a parametric level. For example, a generative algorithm or the results of a simulation can be used to drive the parameters of an array of elements. This way, a set of instances from the same family can have custom properties in your Revit project.</p>
<h3 id="type-and-instance-parameters"><a class="header" href="#type-and-instance-parameters">Type and Instance Parameters</a></h3>
<p><img src="7_dynamo_for_revit/images/3/32(2).jpg" alt="Exercise" /></p>
<blockquote>
<ol>
<li>Instance parameters define the aperture of the panels on the roof surface, ranging from an Aperture Ratio of 0.1 to 0.4.</li>
<li>Type-based parameters are applied to every element on the surface because they are the same family type. The material of each panel, for example, can be driven by a type-based parameter.</li>
</ol>
</blockquote>
<p><img src="7_dynamo_for_revit/../.gitbook/assets/params.jpg" alt="Exercise" /></p>
<blockquote>
<ol>
<li>If you've set up a Revit family before, remember that you have to assign a parameter type (string, number, dimension, etc.) Be sure to use the correct data type when assigning parameters from Dynamo.</li>
<li>You can also use Dynamo in combination with parametric constraints defined in a Revit family's properties.</li>
</ol>
</blockquote>
<p>As a quick review of parameters in Revit, we recall that there are type parameters and instance parameters. Both can be edited from Dynamo, but we'll work with instance parameters in the exercise below.</p>
<p>{% hint style=&quot;info&quot; %}
As you discover the wide-reaching application of editing parameters, you may want to edit a large quantity of elements in Revit with Dynamo. This can be a <em>computationally expensive</em> operation, meaning that it can be slow. If you're editing a large number of elements, you may want to use the &quot;freeze&quot; node functionality in order to pause the execution of Revit operations while you develop your graph. For more information on freezing nodes, check out the &quot;<a href="7_dynamo_for_revit/../essential-nodes-and-concepts/5_geometry-for-computational-design/5-6_solids.html#freezing">Freezing</a>&quot; section in the solids chapter.
{% endhint %}</p>
<h3 id="units"><a class="header" href="#units">Units</a></h3>
<p>As of version 0.8, Dynamo is fundamentally unitless. This allows Dynamo to remain an abstract visual programming environment. Dynamo nodes that interact with Revit dimensions will reference the Revit project's units. For example, if you are setting a length parameter in Revit from Dynamo, the number in Dynamo for the value will correspond to the default units in the Revit project. The exercise below works in meters.</p>
<p>For a quick conversion of units, use the <em>&quot;Convert Between Units&quot;</em> node. This is a handy tool for converting Length, Area, and Volume units on the fly.</p>
<p><img src="7_dynamo_for_revit/images/3/editing-units.jpg" alt="" /></p>
<h2 id="exercise-6"><a class="header" href="#exercise-6">Exercise</a></h2>
<blockquote>
<p>Download the example file by clicking on the link below.</p>
<p>A full list of example files can be found in the Appendix.</p>
</blockquote>
<p>{% file src=&quot;datasets/3/Revit-Editing.zip&quot; %}</p>
<p>{% hint style=&quot;warning&quot; %}
The exercise below works in meters.
{% endhint %}</p>
<p>This exercise focuses on editing Revit elements without performing geometric operation in Dynamo. We're not importing Dynamo geometry here, just editing parameters in a Revit project. This exercise is basic, and to the more advanced Revit users, notice that these are instance parameters of a mass, but the same logic can be applied to an array of elements to customize on a large scale. This is all done with the &quot;Element.SetParameterByName&quot; node.</p>
<h3 id="editing-building-mass-parameters"><a class="header" href="#editing-building-mass-parameters">Editing Building Mass Parameters</a></h3>
<p>Begin with the example Revit file for this section. We've removed the structural elements and adaptive trusses from the previous section. In this exercise, we will focus on a parametric rig in Revit and manipulating in Dynamo.</p>
<p>Selecting the building in Mass in Revit, we see an array of instance parameters in the properties panel.</p>
<p><img src="7_dynamo_for_revit/images/3/editing-exercise01.jpg" alt="" /></p>
<p>In Dynamo, we can retrieve the parameters by selecting the targeting element.</p>
<p><img src="7_dynamo_for_revit/images/3/editing-exercise02.jpg" alt="" /></p>
<blockquote>
<ol>
<li>Select the building mass with the <em>&quot;Select Model Element&quot;</em> node.</li>
<li>We can query all of the parameters of this mass with the <em>&quot;Element.Parameters&quot;</em> node. This includes type and instance parameters.</li>
</ol>
</blockquote>
<p><img src="7_dynamo_for_revit/images/3/editing-exercise03.jpg" alt="" /></p>
<blockquote>
<ol>
<li>Reference the <em>Element. Parameters</em> node to find target parameters. Or, we can view the properties panel from the previous step to choose which parameter names we want to edit. In this case, we are looking for the parameters which affect the large geometric moves on the building mass.</li>
<li>We will make changes to the Revit element using the <em>Element.SetParameterByName</em> node</li>
<li>Use C_ode Block to_ define a list of parameters, with quotes around each item to denote a string. We can also use the List.Create node with a series of <em>&quot;string&quot;</em> nodes connected to multiple inputs but Code block is faster and easier. Make sure that the string matches the exact name in Revit, case-specific: <code>{&quot;BldgWidth&quot;,&quot;BldgLength&quot;,&quot;BldgHeight&quot;, &quot;AtriumOffset&quot;, &quot;InsideOffset&quot;,&quot;LiftUp&quot;};</code></li>
</ol>
</blockquote>
<p><img src="7_dynamo_for_revit/images/3/editing-exercise04.jpg" alt="" /></p>
<blockquote>
<ol>
<li>We also want to designate values for each parameter. Add six <em>&quot;integer sliders&quot;</em> to the canvas and rename to the corresponding parameter in the list. Also, set the values of each slider to the image above. In order from top-to-bottom: 62,92,25,22,8,12</li>
<li>Define another <em>code block</em> with a list of the same length as the parameter names. In this case, we name variables (without quotes) which create inputs for the <em>code block.</em> Plug the <em>sliders</em> into each respective input: <code>{bw,bl,bh,ao,io,lu};</code></li>
<li>Connect the Code Block <em>to the &quot;Element.SetParameterByName&quot;*</em> value input. With run automatically checked, we will automatically see results.</li>
</ol>
</blockquote>
<p>{% hint style=&quot;warning&quot; %}
*This demonstration works with instance parameters, but not type parameters.
{% endhint %}</p>
<p>Just as in Revit, many of these parameters are dependent on each other. There are of course combinations where the geometry may break. We can remedy this issue with defined formulas in the parameter properties, or we can setup a similar logic with math operations in Dynamo (this is an additional challenge if you'd like to expand on the exercise).</p>
<p><img src="7_dynamo_for_revit/images/3/editing-exercise05.jpg" alt="" /></p>
<blockquote>
<ol>
<li>This combination gives a funky new design to the building mass: 100, 92, 100, 25, 13, 51</li>
</ol>
</blockquote>
<h3 id="editing-facade-parameters"><a class="header" href="#editing-facade-parameters">Editing Facade Parameters</a></h3>
<p>Next, let's look at how we can edit the facade using a similar process.</p>
<p><img src="7_dynamo_for_revit/images/3/editing-exercise06.jpg" alt="" /></p>
<blockquote>
<ol>
<li>Copy the graph and focus on the facade glazing which will house the truss system. We isolate four parameters in this case: <code>{&quot;DblSkin_SouthOffset&quot;,&quot;DblSkin_MidOffset&quot;,&quot;DblSkin_NorthOffset&quot;,&quot;Facade Bend Location&quot;};</code></li>
<li>Additionally, we create <em>number sliders</em> and rename to the appropriate parameters. The first three sliders from top-to-bottom should be remapped to a domain of [0,10], while the final slider, <em>&quot;Facade Bend Location&quot;</em>, should be remapped to a domain of [0,1]. These values, from top-to-bottom should start with these values (although they're arbitrary): 2.68, 2.64, 2.29, 0.5</li>
<li>Define a new Code block and connect the sliders: <code>{so,mo,no,fbl};</code></li>
</ol>
</blockquote>
<p><img src="7_dynamo_for_revit/images/3/editing-exercise07.jpg" alt="" /></p>
<blockquote>
<ol>
<li>By changing the <em>sliders</em> in this part of the graph, we can make the facade glazing much more substantial: 9.98, 10.0, 9.71 ,0.31</li>
</ol>
</blockquote>
<div style="break-before: page; page-break-before: always;"></div><h1 id="creating"><a class="header" href="#creating">Creating</a></h1>
<p>You can create an array of Revit elements in Dynamo with full parametric control. The Revit nodes in Dynamo offer the ability to import elements from generic geometries to specific category types (like walls and floors). In this section, we'll focus on importing parametrically flexible elements with adaptive components.</p>
<p><img src="7_dynamo_for_revit/images/4/creating-dynamonodes.jpg" alt="" /></p>
<h3 id="adaptive-components"><a class="header" href="#adaptive-components">Adaptive Components</a></h3>
<p>An adaptive component is a flexible family category which lends itself well to generative applications. Upon instantiation, you can create a complex geometric element which is driven by the fundamental location of adaptive points.</p>
<p>Below is an example of a three-point adaptive component in the family editor. This generates a truss which is defined by the position of each adaptive point. In the exercise below, we'll use this component to generate a series of trusses across a facade.</p>
<p><img src="7_dynamo_for_revit/images/4/ac.jpg" alt="" /></p>
<h3 id="principles-of-interoperability"><a class="header" href="#principles-of-interoperability">Principles of Interoperability</a></h3>
<p>The adaptive component is a good example for best practices of interoperability. We can create an array of adaptive components by defining the fundamental adaptive points. And, when transferring this data to other programs, we have the ability to reduce the geometry to simple data. Importing and exporting with a program like Excel follows a similar logic.</p>
<p>Suppose a facade consultant wants to know the location of the truss elements without needing to parse through fully articulated geometry. In preparation for fabrication, the consultant can reference the location of adaptive points to regenerate geometry in a program like Inventor.</p>
<p>The workflow we'll setup in the exercise below allows us to access all of this data while creating the definition for Revit element creation. By this process, we can merge conceptualization, documentation, and fabrication into a seamless workflow. This creates a more intelligent and efficient process for interoperability.</p>
<h3 id="multiple-elements-and-lists"><a class="header" href="#multiple-elements-and-lists">Multiple Elements and Lists</a></h3>
<p>The <a href="7_dynamo_for_revit/8-4_creating.html#exercise">first exercise</a> below will walk through how Dynamo references data for Revit element creation. To generate multiple adaptive components, we define a list of lists, where each list has three points representing each point of the adaptive component. We'll keep this in mind as we manage the data structures in Dynamo.</p>
<p><img src="7_dynamo_for_revit/images/4/creating-multipleelementsandlists01.jpg" alt="" /></p>
<h3 id="directshape-elements"><a class="header" href="#directshape-elements">DirectShape Elements</a></h3>
<p>Another method for importing parametric Dynamo geometry into Revit is with DirectShape. In summary, the DirectShape element and related classes support the ability to store externally created geometric shapes in a Revit document. The geometry can include closed solids or meshes. DirectShape is primarily intended for importing shapes from other data formats such as IFC or STEP where not enough information is available to create a &quot;real&quot; Revit element. Like the IFC and STEP workflow, the DirectShape functionality works well with importing Dynamo created geometries into Revit projects as real elements.</p>
<p>Let's walk through <a href="7_dynamo_for_revit/8-4_creating.html#exercise-directshape-elements">second exercise</a> for importing Dynamo geometry as a DirectShape into our Revit project. Using this method, we can assign an imported geometry's category, material, and name - all while maintaining a parametric link to our Dynamo graph.</p>
<h2 id="exercise-generate-elements-and-lists"><a class="header" href="#exercise-generate-elements-and-lists">Exercise: Generate Elements and Lists</a></h2>
<blockquote>
<p>Download the example file by clicking on the link below.</p>
<p>A full list of example files can be found in the Appendix.</p>
</blockquote>
<p>{% file src=&quot;datasets/4/Revit-Creating.zip&quot; %}</p>
<p>Beginning with the example file from this section (or continuing with the Revit file from the previous session), we see the same Revit mass.</p>
<p><img src="7_dynamo_for_revit/images/4/creating-exercise01.jpg" alt="" /></p>
<blockquote>
<ol>
<li>This is the file as opened.</li>
<li>This is the truss system we created with Dynamo, linked intelligently to the Revit mass.</li>
</ol>
</blockquote>
<p>We've used the <em>&quot;Select Model Element&quot;</em> and <em>&quot;Select Face&quot;</em> nodes, now we're taking one step further down in the geometry hierarchy and using <em>&quot;Select Edge&quot;</em>. With the Dynamo solver set to run <em>&quot;Automatic&quot;</em>, the graph will continually update to changes in the Revit file. The edge we are selecting is tied dynamically to the Revit element topology. As long as the topology* does not change, the connection remains linked between Revit and Dynamo.</p>
<p><img src="7_dynamo_for_revit/images/4/creating-exercise02.jpg" alt="" /></p>
<blockquote>
<ol>
<li>Select the top most curve of the glazing facade. This spans the full length of the building. If you're having trouble selecting the edge, remember to choose the selection in Revit by hovering over the edge and hitting <em>&quot;Tab&quot;</em> until the desired edge is highlighted.</li>
<li>Using two <em>&quot;Select Edge&quot;</em> nodes, select each edge representing the cant at the middle of the facade.</li>
<li>Do the same for the bottom edges of the facade in Revit.</li>
<li>The <em>Watch</em> nodes reveal that we now have lines in Dynamo. This is automatically converted to Dynamo geometry since the edges themselves are not Revit elements. These curves are the references we'll use to instantiate adaptive trusses across the facade.</li>
</ol>
</blockquote>
<p>{% hint style=&quot;info&quot; %}
*To keep a consistent topology, we're referring to a model that does not have additional faces or edges added. While parameters can change its shape, the way in which it is built remains consistent.
{% endhint %}</p>
<p>We first need to join the curves and merge them into one list. This way we can <em>&quot;group&quot;</em> the curves to perform geometry operations.</p>
<p><img src="7_dynamo_for_revit/images/4/creating-exercise03.jpg" alt="" /></p>
<blockquote>
<ol>
<li>Create a list for the two curves at the middle of the facade.</li>
<li>Join the two curves into a Polycurve by plugging the <em>List.Create</em> component into a <em>Polycurve.ByJoinedCurves</em> node.</li>
<li>Create a list for the two curves at the bottom of the facade.</li>
<li>Join the two curves into a Polycurve by plugging the <em>List.Create</em> component into a <em>Polycurve.ByJoinedCurves</em> node.</li>
<li>Finally, join the three main curves (one line and two polycurves) into one list.</li>
</ol>
</blockquote>
<p>We want to take advantage of the top curve, which is a line, and represents the full span of the facade. We'll create planes along this line to intersect with the set of curves we've grouped together in a list.</p>
<p><img src="7_dynamo_for_revit/images/4/creating-exercise04.jpg" alt="" /></p>
<blockquote>
<ol>
<li>With a <em>code block</em>, define a range using the syntax: <code>0..1..#numberOfTrusses;</code></li>
<li>Plug an *integer slider *into the input for the code block. As you could have guessed, this will represent the number of trusses. Notice that the slider controls the number of items in the range defined from *0 *to <em>1</em>.</li>
<li>Plug the <em>code block</em> into the <em>param</em> input of a <em>&quot;Curve.PlaneAtParameter&quot;</em> node, and plug the top edge into the <em>curve</em> input. This will give us ten planes, evenly distributed across the span of the facade.</li>
</ol>
</blockquote>
<p>A plane is an abstract piece of geometry, representing a two dimensional space which is infinite. Planes are great for contouring and intersecting, as we are setting up in this step.</p>
<p><img src="7_dynamo_for_revit/images/4/creating-exercise05.jpg" alt="" /></p>
<blockquote>
<ol>
<li>Using the <em>Geometry.Intersect</em> node (set lacing option to cross product), plug the <em>Curve.PlaneAtParameter</em> into the <em>entity</em> input of the <em>Geometry.Intersect</em> node. Plug the main <em>List.Create</em> node into the <em>geometry</em> input. We now see points in the Dynamo viewport representing the intersection of each curve with the defined planes.</li>
</ol>
</blockquote>
<p>Notice the output is a list of lists of lists. Too many lists for our purposes. We want to do a partial flatten here. We need to take one step down on the list and flatten the result. To do this, we use the <em>List.Map</em> operation, as discussed in the list chapter of the primer.</p>
<p><img src="7_dynamo_for_revit/images/4/creating-exercise06.jpg" alt="" /></p>
<blockquote>
<ol>
<li>Plug the <em>Geometry.Intersect</em> node into the list input of <em>List.Map</em>.</li>
<li>Plug a <em>Flatten</em> node into the f(x) input of <em>List.Map</em>. The results gives 3 list, each with a count equal to the number of trusses.</li>
<li>We need to change this data. If we want to instantiate the truss, we have to use the same number of adaptive points as defined in the family. This is a three point adaptive component, so instead of three lists with 10 items each (numberOfTrusses), we want 10 lists of three items each. This way we can create 10 adaptive components.</li>
<li>Plug the <em>List.Map</em> into a <em>List.Transpose</em> node. Now we have the desired data output.</li>
<li>To confirm that the data is correct, add a <em>Polygon.ByPoints</em> node to the canvas and double check with the Dynamo preview.</li>
</ol>
</blockquote>
<p>In the same way we created the polygons, we array the adaptive components.</p>
<p><img src="7_dynamo_for_revit/images/4/creating-exercise07.jpg" alt="" /></p>
<blockquote>
<ol>
<li>Add an <em>AdaptiveComponent.ByPoints</em> node to the canvas, plug the <em>List.Transpose</em> node into the <em>points</em> input.</li>
<li>Using a <em>Family Types</em> node, select the <em>&quot;AdaptiveTruss&quot;</em> family, and plug this into the <em>FamilyType</em> input of the <em>AdaptiveComponent.ByPoints</em> node.</li>
</ol>
</blockquote>
<p>In Revit, we now have the ten trusses evenly spaced across the facade!</p>
<p>&quot;Flex&quot; the graph, we turn up the numberOfTrusses to 30 by changing the slider. Lots of trusses, not very realistic, but the parametric link is working. Once verified, set the numberOfTrusses to 15.</p>
<p><img src="7_dynamo_for_revit/images/4/creating-exercise08.gif" alt="" /></p>
<p>And for the final test, by selecting the mass in Revit and editing instance parameters, we can change the form of the building and watch the truss follow suit. Remember, this Dynamo graph has to be open in order to see this update, and the link will be broken as soon as it's closed.</p>
<p><img src="7_dynamo_for_revit/images/4/creating-exercise09.jpg" alt="" /></p>
<h2 id="exercise-directshape-elements"><a class="header" href="#exercise-directshape-elements">Exercise: DirectShape Elements</a></h2>
<blockquote>
<p>Download the example file by clicking on the link below.</p>
<p>A full list of example files can be found in the Appendix.</p>
</blockquote>
<p>{% file src=&quot;datasets/4/Revit-Creating-DirectShape.zip&quot; %}</p>
<p>Begin by opening the sample file for this lesson - ARCH-DirectShape-BaseFile.rvt.</p>
<p><img src="7_dynamo_for_revit/images/4/creating-exerciseII-01.jpg" alt="" /></p>
<blockquote>
<ol>
<li>In the 3D view, we see our building mass from the previous lesson.</li>
<li>Along the edge of the atrium is one reference curve, we'll use this as a curve to reference in Dynamo.</li>
<li>Along the opposing edge of the atrium is another reference curve which we'll reference in Dynamo as well.</li>
</ol>
</blockquote>
<p><img src="7_dynamo_for_revit/images/4/creating-exerciseII-02.jpg" alt="" /></p>
<blockquote>
<ol>
<li>To reference our geometry in Dynamo, we'll use <em>Select Model Element</em> for each member in Revit. Select the mass in Revit and import the geometry into Dynamo by Using <em>Element.Faces</em> - the mass should now be visible in your Dynamo preview.</li>
<li>Import one reference curve into Dynamo by using <em>Select Model Element</em> and <em>CurveElement.Curve</em>.</li>
<li>Import the other reference curve into Dynamo by using <em>Select Model Element</em> and <em>CurveElement.Curve</em>.</li>
</ol>
</blockquote>
<p><img src="7_dynamo_for_revit/images/4/creating-exerciseII-03.jpg" alt="" /></p>
<blockquote>
<ol>
<li>Zooming out and panning to the right in the sample graph, we see a large group of nodes - these are geometric operations which generate the trellis roof structure visible in the Dynamo preview. These nodes are generating using the <em>Node to Code</em> functionality as discussed in the <a href="7_dynamo_for_revit/../coding-in-dynamo/7_code-blocks-and-design-script/7-2_design-script-syntax.html#Node">code block section</a> of the primer.</li>
<li>The structure is driven by three major parameters - Diagonal Shift, Camber, and Radius.</li>
</ol>
</blockquote>
<p>Zooming a close-up look of the parameters for this graph. We can flex these to get different geometry outputs.</p>
<p><img src="7_dynamo_for_revit/images/4/creating-exerciseII-04.jpg" alt="" /></p>
<p><img src="7_dynamo_for_revit/images/4/creating-exerciseII-05.jpg" alt="" /></p>
<blockquote>
<ol>
<li>Dropping the <em>DirectShape.ByGeometry</em> node onto the canvas, we see that it has four inputs: <em>geometry</em><strong>,</strong> <em>category</em><strong>,</strong> <em>material</em>, and <em>name</em>.</li>
<li>Geometry will be the solid created from the geometry creation portion of the graph</li>
<li>The category input is chosen using the dropdown <em>Categories</em> node. In this case we'll use &quot;Structural Framing&quot;.</li>
<li>The material input is selected through the array of nodes above - although it can be more simply defined as &quot;Default&quot; in this case.</li>
</ol>
</blockquote>
<p>After running Dynamo, back in Revit, we have the imported geometry on the roof in our project. This is a structural framing element, rather than a generic model. The parametric link to Dynamo remains intact.</p>
<p><img src="7_dynamo_for_revit/images/4/creating-exerciseII-06.jpg" alt="" /></p>
<div style="break-before: page; page-break-before: always;"></div><h1 id="customizing"><a class="header" href="#customizing">Customizing</a></h1>
<p>While we previously looked at editing a basic building mass, we want to dive deeper into the Dynamo/Revit link by editing a large number of elements in one go. Customizing on a large scale becomes more complex as data structures require more advanced list operations. However, the underlying principles behind their execution is fundamentally the same. Let's study some opportunities for analysis from a set of adaptive components.</p>
<h3 id="point-location"><a class="header" href="#point-location">Point Location</a></h3>
<p>Suppose we've created a range of adaptive components and want to edit parameters based on their point locations. The points, for example, could drive a thickness parameter which is related to the area of the element. Or, they could drive an opacity parameter related to solar exposure throughout the year. Dynamo allows the connection of analysis to parameters in a few easy steps, and we'll explore a basic version in the exercise below.</p>
<p><img src="7_dynamo_for_revit/./images/5/customizing-pointlocation.jpg" alt="" /></p>
<blockquote>
<p>Query the adaptive points of a selected adaptive component by using the <strong>AdaptiveComponent.Locations</strong> node. This allows us to work with an abstracted version of a Revit element for analysis.</p>
</blockquote>
<p>By extracting the point location of adaptive components, we can run a range of analysis for that element. A four-point adaptive component will allow you to study the deviation from plane for a given panel for example.</p>
<h3 id="solar-orientation-analysis"><a class="header" href="#solar-orientation-analysis">Solar Orientation Analysis</a></h3>
<p><img src="7_dynamo_for_revit/./images/5/customizing-solarorientationanalysis.jpg" alt="" /></p>
<blockquote>
<p>Use remapping to map a set of a data into a parameter range. This is fundamental tool used in a parametric model, and we'll demonstrate it in the exercise below.</p>
</blockquote>
<p>Using Dynamo, the point locations of adaptive components can be used to create a best-fit plane each element. We can also query the sun position in the Revit file and study the plane's relative orientation to the sun in comparison to other adaptive components. Let's set that up in the exercise below by creating an algorithmic roofscape.</p>
<h2 id="exercise-7"><a class="header" href="#exercise-7">Exercise</a></h2>
<blockquote>
<p>Download the example file by clicking on the link below.</p>
<p>A full list of example files can be found in the Appendix.</p>
</blockquote>
<p>{% file src=&quot;./datasets/5/Revit-Customizing.zip&quot; %}</p>
<p>This exercise will expand on the techniques demonstrated in the previous section. In this case, we are defining a parametric surface from Revit elements, instantiating four-point adaptive components and then editing them based on orientation to the sun.</p>
<p><img src="7_dynamo_for_revit/./images/5/customizing-exercise01.jpg" alt="" /></p>
<blockquote>
<ol>
<li>Beginning by selecting two edges with the <em>&quot;Select Edge&quot;</em> node. The two edges are the long spans of the atrium.</li>
<li>Combine the two edges into one list with the <em>List.Create</em> node.</li>
<li>Create a surface between the two edges with a <em>Surface.ByLoft</em>.</li>
</ol>
</blockquote>
<p><img src="7_dynamo_for_revit/./images/5/customizing-exercise02.jpg" alt="" /></p>
<blockquote>
<ol>
<li>Using <em>code block</em>, define a range from 0 to 1 with 10 evenly spaced values: <code>0..1..#10;</code></li>
<li>Plug the <em>code block</em> into the *u *and <em>v</em> inputs of a <em>Surface.PointAtParameter</em> node, and plug the <em>Surface.ByLoft</em> node into the <em>surface</em> input. Right click the node and change the <em>lacing</em> to <em>Cross Product</em>. This will give a grid of points on the surface.</li>
</ol>
</blockquote>
<p>This grid of points serves as the control points for a parametrically defined surface. We want to extract the u and v positions of each one of these points so that we can plug them into a parametric formula and keep the same data structure. We can do this by querying the parameter locations of the points we just created.</p>
<p><img src="7_dynamo_for_revit/./images/5/customizing-exercise03.jpg" alt="" /></p>
<blockquote>
<ol>
<li>Add a <em>Surface.ParameterAtPoint</em> node to the canvas, connect the inputs as shown above.</li>
<li>Query the <em>u</em> values of these parameters with the UV.U node.</li>
<li>Query the <em>v</em> values of these parameters with the UV.V node.</li>
<li>The outputs show the corresponding <em>u</em> and <em>v</em> values for every point of the surface. We now have a range from <em>0</em> to <em>1</em> for each value, in the proper data structure, so we're ready to apply a parametric algorithm.</li>
</ol>
</blockquote>
<p><img src="7_dynamo_for_revit/./images/5/customizing-exercise04.jpg" alt="" /></p>
<blockquote>
<ol>
<li>Add a <em>code block</em> to the canvas and enter the code: <code>Math.Sin(u*180)*Math.Sin(v*180)*w;</code> This is a parametric function which creates a sine mound from a flat surface.</li>
<li>Connects the <em>UV.U</em> to the <em>u</em> input and the UV.V to the <em>v</em> input.</li>
<li>The <em>w</em> input represents the <em>amplitude</em> of the shape, so we attach a <em>number slider</em> to it.</li>
</ol>
</blockquote>
<p><img src="7_dynamo_for_revit/./images/5/customizing-exercise05.jpg" alt="" /></p>
<blockquote>
<ol>
<li>Now, we have a list of values as defined by the algorithm. Let's use this list of values to move the points up in the <em>+Z</em> direction. Using <em>Geometry.Translate</em>, plug the *code block *into <em>zTranslation</em> and the <em>Surface.PointAtParameter</em> into the <em>geometry</em> input. You should see the new points displayed in the Dynamo preview.</li>
<li>Finally, we create a surface with the <em>NurbsSurface.ByPoints</em> node, plugging the node from the previous step into the points input. We have ourselves a parametric surface. Feel free to drag the slider to watch the mound shrink and grow.</li>
</ol>
</blockquote>
<p>With the parametric surface, we want to define a way to panelize it in order to array four-point adaptive components. Dynamo does not have out-of-the-box functionality for surface panelization, so we can look to the community for helpful Dynamo packages.</p>
<p><img src="7_dynamo_for_revit/./images/5/customizing-exercise06.jpg" alt="" /></p>
<blockquote>
<ol>
<li>Go to <em>Packages&gt;Search for a Package...</em></li>
<li>Search for <em>&quot;LunchBox&quot;</em> and install <em>&quot;LunchBox for Dynamo&quot;</em>. This is a really helpful set of tools for geometry operations such as this.</li>
</ol>
</blockquote>
<blockquote>
<ol>
<li>After downloading, you now have full access to the LunchBox suite. Search for <em>&quot;Quad Grid&quot;</em> and select <em>&quot;LunchBox Quad Grid By Face&quot;</em>. Plug the parametric surface into the <em>surface</em> input and set the <em>U</em> and <em>V</em> divisions to <em>15</em>. You should see a quad-paneled surface in your Dynamo preview.</li>
</ol>
</blockquote>
<blockquote>
<p>If you're curious about its setup, you can double click on the <em>Lunch Box</em> node and see how it's made.</p>
</blockquote>
<blockquote>
<p>Back in Revit, let's take a quick look at the adaptive component we're using here. No need to follow along, but this is the roof panel we're going to instantiate. It is a four-point adaptive component which is a crude representation of an ETFE system. The aperture of the center void is on a parameter called <em>&quot;ApertureRatio&quot;</em>.</p>
</blockquote>
<blockquote>
<ol>
<li>We're about to instantiate a lot of geometry in Revit, so make sure to turn the Dynamo solver to <em>&quot;Manual&quot;</em>.</li>
<li>Add a <em>Family Types</em> node to the canvas and select <em>&quot;ROOF-PANEL-4PT&quot;</em>.</li>
<li>Add an <em>AdaptiveComponent.ByPoints</em> node to the canvas, connect <em>Panel Pts</em> from the <em>&quot;LunchBox Quad Grid by Face&quot;</em> output into the <em>points</em> input. Connect the <em>Family Types</em> node to the <em>familySymbol</em> input.</li>
<li>Hit <em>Run</em>. Revit will have to <em>think</em> for a bit while the geometry is being created. If it takes too long, reduce the <em>code block's '15'</em> to a lower number. This will reduce the number of panels on the roof.</li>
</ol>
</blockquote>
<p><em>Note: If Dynamo is taking a long time to calculate nodes, you may want to use the &quot;freeze&quot; node functionality in order to pause the execution of Revit operations while you develop your graph. For more information on freezing nodes, check out the &quot;Freezing&quot; section in the solids chapter.</em></p>
<blockquote>
<p>Back in Revit, we have the array of panels on the roof.</p>
</blockquote>
<blockquote>
<p>Zooming in, we can get a closer look at their surface qualities.</p>
</blockquote>
<h3 id="analysis"><a class="header" href="#analysis">Analysis</a></h3>
<blockquote>
<ol>
<li>Continuing from the previous step, let's go further and drive the aperture of each panel based on its exposure to the sun. Zooming into Revit and select one panel, we see in the properties bar that there is a parameter called <em>&quot;Aperture Ratio&quot;</em>. The family is setup so that the aperture ranges, roughly, from <em>0.05</em> to <em>0.45</em>.</li>
</ol>
</blockquote>
<blockquote>
<ol>
<li>If we turn on the solar path, we can see the current sun location in Revit.</li>
</ol>
</blockquote>
<blockquote>
<ol>
<li>We can reference this sun location using the <em>SunSettings.Current</em> node.</li>
</ol>
</blockquote>
<ol>
<li>Plug the Sun settings into <em>Sunsetting.SunDirection</em> to get the solar vector.</li>
<li>From the <em>Panel Pts</em> used to create the adaptive components, use <em>Plane.ByBestFitThroughPoints</em> to approximate a plane for the component.</li>
<li>Query the <em>normal</em> of this plane.</li>
<li>Use the <em>dot product</em> to calculate solar orientation. The dot product is a formula which determines how parallel or anti-parallel two vectors may be. So we're taking the plane normal of each adaptive component and comparing it to the solar vector to roughly simulate solar orientation.</li>
<li>Take the <em>absolute value</em> of the result. This ensures that the dot product is accurate if the plane normal is facing the reverse direction.</li>
<li>Hit <em>Run</em>.</li>
</ol>
<blockquote>
<ol>
<li>Looking at the <em>dot product</em>, we have a wide range of numbers. We want to use their relative distribution, but we need to condense the numbers into the appropriate range of the <em>&quot;Aperture Ratio&quot;</em> parameter we plan to edit.</li>
</ol>
</blockquote>
<ol>
<li>The <em>Math.RemapRange</em> is a great tool for this. It takes an input list and remaps its bounds into two target values.</li>
<li>Define the target values as <em>0.15</em> and <em>0.45</em> in a <em>code block</em>.</li>
<li>Hit <em>Run</em>.</li>
</ol>
<blockquote>
<ol>
<li>Connect the remapped values into a <em>Element.SetParameterByName</em> node.</li>
</ol>
</blockquote>
<ol>
<li>Connect the string <em>&quot;Aperture Ratio&quot;</em> into the <em>parameterName</em> input.</li>
<li>Connect the <em>adaptive components</em> into the <em>element</em> input.</li>
<li>Hit <em>Run</em>.</li>
</ol>
<blockquote>
<p>Back in Revit, from a distance we can make out the affect of the solar orientation on the aperture of the ETFE panels.</p>
</blockquote>
<blockquote>
<p>Zooming in, we see that the ETFE panels are more closed as the face the sun. Our target here is to reduce overheating from solar exposure. If we wanted to let in more light based on solar exposure, we just have to switch the domain on <em>Math.RemapRange</em>.</p>
</blockquote>
<div style="break-before: page; page-break-before: always;"></div><h1 id="documenting"><a class="header" href="#documenting">Documenting</a></h1>
<p>Editing parameters for documentation follows suit with the lessons learned in prior sections. In this section, we'll look at editing parameters which don't affect the geometric properties of an element, but instead prepare a Revit file for documentation.</p>
<h3 id="deviation"><a class="header" href="#deviation">Deviation</a></h3>
<p>In the exercise below, we'll use a basic deviation from plane node to create a Revit sheet for documentation. Each panel on our parametrically defined roof structure has a different value for deviation, and we want to call out the range of values using color and by scheduling out the adaptive points to hand off to a facade consultant, engineer, or contractor.</p>
<p><img src="7_dynamo_for_revit/images/6/deviation.jpg" alt="deviation" /></p>
<blockquote>
<p>The deviation from plane node will calculate the distance that the set of four points varies from the best-fit plane between them. This is a quick and easy way to study constructability.</p>
</blockquote>
<h2 id="exercise-8"><a class="header" href="#exercise-8">Exercise</a></h2>
<h3 id="part-i-setting-panels-aperture-ratio-based-on-deviation-from-plane-node"><a class="header" href="#part-i-setting-panels-aperture-ratio-based-on-deviation-from-plane-node">Part I: Setting Panels Aperture Ratio Based on Deviation From Plane Node</a></h3>
<blockquote>
<p>Download the example file by clicking on the link below.</p>
<p>A full list of example files can be found in the Appendix.</p>
</blockquote>
<p>{% file src=&quot;datasets/6/Revit-Documenting.zip&quot; %}</p>
<p>Start with the Revit file for this section (or continue from the previous section). This file has an array of ETFE panels on the roof. We'll reference these panels for this exercise.</p>
<p><img src="7_dynamo_for_revit/images/6/documenting-exerciseI-01.jpg" alt="" /></p>
<blockquote>
<ol>
<li>Add a <em>Family Types</em> node to the canvas and choose <em>&quot;ROOF-PANEL-4PT&quot;</em>.</li>
<li>Plug this node into a Select <em>All Elements of Family Type</em> node to get all of the elements from Revit into Dynamo.</li>
</ol>
</blockquote>
<p><img src="7_dynamo_for_revit/images/6/documenting-exerciseI-02.jpg" alt="" /></p>
<blockquote>
<ol>
<li>Query the location of adaptive points for each element with the <em>AdaptiveComponent.Locations</em> node.</li>
<li>Create a polygon from these four points with the <em>Polygon.ByPoints</em> node. Notice we now have an abstract version of the paneled system in Dynamo without having to import the full geometry of the Revit element.</li>
<li>Calculate planar deviation with the <em>Polygon.PlaneDeviation</em> node.</li>
</ol>
</blockquote>
<p>Just for kicks, like the previous exercise, let's set the aperture ratio of each panel based on its planar deviation.</p>
<p><img src="7_dynamo_for_revit/images/6/documenting-exerciseI-03.jpg" alt="" /></p>
<blockquote>
<ol>
<li>Add an <em>Element.SetParameterByName</em> node to the canvas and connect the adaptive components to the <em>element</em> input. Connect a <em>Code Block</em> reading <em>&quot;Aperture Ratio&quot;</em> into the <em>parameterName</em> input.</li>
<li>We cannot directly connect the deviation results into the value input because we need to remap the values to the parameter range.</li>
</ol>
</blockquote>
<p><img src="7_dynamo_for_revit/images/6/documenting-exerciseI-04.jpg" alt="" /></p>
<blockquote>
<ol>
<li>Using <em>Math.RemapRange</em>, remap the deviation values to a domain between 0.15 and 0_._45 by entering <code>0.15; 0.45;</code> into the <em>Code Block</em>.</li>
<li>Plug these results into the value input for <em>Element.SetParameterByName</em>.</li>
</ol>
</blockquote>
<p>Back in Revit we can <em>kind of</em> make sense of the change in aperture across the surface.</p>
<p><img src="7_dynamo_for_revit/images/6/13.jpg" alt="Exercise" /></p>
<p>Zooming in, it becomes more clear that the closed panels are weighted towards the corners of the surface. The open corners are towards the top. The corners represent areas of larger deviation while bulge has minimal curvature, so this makes sense.</p>
<p><img src="7_dynamo_for_revit/images/6/13a.jpg" alt="Exercise" /></p>
<h3 id="part-ii-color-and-documentation"><a class="header" href="#part-ii-color-and-documentation">Part II: Color and Documentation</a></h3>
<p>Setting the Aperture Ratio doesn't clearly demonstrate the deviation of panels on the roof, and we're also changing the geometry of the actual element. Suppose we just want to study the deviation from the standpoint of fabrication feasibility. It would be helpful to color the panels based on deviation range for our documentation. We can do that with the series of steps below, and in a very similar process to the steps above.</p>
<p><img src="7_dynamo_for_revit/images/6/documenting-exerciseII-01.jpg" alt="" /></p>
<blockquote>
<ol>
<li>Remove the <em>Element.SetParameterByName</em> and its input nodes and add <em>Element.OverrideColorInView</em>.</li>
<li>Add a <em>Color Range</em> node to the canvas and plug into the color input of <em>Element.OverrideColorInView</em>. We still have to connect the deviation values to the color range in order to create the gradient.</li>
<li>Hovering over the <em>value</em> input, we can see that the values for the input must be between <em>0</em> and <em>1</em> in order to map a color to each value. We need to remap the deviation values to this range.</li>
</ol>
</blockquote>
<p><img src="7_dynamo_for_revit/images/6/documenting-exerciseII-02.jpg" alt="" /></p>
<blockquote>
<ol>
<li>Using <em>Math.RemapRange</em>, remap the planar deviation values to a range between* 0* and <em>1</em> (note: you can use the <em>&quot;MapTo&quot;</em> node to define a source domain as well).</li>
<li>Plug the results into a <em>Color Range</em> node.</li>
<li>Notice our output is a range of colors instead of a range of numbers.</li>
<li>If you're set to Manual, hit <em>Run</em>. You should be able to get away with being set to Automatic from this point forward.</li>
</ol>
</blockquote>
<p>Back in Revit, we see a much more legible gradient which is representative of planar deviation based on our color range. But what if we want to customize the colors? Notice that the minimum deviation values are represented in red, which seems to be the opposite of what we'd expect. We want to have maximum deviation to be red, with minimum deviation represented by a calmer color. Let's go back to Dynamo and fix this.</p>
<p><img src="7_dynamo_for_revit/images/6/09.jpg" alt="" /></p>
<p><img src="7_dynamo_for_revit/images/6/documenting-exerciseII-04.jpg" alt="" /></p>
<blockquote>
<ol>
<li>Using a <em>code block</em>, add two numbers on two different lines: <code>0;</code> and <code>255;</code>.</li>
<li>Create a red and blue color by plugging the appropriate values into two <em>Color.ByARGB</em> nodes.</li>
<li>Create a list from these two colors.</li>
<li>Plug this list into the <em>colors</em> input of the <em>Color Range</em>, and watch the custom color range update.</li>
</ol>
</blockquote>
<p>Back in Revit, we can now make better sense of areas of maximum deviation in the corners. Remember, this node is for overriding a color in a view, so it can be really helpful if we had a particular sheet in the set of drawings which focuses on a particular type of analysis.</p>
<p><img src="7_dynamo_for_revit/images/6/07(6).jpg" alt="Exercise" /></p>
<h3 id="part-iii-scheduling"><a class="header" href="#part-iii-scheduling">Part III: Scheduling</a></h3>
<p>Selecting one ETFE panel in Revit, we see that there are four instance parameters, XYZ1, XYZ2, XYZ3, and XYZ4. These are all blank after they're created. These are text-based parameters and need values. We'll use Dynamo to write the adaptive point locations to each parameter. This helps interoperability if the geometry needs to be sent to an engineer of facade consultant.</p>
<p><img src="7_dynamo_for_revit/images/6/documenting-exerciseIII-01.jpg" alt="" /></p>
<p>In a sample sheet, we have a large, empty schedule. The XYZ parameters are shared parameters in the Revit file, which allows us to add them to the schedule.</p>
<p><img src="7_dynamo_for_revit/images/6/03(8).jpg" alt="Exercise" /></p>
<p>Zooming in, the XYZ parameters are yet to be filled in. The first two parameters are taken care of by Revit.</p>
<p><img src="7_dynamo_for_revit/images/6/02(9).jpg" alt="Exercise" /></p>
<p>To write in these values, we'll do a complex list operation. The graph itself is simple, but the concepts build heavily from the list mapping as discussed in the list chapter.</p>
<p><img src="7_dynamo_for_revit/images/6/documenting-exerciseIII-04.jpg" alt="" /></p>
<blockquote>
<ol>
<li>Select all the adaptive components with two nodes.</li>
<li>Extract the location of each point with <em>AdaptiveComponent.Locations</em>.</li>
<li>Convert these points to strings. Remember, the parameter is text-based so we need to input the correct data type.</li>
<li>Create a list of the four strings which define the parameters to change: <em>XYZ1, XYZ2, XYZ3,</em> and <em>XYZ4</em>.</li>
<li>Plug this list into the <em>parameterName</em> input of <em>Element.SetParameterByName</em>.</li>
<li>Connect <em>Element.SetParameterByName</em> into the the <em>combinator</em> input of <em>List.Combine.</em> Connect the <em>adaptive components</em> into <em>list1</em>. Connect <em>String</em> from Object into <em>list2</em>.</li>
</ol>
</blockquote>
<p>We are list mapping here, because we are writing four values for each element, which creates a complex data structure. The <em>List.Combine</em> node defines an operation one step down in the data hierarchy. This is why element and value inputs of <em>Element.SetParameterByName</em> are left blank. <em>List.Combine</em> is connecting the sublists of its inputs into the empty inputs of <em>Element.SetParameterByName</em>, based on the order in which they are connected.</p>
<p>Selecting a panel in Revit, we see now that we have string values for each parameter. Realistically, we would create a simpler format to write a point (X,Y,Z). This can be done with string operations in Dynamo, but we're bypassing that here to stay within the scope of this chapter.</p>
<p><img src="7_dynamo_for_revit/../.gitbook/assets/04(5).jpg" alt="" /></p>
<p>A view of the sample schedule with parameters filled in.</p>
<p><img src="7_dynamo_for_revit/../.gitbook/assets/01(9).jpg" alt="" /></p>
<p>Each ETFE panel now has the XYZ coordinates written for each adaptive point, representing the corners of each panel for fabrication.</p>
<p><img src="7_dynamo_for_revit/../.gitbook/assets/00(8).jpg" alt="Exercise" /></p>
<div style="break-before: page; page-break-before: always;"></div><h1 id="coding-in-dynamo"><a class="header" href="#coding-in-dynamo">Coding in Dynamo</a></h1>
<p>Dynamo is a great door to start coding for the AEC world. You may be interested in some of these sections to start your coding journey:</p>
<ul>
<li><a href="8_coding_in_dynamo/8-1_code-blocks-and-design-script/">Code Blocks and DesignScript</a></li>
<li><a href="8_coding_in_dynamo/8-2_geometry-with-design-script/">Geometry with DesignScript</a></li>
<li><a href="8_coding_in_dynamo/8-3_python/">Python</a></li>
</ul>
<p><img src="8_coding_in_dynamo/./images/image(17).png" alt="" /></p>
<div style="break-before: page; page-break-before: always;"></div><h1 id="code-blocks-and-designscript"><a class="header" href="#code-blocks-and-designscript">Code Blocks and DesignScript</a></h1>
<p>The code block is a unique feature in Dynamo that dynamically links a visual programming environment with a text-based one. The code-block has access to all of the Dynamo nodes and can define an entire graph in one node. Read this chapter closely, as the code block is a fundamental building block of Dynamo.</p>
<p><img src="8_coding_in_dynamo/8-1_code-blocks-and-design-script/../images/8-1/CodeBlocks-01.jpg" alt="" /></p>
<div style="break-before: page; page-break-before: always;"></div><h1 id="whats-a-code-block"><a class="header" href="#whats-a-code-block">What's a Code Block</a></h1>
<p>Code blocks are a window deep into DesignScript, the programming language at the heart of Dynamo. Built from scratch to support exploratory design workflows, DesignScript is a readable and concise language that offers both immediate feedback to small bits of code and also scales to large and complex interactions. DesignScript also forms the backbone of the engine that drives most aspects of Dynamo under the hood. Because nearly all of the functionality found in Dynamo nodes and interactions have a one-to-one relationship with the scripting language, there are unique opportunities to move between node-based interactions and scripting in a fluid way.  </p>
<p><img src="8_coding_in_dynamo/8-1_code-blocks-and-design-script/../images/8-1/1/codeblock.jpg" alt="" /></p>
<p>For beginners, nodes can be automatically converted to text syntax to aid in learning DesignScript or simply to reduce the size of larger sections of graphs. This is done using a process called &quot;Node to Code&quot;, which is outlined in more detail in the <a href="8_coding_in_dynamo/8-1_code-blocks-and-design-script/7-2_design-script-syntax.html">DesignScript Syntax section</a>. More experienced users can use Code Blocks to create customized mashups of existing functionality and user authored relationships using many standard coding paradigms. In between the beginner and advanced user, there are a huge number of shortcuts and code snippets that will accelerate your designs. While the term 'code block' may be a little intimidating to non-programmers, it is both easy to use and robust. A beginner can use the code block efficiently with minimal coding, and an advanced user can define scripted definitions to be recalled elsewhere in a Dynamo definition.</p>
<h3 id="code-block-a-brief-overview"><a class="header" href="#code-block-a-brief-overview">Code Block: A Brief Overview </a></h3>
<p>In short, code blocks are a text-scripting interface within a visual-scripting environment. They can be used as numbers, strings, formulas, and other data types. The code block is designed for Dynamo, so one can define arbitrary variables in the code block, and those variables are automatically added to the inputs of the node:</p>
<p>With code blocks, a user has the flexibility to decide how to specify inputs. Here are several different ways to make a basic point with coordinates <em>(10, 5, 0)</em>: </p>
<p><img src="8_coding_in_dynamo/8-1_code-blocks-and-design-script/../images/8-1/1/codeblockbriefoverview.jpg" alt="" /></p>
<p>As you learn more of the available functions in the library, you might even find that typing Point.ByCoordinates is faster than searching in the library and finding the proper node. When you type in <em>&quot;Point.&quot;</em> for example, Dynamo will display a list of possible functions to apply to a Point. This makes the scripting more intuitive and will help with learning how to apply functions in Dynamo.</p>
<h3 id="creating-code-block-nodes"><a class="header" href="#creating-code-block-nodes">Creating Code Block Nodes</a></h3>
<p>The code block can be found in <em>Core&gt;Input&gt;Actions&gt;Code Block</em>. But even faster, just double click on the canvas and the code block appears. This node is used so often, it's given full double-click privileges.</p>
<p><img src="8_coding_in_dynamo/8-1_code-blocks-and-design-script/../images/8-1/1/creatingcodeblocknodes.jpg" alt="" /></p>
<h3 id="numbers-strings-and-formulas"><a class="header" href="#numbers-strings-and-formulas">Numbers, Strings and Formulas</a></h3>
<p>Code blocks are also flexible towards data types. The user can quickly define numbers, strings, and formulas and the code block will deliver the desired output.</p>
<p>In the image below, you can see the &quot;old school&quot; way of doing things is a little long-winded: the user searches for the intended node in the interface, adds the node to the canvas, and then inputs the data. With code block, the user can double-click on the canvas to pull up the node, and type in the correct data type with basic syntax.</p>
<p>The number, string, and formula nodes are three examples of Dynamo nodes which are arguably obsolete in comparison to the code block.</p>
<p><img src="8_coding_in_dynamo/8-1_code-blocks-and-design-script/../images/8-1/1/oldschoolvscodeblocksnodes.jpg" alt="" /></p>
<blockquote>
<ol>
<li>&quot;Old-school&quot;</li>
<li>Code Blocks</li>
</ol>
</blockquote>
<div style="break-before: page; page-break-before: always;"></div><h1 id="designscript-syntax"><a class="header" href="#designscript-syntax">DesignScript Syntax</a></h1>
<p>You may have noticed a common theme in the names of nodes in Dynamo: each node uses a <em>&quot;.&quot;</em> syntax without spaces. This is because the text at the top of each node represents the actual syntax for scripting, and the <em>&quot;.&quot;</em> (or <em>dot notation</em>) separates an element from the possible methods we can call. This creates an easy translation from visual scripting to text-based scripting.</p>
<p><img src="8_coding_in_dynamo/8-1_code-blocks-and-design-script/../images/8-1/2/apple.jpg" alt="NodeNames" /></p>
<p>As a general analogy for the dot notation, how can we deal with a parametric apple in Dynamo? Below are a few methods we'll run on the apple before deciding to eat it. (Note: these are not actual Dynamo methods):</p>
<div class="table-wrapper"><table><thead><tr><th>Human Readible</th><th>Dot Notation</th><th>Output</th></tr></thead><tbody>
<tr><td>What color is the apple?</td><td>Apple.color</td><td>red</td></tr>
<tr><td>Is the apple ripe?</td><td>Apple.isRipe</td><td>true</td></tr>
<tr><td>How much does the apple weigh?</td><td>Apple.weight</td><td>6 oz.</td></tr>
<tr><td>Where did the apple come from?</td><td>Apple.parent</td><td>tree</td></tr>
<tr><td>What does the apple create?</td><td>Apple.children</td><td>seeds</td></tr>
<tr><td>Is this apple locally grown?</td><td>Apple.distanceFromOrchard</td><td>60 mi.</td></tr>
</tbody></table>
</div>
<p>I don't know about you, but judging by the outputs in the table above, this looks like one tasty apple. I think I'll <em>Apple.eat()</em> it.</p>
<h3 id="dot-notation-in-code-block"><a class="header" href="#dot-notation-in-code-block">Dot Notation in Code Block</a></h3>
<p>With the apple analogy in mind, let's look at <em>Point.ByCoordinates</em> and show how we can create a point using the code block.</p>
<p>The <em>code block</em> syntax <code>Point.ByCoordinates(0,10);</code> gives the same result as a <em>Point.ByCoordinates</em> node in Dynamo, except we're able to create a point using one node. This is more efficient than the connecting a separate node into <em>&quot;X&quot;</em> and <em>&quot;Y&quot;</em>.</p>
<p><img src="8_coding_in_dynamo/8-1_code-blocks-and-design-script/../images/8-1/2/codeblockdotnotation.jpg" alt="" /></p>
<blockquote>
<ol>
<li>By using <em>Point.ByCoordinates</em> in the code block, we are specifying the inputs in the same order as the out-of-the-box node <em>(X,Y)</em>.</li>
</ol>
</blockquote>
<h3 id="calling-nodes---create-actions-query"><a class="header" href="#calling-nodes---create-actions-query">Calling Nodes - Create, Actions, Query</a></h3>
<p>You can call any regular node in the library through a Code Block as long as the node isnt a special <em>UI node</em>: those with a special user interface feature. For instance, you can call <em>Circle.ByCenterPointRadius</em>, but it wouldnt make much sense to call a <em>Watch 3D</em> node.</p>
<p>Regular nodes (most of your library), generally come in three types. Youll find that the library is organized with these categories in mind. Methods, or nodes, of these three types are treated differently when invoked within a Code Block.</p>
<p><img src="8_coding_in_dynamo/8-1_code-blocks-and-design-script/../images/8-1/2/actioncreatequerycategory.jpg" alt="" /></p>
<blockquote>
<ol>
<li><strong>Create</strong> - Create (or construct) something</li>
<li><strong>Action</strong> - Perform an action on something</li>
<li><strong>Query</strong> - Get a property of something that already exists</li>
</ol>
</blockquote>
<h4 id="create-1"><a class="header" href="#create-1">Create</a></h4>
<p>The &quot;Create&quot; category will construct geometry from scratch. We input values in the code block from left-to-right. These inputs are in the same order as the inputs on the node from top-to-bottom.</p>
<p>Comparing the <em>Line.ByStartPointEndPoint</em> node and the corresponding syntax in the code block, we get the same results.</p>
<p><img src="8_coding_in_dynamo/8-1_code-blocks-and-design-script/../images/8-1/2/create.jpg" alt="" /></p>
<h4 id="action-3"><a class="header" href="#action-3">Action</a></h4>
<p>An action is something you do to an object of that type. Dynamo uses <em>dot notation</em>, common to many coding languages, to apply an action to a thing. Once you have the thing, type a dot then the name of the action. The action-type methods input is placed in parentheses just like create-type methods, only you dont have to specify the first input you see on the corresponding node. Instead, we specify the element upon which we are performing the action:</p>
<p><img src="8_coding_in_dynamo/8-1_code-blocks-and-design-script/../images/8-1/2/DesignScript-action.jpg" alt="" /></p>
<blockquote>
<ol>
<li>The <strong>Point.Add</strong> node is an action-type node, so the syntax works a little differently.</li>
<li>The inputs are (1) the <em>point</em>, and (2) the <em>vector</em> to add to it. In a <strong>Code Block</strong>, we've named the point (the thing) <em>pt</em>. To add a vector named *vec *to <em>pt</em>, we would write <em>pt.Add(vec)</em>, or: thing, dot, action. The Add action only has one input, or all the inputs from the <strong>Point.Add</strong> node minus the first one. The first input for the <strong>Point.Add</strong> node is the point itself.</li>
</ol>
</blockquote>
<h4 id="query-2"><a class="header" href="#query-2">Query</a></h4>
<p>Query-type methods get a property of an object. Since the object itself is the input, you dont have to specify any inputs. No parentheses required.</p>
<p><img src="8_coding_in_dynamo/8-1_code-blocks-and-design-script/../images/8-1/2/query.jpg" alt="" /></p>
<h3 id="how-about-lacing"><a class="header" href="#how-about-lacing">How About Lacing?</a></h3>
<p>Lacing with nodes is somewhat different from lacing with code block. With nodes, the user right clicks on the node and selects the lacing option to perform. With code block, the user has much more control as to how the data is structured. The code block shorthand method uses <em>replication guides</em> to set how several one-dimensional lists should be paired. Numbers in angled brackets &quot;&lt;&gt;&quot; define the hierarchy of the resulting nested list: &lt;1&gt;,&lt;2&gt;,&lt;3&gt;, etc.</p>
<p><img src="8_coding_in_dynamo/8-1_code-blocks-and-design-script/../images/8-1/2/DesignScript-lacing.jpg" alt="" /></p>
<blockquote>
<ol>
<li>In this example, we use a shorthand to define two ranges (more on shorthand in the following section of this chapter). In short, <code>0..1;</code> is equivalent to <code>{0,1}</code> and <code>-3..-7</code>is equivalent to <code>{-3,-4,-5,-6,-7}</code>. The result gives us lists of 2 x-values and 5 y-values. If we dont use replication guides with these mismatched lists, we get a list of two points, which is the length of the shortest list. Using replication guides, we can find all of the possible combinations of 2 and 5 coordinates (or, a Cross Product).</li>
<li>Using the syntax <strong>Point.ByCoordinates</strong><code>(x_vals&lt;1&gt;,y_vals&lt;2&gt;);</code> we get <em>two</em> lists with <em>five</em> items in each list.</li>
<li>Using the syntax <strong>Point.ByCoordinates</strong><code>(x_vals&lt;2&gt;,y_vals&lt;1&gt;);</code> we get <em>five</em> lists with <em>two</em> items in each list.</li>
</ol>
</blockquote>
<p>With this notation, we can also specify which list will be dominant: 2 lists of 5 things or 5 lists of 2 things. In the example, changing the order of the replication guides makes the result a list of rows of points or a list of columns of points in a grid.</p>
<h3 id="node-to-code"><a class="header" href="#node-to-code">Node to Code</a></h3>
<p>While the code block methods above may take some getting used to, there is a feature in Dynamo called &quot;Node to Code&quot; which will make the process easier. To use this feature, select an array of nodes in your Dynamo graph, right-click on the canvas and select &quot;Node to Code&quot;. Dynamo condenses these nodes into a code block, with all of the inputs and outputs! Not only is this a great tool for learning code block, but it also allows you to work with a more efficient and parametric Dynamo graph. We'll conclude the exercise below by using &quot;Node to Code&quot;, so don't miss it.</p>
<p><img src="8_coding_in_dynamo/8-1_code-blocks-and-design-script/../images/8-1/2/DesignScript-nodetocode.jpg" alt="" /></p>
<h2 id="exercise-surface-attractor"><a class="header" href="#exercise-surface-attractor">Exercise: Surface Attractor</a></h2>
<blockquote>
<p>Download the example file by clicking on the link below.</p>
<p>A full list of example files can be found in the Appendix.</p>
</blockquote>
<p>{% file src=&quot;../datasets/8-1/2/Dynamo-Syntax_Attractor-Surface.dyn&quot; %}</p>
<p>To show the power of code block, we are going to translate an existing attractor field definition into code block form. Working with an existing definition demonstrates how code block relates to visual scripting, and is helpful for learning DesignScript syntax.</p>
<p>Begin by recreating the definition in the image above (or by opening the sample file).</p>
<p><img src="8_coding_in_dynamo/8-1_code-blocks-and-design-script/../images/8-1/2/DesignScript-exercise-01.jpg" alt="" /></p>
<blockquote>
<ol>
<li>Notice that the lacing on <strong>Point.ByCoordinates</strong> has been set to <em>Cross Product</em>.</li>
<li>Each point in a grid is moved up in the Z direction based on its distance to the reference point.</li>
<li>A surface is recreated and thickened, creating a bulge in the geometry relative to the distance to the reference point.</li>
</ol>
</blockquote>
<p><img src="8_coding_in_dynamo/8-1_code-blocks-and-design-script/../images/8-1/2/DesignScript-exercise-02.jpg" alt="" /></p>
<blockquote>
<ol>
<li>Starting from the beginning, let's define the reference point first: <strong>Point.ByCoordinates</strong><code>(x,y,0);</code> We use the same <strong>Point.ByCoordinates</strong> syntax as is specified on the top of the reference point node.</li>
<li>The variables <em>x</em> and <em>y</em> are inserted into the <strong>Code Block</strong> so that we may update these dynamically with sliders.</li>
<li>Add some <em>sliders</em> to the <strong>Code Block</strong> inputs which range from -50 to 50. This way, we can span across the default Dynamo grid.</li>
</ol>
</blockquote>
<p><img src="8_coding_in_dynamo/8-1_code-blocks-and-design-script/../images/8-1/2/DesignScript-exercise-03.jpg" alt="" /></p>
<blockquote>
<ol>
<li>In the second line of the <strong>Code Block</strong>, we define a shorthand to replace the number sequence node: <code>coordsXY = (-50..50..#11);</code>We'll discuss this more in the next section. For now, notice that this shorthand is equivalent to the <strong>Number Sequence</strong> node in the visual script.</li>
</ol>
</blockquote>
<p><img src="8_coding_in_dynamo/8-1_code-blocks-and-design-script/../images/8-1/2/DesignScript-exercise-04.jpg" alt="" /></p>
<blockquote>
<ol>
<li>Now, we want to create a grid of points from the <em>coordsXY</em> sequence. To do this, we want to use the <strong>Point.ByCoordinates</strong> syntax, but also need to initiate a <em>Cross Product</em> of the list in the same manner that we did in the visual script. To do this, we type the line: <code>gridPts = Point.ByCoordinates(coordsXY&lt;1&gt;,coordsXY&lt;2&gt;,0);</code> The angled brackets denote the cross product reference.</li>
<li>Notice in the <strong>Watch3D</strong> node that we have a grid of points across the Dynamo grid.</li>
</ol>
</blockquote>
<p><img src="8_coding_in_dynamo/8-1_code-blocks-and-design-script/../images/8-1/2/DesignScript-exercise-05.jpg" alt="" /></p>
<blockquote>
<ol>
<li>Now for the tricky part: We want to move the grid of points up based on their distance to the reference point. First, let's call this new set of points <em>transPts</em>. And since a translation is an action on an existing element, rather than using <code>Geometry.Translate...</code> , we use <code>gridPts.Translate</code></li>
<li>Reading from the actual node on the canvas, we see that there are three inputs. The geometry to translate is already declared because we are performing the action on that element (with <em>gridPts.Translate</em>). The remaining two inputs will be inserted into the parentheses of the function: direction and <em>distance</em>.</li>
<li>The direction is simple enough, we use a <code>Vector.ZAxis()</code> to move vertically.</li>
<li>The distance between the reference point and each grid point still needs to be calculated, so we do this as an action to the reference point in the same manner: <code>refPt.DistanceTo(gridPts)</code></li>
<li>The final line of code gives us the translated points: <code>transPts=gridPts.Translate(Vector.ZAxis(),refPt.DistanceTo(gridPts));</code></li>
</ol>
</blockquote>
<p><img src="8_coding_in_dynamo/8-1_code-blocks-and-design-script/../images/8-1/2/DesignScript-exercise-06.jpg" alt="" /></p>
<blockquote>
<ol>
<li>We now have a grid of points with the appropriate data structure to create a Nurbs Surface. We construct the surface using <code>srf = NurbsSurface.ByControlPoints(transPts);</code></li>
</ol>
</blockquote>
<p><img src="8_coding_in_dynamo/8-1_code-blocks-and-design-script/../images/8-1/2/DesignScript-exercise-07.jpg" alt="" /></p>
<blockquote>
<ol>
<li>And finally, to add some depth to the surface, we construct a solid using <code>solid = srf.Thicken(5);</code> In this case we thickened the surface by 5 units in the code, but we could always declare this as a variable (calling it thickness for example) and then control that value with a slider.</li>
</ol>
</blockquote>
<h4 id="simplify-the-graph-with-node-to-code"><a class="header" href="#simplify-the-graph-with-node-to-code">Simplify the Graph with &quot;Node to Code&quot;</a></h4>
<p>The &quot;Node to Code&quot; feature automates the entire exercise that we just completed with the click of a button. Not only is this powerful for creating custom definitions and reusable code blocks, but it is also a really helpful tool to learn how to script in Dynamo:</p>
<p><img src="8_coding_in_dynamo/8-1_code-blocks-and-design-script/../images/8-1/2/DesignScript-exercise-08.jpg" alt="" /></p>
<blockquote>
<ol>
<li>Start with the existing visual script from step 1 of the exercise. Select all of the nodes, right click on the canvas, and select <em>&quot;Node to Code&quot;</em>. Simple as that.</li>
</ol>
</blockquote>
<p>Dynamo has automated a text based version of the visual graph, lacing and all. Test this out on your visual scripts and release the power of the code block!</p>
<p><img src="8_coding_in_dynamo/8-1_code-blocks-and-design-script/../images/8-1/2/DesignScript-exercise-09.jpg" alt="" /></p>
<div style="break-before: page; page-break-before: always;"></div><h1 id="shorthand"><a class="header" href="#shorthand">Shorthand</a></h1>
<h3 id="shorthand-1"><a class="header" href="#shorthand-1">Shorthand</a></h3>
<p>There are a few basic shorthand methods in the code block which, simply put, make data management <em>a lot</em> easier. We'll break down the basics below and discuss how this shorthand can be used both for creating and querying data.</p>
<div class="table-wrapper"><table><thead><tr><th><strong>Data Type</strong></th><th><strong>Standard Dynamo</strong></th><th><strong>Code Block Equilvalent</strong></th></tr></thead><tbody>
<tr><td>Numbers</td><td><img src="8_coding_in_dynamo/8-1_code-blocks-and-design-script/../images/8-1/3/01node-numbers.jpg" alt="" /></td><td><img src="8_coding_in_dynamo/8-1_code-blocks-and-design-script/../images/8-1/3/01codeblock-numbers.jpg" alt="" /></td></tr>
<tr><td>Strings</td><td><img src="8_coding_in_dynamo/8-1_code-blocks-and-design-script/../images/8-1/3/02node-string.jpg" alt="" /></td><td><img src="8_coding_in_dynamo/8-1_code-blocks-and-design-script/../images/8-1/3/02codeblock-string.jpg" alt="" /></td></tr>
<tr><td>Sequences</td><td><img src="8_coding_in_dynamo/8-1_code-blocks-and-design-script/../images/8-1/3/03node-sequence.jpg" alt="" /></td><td><img src="8_coding_in_dynamo/8-1_code-blocks-and-design-script/../images/8-1/3/03codeblock-sequence.jpg" alt="" /></td></tr>
<tr><td>Ranges</td><td><img src="8_coding_in_dynamo/8-1_code-blocks-and-design-script/../images/8-1/3/04node-range.jpg" alt="" /></td><td><img src="8_coding_in_dynamo/8-1_code-blocks-and-design-script/../images/8-1/3/04codeblock-range.jpg" alt="" /></td></tr>
<tr><td>Get Item at Index</td><td><img src="8_coding_in_dynamo/8-1_code-blocks-and-design-script/../images/8-1/3/05node-listgetitem.jpg" alt="" /></td><td><img src="8_coding_in_dynamo/8-1_code-blocks-and-design-script/../images/8-1/3/05codeblock-listgetitem.jpg" alt="" /></td></tr>
<tr><td>Create List</td><td><img src="8_coding_in_dynamo/8-1_code-blocks-and-design-script/../images/8-1/3/06node-listcreate.jpg" alt="" /></td><td><img src="8_coding_in_dynamo/8-1_code-blocks-and-design-script/../images/8-1/3/06codeblock-listcreate.jpg" alt="" /></td></tr>
<tr><td>Concatenate Strings</td><td><img src="8_coding_in_dynamo/8-1_code-blocks-and-design-script/../images/8-1/3/07node-stringconcat.jpg" alt="" /></td><td><img src="8_coding_in_dynamo/8-1_code-blocks-and-design-script/../images/8-1/3/07codeblock-stringconcat.jpg" alt="" /></td></tr>
<tr><td>Conditional Statements</td><td><img src="8_coding_in_dynamo/8-1_code-blocks-and-design-script/../images/8-1/3/08node-conditional.jpg" alt="" /></td><td><img src="8_coding_in_dynamo/8-1_code-blocks-and-design-script/../images/8-1/3/08codeblock-conditional.jpg" alt="" /></td></tr>
</tbody></table>
</div>
<h3 id="additional-syntax"><a class="header" href="#additional-syntax">Additional Syntax</a></h3>
<div class="table-wrapper"><table><thead><tr><th></th><th></th><th></th></tr></thead><tbody>
<tr><td><strong>Node(s)</strong></td><td><strong>Code Block Equivalent</strong></td><td><strong>Note</strong></td></tr>
<tr><td>Any operator (+, &amp;&amp;, &gt;=, Not, etc.)</td><td>+, &amp;&amp;, &gt;=, !, etc.</td><td>Note that Not becomes ! but the node is called Not to distinguish from Factorial</td></tr>
<tr><td>Boolean True</td><td>true;</td><td>Note lower case</td></tr>
<tr><td>Boolean False</td><td>false;</td><td>Note lower case</td></tr>
</tbody></table>
</div>
<h3 id="ranges-and-sequences"><a class="header" href="#ranges-and-sequences">Ranges and Sequences</a></h3>
<p>The method for defining ranges and sequences can be reduced to basic shorthand. Use the image below as a guide to the &quot;..&quot; syntax for defining a list of numerical data with code block. After getting the hang of this notation, creating numerical data is a really efficient process:</p>
<p><img src="8_coding_in_dynamo/8-1_code-blocks-and-design-script/../images/8-1/3/shorthand-rangesandsequences.jpg" alt="" /></p>
<blockquote>
<ol>
<li>In this example, a number range is replaced by basic <strong>Code Block</strong> syntax defining the <code>beginning..end..step-size;</code> . Represented numerically, we get: <code>0..10..1;</code></li>
<li>Notice that the syntax <code>0..10..1;</code> is equivalent to <code>0..10;</code> A step-size of 1 is the default value for the shorthand notation. So <code>0..10;</code> will give a sequence from 0 to 10 with a step-size of 1.</li>
<li>The <em>Sequence</em> example is similar, except we use a &quot;#&quot; to state that we want 15 values in the list, rather than a list which goes up to 15. In this case, we are defining: <code>beginning..#ofSteps..step-size:</code> The actual syntax for the sequence is <code>0..#15..2</code></li>
<li>Using the <em>&quot;#&quot;</em> from the previous step, we now place it in the <em>&quot;step-size&quot;</em> portion of the syntax. Now, we have a <em>number range</em> spanning from the <em>&quot;beginning&quot;</em> to the <em>&quot;end&quot;</em> and the <em>&quot;step-size&quot;</em> notation evenly distributes a number of values between the two: <code>beginning..end..#ofSteps</code></li>
</ol>
</blockquote>
<h3 id="advanced-ranges"><a class="header" href="#advanced-ranges">Advanced Ranges</a></h3>
<p>Creating advanced ranges allows us to work with list of lists in a simple fashion. In the examples below, we're isolating a variable from the primary range notation, and creating another range of that list.</p>
<p><img src="8_coding_in_dynamo/8-1_code-blocks-and-design-script/../images/8-1/3/shorthand-advancerange01.jpg" alt="" /></p>
<blockquote>
<p>1. Creating nested ranges, compare the notation with a &quot;#&quot; vs. the notation without. The same logic applies as in basic ranges, except it gets a little more complex.</p>
<p>2. We can define a sub-range at any place within the primary range, and notice that we can have two sub-ranges as well.</p>
<p>3. By controlling the &quot;end&quot; value in a range, we create more ranges of differing lengths.</p>
</blockquote>
<p>As a logic exercise, compare the two shorthands above and try to parse through how <em>subranges</em> and the <em>#</em> notation drive the resultant output.</p>
<p><img src="8_coding_in_dynamo/8-1_code-blocks-and-design-script/../images/8-1/3/shorthand-advancerange02.jpg" alt="" /></p>
<h3 id="make-lists-and-get-items-from-a-list"><a class="header" href="#make-lists-and-get-items-from-a-list">Make Lists and Get Items From a List</a></h3>
<p>In addition to making lists with shorthand, we can also create lists on the fly. These list can contain a wide range of element types and can also be queried (remember, lists are objects in themselves). To summarize, with code block you make lists and query items from a list with brackets (a.k.a. square brackets):</p>
<p><img src="8_coding_in_dynamo/8-1_code-blocks-and-design-script/../images/8-1/3/shorthand-list&amp;getfromlist01.jpg" alt="" /></p>
<blockquote>
<p>1. Create lists quickly with strings and query them using the item index.</p>
<p>2. Create lists with variables and query using the range shorthand notation.</p>
</blockquote>
<p>And managing with nested lists is a similar process. Be aware of the list order and recall using multiple sets of square brackets:</p>
<p><img src="8_coding_in_dynamo/8-1_code-blocks-and-design-script/../images/8-1/3/shorthand-list&amp;getfromlist02.jpg" alt="" /></p>
<blockquote>
<p>1. Define a list of lists.</p>
<p>2. Query a list with single bracket notation.</p>
<p>3. Query an item with double bracket notation.</p>
</blockquote>
<h2 id="exercise-sine-surface"><a class="header" href="#exercise-sine-surface">Exercise: Sine Surface</a></h2>
<blockquote>
<p>Download the example file by clicking on the link below.</p>
<p>A full list of example files can be found in the Appendix.</p>
</blockquote>
<p>{% file src=&quot;../datasets/8-1/3/Obsolete-Nodes_Sine-Surface.dyn&quot; %}</p>
<p>In this exercise, we will flex our new shorthand skills to create a funky-cool eggshell surface defined by ranges and formulas. During this exercise, notice how we use code block and existing Dynamo nodes in tandem: we use the code block for the heavy data lifting while the Dynamo nodes are visually laid out for legibility of the definition.</p>
<p>Start by creating a surface by connecting the nodes above. Instead of using a number node to define width and length, double click on the canvas and type <code>100;</code> into a code block</p>
<p><img src="8_coding_in_dynamo/8-1_code-blocks-and-design-script/../images/8-1/3/shorthand-exercise01.jpg" alt="" /></p>
<p><img src="8_coding_in_dynamo/8-1_code-blocks-and-design-script/../images/8-1/3/shorthand-exercise02.jpg" alt="" /></p>
<blockquote>
<ol>
<li>Define a range between 0 and 1 with 50 divisions by typing <code>0..1..#50</code> into a <strong>Code Block</strong>.</li>
<li>Connect the range into <strong>Surface.PointAtParameter</strong>, which takes u and v values between 0 and 1 across the surface. Remember to change the Lacing to Cross Product by right clicking on the <strong>Surface.PointAtParameter</strong> node.</li>
</ol>
</blockquote>
<p>In this step, we employ our first function to move the grid of points up in the Z. This grid will drive a generated surface based on the underlying function. Add new nodes as shown in image below</p>
<p><img src="8_coding_in_dynamo/8-1_code-blocks-and-design-script/../images/8-1/3/shorthand-exercise03.jpg" alt="" /></p>
<blockquote>
<ol>
<li>Rather than using a formula node, we use a <strong>Code Block</strong> with the line: <code>(0..Math.Sin(x*360)..#50)*5;</code>. To quickly break this down, we're defining a range with a formula inside of it. This formula is the Sine function. The sine function receives degree inputs in Dynamo, so in order to get a full sine wave, we multiple our x values (this is the range input from 0 to 1) by 360. Next we want the same number of divisions as control grid points for each row, so we define fifty subdivisions with #50. Finally, the multiplier of 5 simply increases the amplitude of translation so that we can see the effect in the Dynamo Preview.</li>
</ol>
</blockquote>
<p><img src="8_coding_in_dynamo/8-1_code-blocks-and-design-script/../images/8-1/3/shorthand-exercise04.jpg" alt="" /></p>
<blockquote>
<ol>
<li>While the previous <strong>Code Block</strong> worked fine, it wasn't completely parametric. We want to dynamically drive its parameters, so we'll replace the line from the previous step with <code>(0..Math.Sin(x*360*cycles)..#List.Count(x))*amp;</code>. This gives us the ability to define these values based on inputs.</li>
</ol>
</blockquote>
<p>By changing the sliders (ranging from 0 to 10), we get some interesting results.</p>
<p><img src="8_coding_in_dynamo/8-1_code-blocks-and-design-script/../images/8-1/3/shorthand-exercise05.gif" alt="" /></p>
<p><img src="8_coding_in_dynamo/8-1_code-blocks-and-design-script/../images/8-1/3/shorthand-exercise06.jpg" alt="" /></p>
<blockquote>
<ol>
<li>By doing a transpose on the number range, we reverse the direction of the curtain wave: <code>transposeList = List.Transpose(sineList);</code></li>
</ol>
</blockquote>
<p><img src="8_coding_in_dynamo/8-1_code-blocks-and-design-script/../images/8-1/3/shorthand-exercise07.jpg" alt="" /></p>
<blockquote>
<ol>
<li>We get a distorted eggshell surface when we add the sineList and the tranposeList: <code>eggShellList = sineList+transposeList;</code></li>
</ol>
</blockquote>
<p>Let's change the sliders values specified below to 'calm the waters' of this algorithm.</p>
<p><img src="8_coding_in_dynamo/8-1_code-blocks-and-design-script/../images/8-1/3/shorthand-exercise08.jpg" alt="" /></p>
<p>Last, let's query isolated parts of the data with the Code Block. To regenerate the surface with a specific range of points, add the code block above between the <strong>Geometry.Translate</strong> and <strong>NurbsSurface.ByPoints</strong> node. This has the line of text: <code>sineStrips[0..15..1];</code>. This will select the first 16 rows of points (out of 50). Recreating the surface, we can see that we've generated an isolated portion of the grid of points.</p>
<p><img src="8_coding_in_dynamo/8-1_code-blocks-and-design-script/../images/8-1/3/shorthand-exercise09.jpg" alt="" /></p>
<p><img src="8_coding_in_dynamo/8-1_code-blocks-and-design-script/../images/8-1/3/shorthand-exercise10.jpg" alt="" /></p>
<blockquote>
<ol>
<li>In the final step, to make this <strong>Code Block</strong> more parametric, we drive the query by using a slider ranging from 0 to 1. We do this with this line of code: <code>sineStrips[0..((List.Count(sineStrips)-1)*u)];</code>. This may seem confusing, but the line of code gives us a quick way to scale the length of the list into a multiplier between 0 and 1.</li>
</ol>
</blockquote>
<p>A value of <code>0.53</code> on the slider creates a surface just past the midpoint of the grid.</p>
<p><img src="8_coding_in_dynamo/8-1_code-blocks-and-design-script/../images/8-1/3/shorthand-exercise11.jpg" alt="" /></p>
<p>And as expected, a slider of <code>1</code> creates a surface from the full grid of points.</p>
<p><img src="8_coding_in_dynamo/8-1_code-blocks-and-design-script/../images/8-1/3/shorthand-exercise12.jpg" alt="" /></p>
<p>Looking at the visual graph, we can highlight the code blocks and see each of their functions.</p>
<p><img src="8_coding_in_dynamo/8-1_code-blocks-and-design-script/../images/8-1/3/shorthand-exercise13.jpg" alt="" /></p>
<blockquote>
<p>1. The first <strong>Code Block</strong> replaces the <strong>Number</strong> node.</p>
<p>2. The second <strong>Code Block</strong> replaces the <strong>Number Range</strong> node.</p>
<p>3. The third <strong>Code Block</strong> replaces the <strong>Formula</strong> node (as well as <strong>List.Transpose</strong>, <strong>List.Count</strong> and <strong>Number Range</strong>).</p>
<p>4. The fourth <strong>Code Block</strong> queries a list of lists, replacing the <strong>List.GetItemAtIndex</strong> node.</p>
</blockquote>
<div style="break-before: page; page-break-before: always;"></div><h1 id="functions"><a class="header" href="#functions">Functions</a></h1>
<p>Functions can be created in a code block and recalled elsewhere in a Dynamo definition. This creates another layer of control in a parametric file, and can be viewed as a text-based version of a custom node. In this case, the &quot;parent&quot; code block is readily accessible and can be located anywhere on the graph. No wires needed!</p>
<h3 id="parent"><a class="header" href="#parent">Parent</a></h3>
<p>The first line has the key word def, then the function name, then the names of inputs in parentheses. Braces define the body of the function. Return a value with return =. Code Blocks that define a function do not have input or output ports because they are called from other Code Blocks.</p>
<p><img src="8_coding_in_dynamo/8-1_code-blocks-and-design-script/../images/8-1/4/functionsparentdef.jpg" alt="" /></p>
<pre><code>/*This is a multi-line comment,
which continues for
multiple lines*/
def FunctionName(in1,in2)
{
//This is a comment
sum = in1+in2;
return sum;
};
</code></pre>
<h3 id="children"><a class="header" href="#children">Children</a></h3>
<p>Call the function with another Code Block in the same file by giving the name and the same number of arguments. It works just like the out-of-the-box nodes in your library.</p>
<p><img src="8_coding_in_dynamo/8-1_code-blocks-and-design-script/../images/8-1/4/functionschildrencalldef.jpg" alt="" /></p>
<pre><code>FunctionName(in1,in2);
</code></pre>
<h2 id="exercise-sphere-by-z"><a class="header" href="#exercise-sphere-by-z">Exercise: Sphere By Z</a></h2>
<blockquote>
<p>Download the example file by clicking on the link below.</p>
<p>A full list of example files can be found in the Appendix.</p>
</blockquote>
<p>{% file src=&quot;../datasets/8-1/4/Functions_SphereByZ.dyn&quot; %}</p>
<p>In this exercise, we will make a generic definition that will create spheres from an input list of points. The radius of these spheres are driven by the Z property of each point.</p>
<p>Let's begin with a number range of ten values spanning from 0 to 100. Plug these into a <strong>Point.ByCoordinates</strong> nodes to create a diagonal line.</p>
<p><img src="8_coding_in_dynamo/8-1_code-blocks-and-design-script/../images/8-1/4/functions-exercise-01.jpg" alt="" /></p>
<p>Create a <strong>Code Block</strong> and introduce our definition.</p>
<p><img src="8_coding_in_dynamo/8-1_code-blocks-and-design-script/../images/8-1/4/functions-exercise-02.jpg" alt="" /></p>
<blockquote>
<ol>
<li>
<p>Use these lines of code:</p>
<pre><code>def sphereByZ(inputPt)
{

};
</code></pre>
</li>
</ol>
<p>The <em>inputPt</em> is the name we've given to represent the points that will drive the function. As of now, the function isn't doing anything, but we'll build up this function in the steps to come.</p>
</blockquote>
<p><img src="8_coding_in_dynamo/8-1_code-blocks-and-design-script/../images/8-1/4/functions-exercise-03.jpg" alt="" /></p>
<blockquote>
<ol>
<li>Adding to the <strong>Code Block</strong> function, we place a comment and a <em>sphereRadius</em> variable which queries the <em>Z</em> position of each point. Remember, <em>inputPt.Z</em> does not need parenetheses as a method. This is a <em>query</em> of an existing element's properties, so no inputs are necessary:</li>
</ol>
<pre><code>def sphereByZ(inputPt,radiusRatio)
{
//get Z Value, ise ot to drive radius of sphere
sphereRadius=inputPt.Z;
};
</code></pre>
</blockquote>
<p><img src="8_coding_in_dynamo/8-1_code-blocks-and-design-script/../images/8-1/4/functions-exercise-04.jpg" alt="" /></p>
<blockquote>
<ol>
<li>Now, let's recall the function we've created in another <strong>Code Block</strong>. If we double-click on the canvas to create a new <em>code block</em>, and type in <em>sphereB</em>, we notice that Dynamo suggest the <em>sphereByZ</em> function that we've defined. Your function has been added to the intellisense library! Pretty cool.</li>
</ol>
</blockquote>
<p><img src="8_coding_in_dynamo/8-1_code-blocks-and-design-script/../images/8-1/4/functions-exercise-05.jpg" alt="" /></p>
<blockquote>
<ol>
<li>
<p>Now we call the function and create a variable called <em>Pt</em> to plug in the points created in the earlier steps:</p>
<pre><code>sphereByZ(Pt)
</code></pre>
</li>
<li>
<p>We notice from the output that we have all null values. Why is this? When we defined the function, we are calculating the <em>sphereRadius</em> variable, but we did not define what the function should <em>return</em> as an <em>output</em>. We can fix this in the next step.</p>
</li>
</ol>
</blockquote>
<p><img src="8_coding_in_dynamo/8-1_code-blocks-and-design-script/../images/8-1/4/functions-exercise-06.jpg" alt="" /></p>
<blockquote>
<ol>
<li>An important step, we need to define the output of the function by adding the line <code>return = sphereRadius;</code> to the <em>sphereByZ</em> function.</li>
<li>Now we see that the output of the Code Block gives us the Z coordinates of each point.</li>
</ol>
</blockquote>
<p>Let's create actual spheres now by editing the <em>Parent</em> function.</p>
<p><img src="8_coding_in_dynamo/8-1_code-blocks-and-design-script/../images/8-1/4/functions-exercise-07.jpg" alt="" /></p>
<blockquote>
<ol>
<li>We first define a sphere with the line of code: <code>sphere=Sphere.ByCenterPointRadius(inputPt,sphereRadius);</code></li>
<li>Next, we change the return value to be the <em>sphere</em> instead of the <em>sphereRadius</em>: <code>return = sphere;</code> This gives us some giant spheres in our Dynamo preview!</li>
</ol>
</blockquote>
<p><img src="8_coding_in_dynamo/8-1_code-blocks-and-design-script/../images/8-1/4/functions-exercise-08.jpg" alt="" /></p>
<blockquote>
<p>1. To temper the size of these spheres, let's update the sphereRadius value by adding a divider: <code>sphereRadius = inputPt.Z/20;</code> Now we can see the separate spheres and start to make sense of the relationship between radius and Z value.</p>
</blockquote>
<p><img src="8_coding_in_dynamo/8-1_code-blocks-and-design-script/../images/8-1/4/functions-exercise-09.jpg" alt="" /></p>
<blockquote>
<ol>
<li>On the <strong>Point.ByCoordinates</strong> node, by changing the lacing from Shortest List to Cross Product, we create a grid of points. The <em>sphereByZ</em> function is still in full effect, so the points all create spheres with radii based on Z values.</li>
</ol>
</blockquote>
<p><img src="8_coding_in_dynamo/8-1_code-blocks-and-design-script/../images/8-1/4/functions-exercise-10.jpg" alt="" /></p>
<blockquote>
<ol>
<li>And just to test the waters, we plug the original list of numbers into the X input for <strong>Point.ByCoordinates</strong>. We now have a cube of spheres.</li>
<li>Note: if this takes a long time to calculate on your computer, try to change <em>#10</em> to something like <em>#5</em>.</li>
</ol>
</blockquote>
<p>Remember, the <em>sphereByZ</em> function we've created is a generic function, so we can recall the helix from an earlier lesson and apply the function to it.</p>
<p><img src="8_coding_in_dynamo/8-1_code-blocks-and-design-script/../images/8-1/4/functions-exercise-11.jpg" alt="" /></p>
<p>One final step: let's drive the radius ratio with a user defined parameter. To do this, we need to create a new input for the function and also replace the <em>20</em> divider with a parameter.</p>
<p><img src="8_coding_in_dynamo/8-1_code-blocks-and-design-script/../images/8-1/4/functions-exercise-12.jpg" alt="" /></p>
<blockquote>
<ol>
<li>
<p>Update the <em>sphereByZ</em> definition to:</p>
<pre><code>def sphereByZ(inputPt,radiusRatio)
{
//get Z Value, use it to drive radius of sphere
sphereRadius=inputPt.Z/radiusRatio;
//Define Sphere Geometry
sphere=Sphere.ByCenterPointRadius(inputPt,sphereRadius);
//Define output for function
return sphere;
};
</code></pre>
</li>
<li>
<p>Update the children <strong>Code Block</strong> by adding a ratio variable to the input: <code>sphereByZ(Pt,ratio);</code> Plug a slider into the newly created <strong>Code Block</strong> input and vary the size of the radii based on the radius ratio.</p>
</li>
</ol>
</blockquote>
<div style="break-before: page; page-break-before: always;"></div><h1 id="geometry-with-designscript"><a class="header" href="#geometry-with-designscript">Geometry with DesignScript</a></h1>
<p>In this section, you will find a series of lessons on the creation of geometry with DesignScript. Follow along by copying the example DesignScript into Dynamo Code Blocks.</p>
<pre><code class="language-js">// copy this code into a Code Block
// to start writing DesignScript

x = &quot;Let's create some geometry!&quot;;
</code></pre>
<div style="break-before: page; page-break-before: always;"></div><h1 id="designscript-geometry-basics"><a class="header" href="#designscript-geometry-basics">DesignScript Geometry Basics</a></h1>
<h3 id="point-1"><a class="header" href="#point-1">Point</a></h3>
<p>The simplest geometrical object in the Dynamo standard geometry library is a point. All geometry is created using special functions called constructors, which each return a new instance of that particular geometry type. In Dynamo, constructors begin with the name of the objects type, in this case Point, followed by the method of construction. To create a three dimensional point specified by x, y, and z Cartesian coordinates, use the <em>ByCoordinates</em> constructor:</p>
<p><img src="8_coding_in_dynamo/8-2_geometry-with-design-script/../images/8-2/1/GeometryBasics_01.png" alt="" /></p>
<pre><code class="language-js">// create a point with the following x, y, and z
// coordinates:
x = 10;
y = 2.5;
z = -6;

p = Point.ByCoordinates(x, y, z);
</code></pre>
<p>Constructors in Dynamo are typically designated with the <em>By</em> prefix, and invoking these functions returns a newly created object of that type. This newly created object is stored in the variable named on the left side of the equal sign.</p>
<p>Most objects have many different constructors, and we can use the <em>BySphericalCoordinates</em> constructor to create a point lying on a sphere, specified by the spheres radius, a first rotation angle, and a second rotation angle (specified in degrees):</p>
<p><img src="8_coding_in_dynamo/8-2_geometry-with-design-script/../images/8-2/1/GeometryBasics_02.png" alt="" /></p>
<pre><code class="language-js">// create a point on a sphere with the following radius,
// theta, and phi rotation angles (specified in degrees)
radius = 5;
theta = 75.5;
phi = 120.3;
cs = CoordinateSystem.Identity();

p = Point.BySphericalCoordinates(cs, radius, theta,
    phi);
</code></pre>
<h3 id="from-point-to-line"><a class="header" href="#from-point-to-line">From Point to Line</a></h3>
<p>Points can be used to construct higher dimensional geometry such as lines. We can use the <em>ByStartPointEndPoint</em> constructor to create a Line object between two points:</p>
<p><img src="8_coding_in_dynamo/8-2_geometry-with-design-script/../images/8-2/1/GeometryBasics_03.png" alt="" /></p>
<pre><code class="language-js">// create two points:
p1 = Point.ByCoordinates(3, 10, 2);
p2 = Point.ByCoordinates(-15, 7, 0.5);

// construct a line between p1 and p2
l = Line.ByStartPointEndPoint(p1, p2);
</code></pre>
<h3 id="from-line-to-surface"><a class="header" href="#from-line-to-surface">From Line to Surface</a></h3>
<p>Similarly, lines can be used to create higher dimensional surface geometry, for instance using the <em>Loft</em> constructor, which takes a series of lines or curves and interpolates a surface between them.</p>
<p><img src="8_coding_in_dynamo/8-2_geometry-with-design-script/../images/8-2/1/GeometryBasics_04.png" alt="" /></p>
<pre><code class="language-js">// create points:
p1 = Point.ByCoordinates(3, 10, 2);
p2 = Point.ByCoordinates(-15, 7, 0.5);

p3 = Point.ByCoordinates(5, -3, 5);
p4 = Point.ByCoordinates(-5, -6, 2);

p5 = Point.ByCoordinates(9, -10, -2);
p6 = Point.ByCoordinates(-11, -12, -4);

// create lines:
l1 = Line.ByStartPointEndPoint(p1, p2);
l2 = Line.ByStartPointEndPoint(p3, p4);
l3 = Line.ByStartPointEndPoint(p5, p6);

// loft between cross section lines:
surf = Surface.ByLoft([l1, l2, l3]);
</code></pre>
<h3 id="from-surface-to-solid"><a class="header" href="#from-surface-to-solid">From Surface to Solid</a></h3>
<p>Surfaces too can be used to create higher dimensional solid geometry, for instance by thickening the surface by a specified distance. Many objects have functions attached to them, called methods, allowing the programmer to perform commands on that particular object. Methods common to all pieces of geometry include <em>Translate</em> and <em>Rotate</em>, which respectively translate (move) and rotate the geometry by a specified amount. Surfaces have a <em>Thicken</em> method, which take a single input, a number specifying the new thickness of the surface.</p>
<p><img src="8_coding_in_dynamo/8-2_geometry-with-design-script/../images/8-2/1/GeometryBasics_05.png" alt="" /></p>
<pre><code class="language-js">p1 = Point.ByCoordinates(3, 10, 2);
p2 = Point.ByCoordinates(-15, 7, 0.5);

p3 = Point.ByCoordinates(5, -3, 5);
p4 = Point.ByCoordinates(-5, -6, 2);

l1 = Line.ByStartPointEndPoint(p1, p2);
l2 = Line.ByStartPointEndPoint(p3, p4);

surf = Surface.ByLoft([l1, l2]);

// true indicates to thicken both sides of the Surface:
solid = surf.Thicken(4.75, true);
</code></pre>
<h3 id="intersect"><a class="header" href="#intersect">Intersect</a></h3>
<p><em>Intersection</em> commands can extract lower dimensional geometry from higher dimensional objects. This extracted lower dimensional geometry can form the basis for higher dimensional geometry, in a cyclic process of geometrical creation, extraction, and recreation. In this example, we use the generated Solid to create a Surface, and use the Surface to create a Curve.</p>
<p><img src="8_coding_in_dynamo/8-2_geometry-with-design-script/../images/8-2/1/GeometryBasics_06.png" alt="" /></p>
<pre><code class="language-js">p1 = Point.ByCoordinates(3, 10, 2);
p2 = Point.ByCoordinates(-15, 7, 0.5);

p3 = Point.ByCoordinates(5, -3, 5);
p4 = Point.ByCoordinates(-5, -6, 2);

l1 = Line.ByStartPointEndPoint(p1, p2);
l2 = Line.ByStartPointEndPoint(p3, p4);

surf = Surface.ByLoft([l1, l2]);

solid = surf.Thicken(4.75, true);

p = Plane.ByOriginNormal(Point.ByCoordinates(2, 0, 0),
    Vector.ByCoordinates(1, 1, 1));

int_surf = solid.Intersect(p);

int_line = int_surf.Intersect(Plane.ByOriginNormal(
    Point.ByCoordinates(0, 0, 0),
    Vector.ByCoordinates(1, 0, 0)));
</code></pre>
<div style="break-before: page; page-break-before: always;"></div><h1 id="geometric-primitives"><a class="header" href="#geometric-primitives">Geometric Primitives</a></h1>
<h3 id="coordinatesystem-1"><a class="header" href="#coordinatesystem-1">CoordinateSystem</a></h3>
<p>While Dynamo is capable of creating a variety of complex geometric forms, simple geometric primitives form the backbone of any computational design: either directly expressed in the final designed form, or used as scaffolding off of which more complex geometry is generated.</p>
<p>While not strictly a piece of geometry, the CoordinateSystem is an important tool for constructing geometry. A CoordinateSystem object keeps track of both position and geometric transformations such as rotation, sheer, and scaling.</p>
<p>Creating a CoordinateSystem centered at a point with x = 0, y = 0, z = 0, with no rotations, scaling, or sheering transformations, simply requires calling the Identity constructor:</p>
<p><img src="8_coding_in_dynamo/8-2_geometry-with-design-script/../images/8-2/2/GeometricPrimitives_01.png" alt="" /></p>
<pre><code class="language-js">// create a CoordinateSystem at x = 0, y = 0, z = 0,
// no rotations, scaling, or sheering transformations

cs = CoordinateSystem.Identity();
</code></pre>
<p>CoordinateSystems with geometric transformations are beyond the scope of this chapter, though another constructor allows you to create a coordinate system at a specific point, <em>CoordinateSystem.ByOriginVectors</em>:</p>
<p><img src="8_coding_in_dynamo/8-2_geometry-with-design-script/../images/8-2/2/GeometricPrimitives_02.png" alt="" /></p>
<pre><code class="language-js">// create a CoordinateSystem at a specific location,
// no rotations, scaling, or sheering transformations
x_pos = 3.6;
y_pos = 9.4;
z_pos = 13.0;

origin = Point.ByCoordinates(x_pos, y_pos, z_pos);
identity = CoordinateSystem.Identity();

cs = CoordinateSystem.ByOriginVectors(origin,
    identity.XAxis, identity.YAxis, identity.ZAxis);
</code></pre>
<h3 id="point-2"><a class="header" href="#point-2">Point</a></h3>
<p>The simplest geometric primitive is a Point, representing a zero-dimensional location in three-dimensional space. As mentioned earlier there are several different ways to create a point in a particular coordinate system: <em>Point.ByCoordinates</em> creates a point with specified x, y, and z coordinates; <em>Point.ByCartesianCoordinates</em> creates a point with a specified x, y, and z coordinates in a specific coordinate system; <em>Point.ByCylindricalCoordinates</em> creates a point lying on a cylinder with radius, rotation angle, and height; and <em>Point.BySphericalCoordinates</em> creates a point lying on a sphere with radius and two rotation angle.</p>
<p>This example shows points created at various coordinate systems:</p>
<p><img src="8_coding_in_dynamo/8-2_geometry-with-design-script/../images/8-2/2/GeometricPrimitives_03.png" alt="" /></p>
<pre><code class="language-js">// create a point with x, y, and z coordinates
x_pos = 1;
y_pos = 2;
z_pos = 3;

pCoord = Point.ByCoordinates(x_pos, y_pos, z_pos);

// create a point in a specific coordinate system
cs = CoordinateSystem.Identity();
pCoordSystem = Point.ByCartesianCoordinates(cs, x_pos,
    y_pos, z_pos);

// create a point on a cylinder with the following
// radius and height
radius = 5;
height = 15;
theta = 75.5;

pCyl = Point.ByCylindricalCoordinates(cs, radius, theta,
    height);

// create a point on a sphere with radius and two angles

phi = 120.3;

pSphere = Point.BySphericalCoordinates(cs, radius,
    theta, phi);
</code></pre>
<h3 id="line-2"><a class="header" href="#line-2">Line </a></h3>
<p>The next higher dimensional Dynamo primitive is a line segment, representing an infinite number of points between two end points. Lines can be created by explicitly stating the two boundary points with the constructor <em>Line.ByStartPointEndPoint</em>, or by specifying a start point, direction, and length in that direction, <em>Line.ByStartPointDirectionLength</em>.</p>
<p><img src="8_coding_in_dynamo/8-2_geometry-with-design-script/../images/8-2/2/GeometricPrimitives_04.png" alt="" /></p>
<pre><code class="language-js">p1 = Point.ByCoordinates(-2, -5, -10);
p2 = Point.ByCoordinates(6, 8, 10);

// a line segment between two points
l2pts = Line.ByStartPointEndPoint(p1, p2);

// a line segment at p1 in direction 1, 1, 1 with
// length 10
lDir = Line.ByStartPointDirectionLength(p1,
    Vector.ByCoordinates(1, 1, 1), 10);
</code></pre>
<h3 id="3d-primitives---cuboid-cone-cylinder-sphere-etc"><a class="header" href="#3d-primitives---cuboid-cone-cylinder-sphere-etc">3D Primitives - Cuboid, Cone, Cylinder, Sphere, etc</a></h3>
<p>Dynamo has objects representing the most basic types of geometric primitives in three dimensions: Cuboids, created with <em>Cuboid.ByLengths</em>; Cones, created with <em>Cone.ByPointsRadius</em> and <em>Cone.ByPointsRadii</em>; Cylinders, created with <em>Cylinder.ByRadiusHeight</em>; and Spheres, created with <em>Sphere.ByCenterPointRadius</em>.</p>
<p><img src="8_coding_in_dynamo/8-2_geometry-with-design-script/../images/8-2/2/GeometricPrimitives_05.png" alt="" /></p>
<pre><code class="language-js">// create a cuboid with specified lengths
cs = CoordinateSystem.Identity();

cub = Cuboid.ByLengths(cs, 5, 15, 2);

// create several cones
p1 = Point.ByCoordinates(0, 0, 10);
p2 = Point.ByCoordinates(0, 0, 20);
p3 = Point.ByCoordinates(0, 0, 30);

cone1 = Cone.ByPointsRadii(p1, p2, 10, 6);
cone2 = Cone.ByPointsRadii(p2, p3, 6, 0);

// make a cylinder
cylCS = cs.Translate(10, 0, 0);

cyl = Cylinder.ByRadiusHeight(cylCS, 3, 10);

// make a sphere
centerP = Point.ByCoordinates(-10, -10, 0);

sph = Sphere.ByCenterPointRadius(centerP, 5);
</code></pre>
<div style="break-before: page; page-break-before: always;"></div><h1 id="vector-math"><a class="header" href="#vector-math">Vector Math</a></h1>
<p>Objects in computational designs are rarely created explicitly in their final position and form, and are most often translated,rotated, and otherwise positioned based off of existing geometry. Vector math serves as a kind-of geometric scaffolding to give direction and orientation to geometry, as well as to conceptualize movements through 3D space without visual representation.</p>
<p>At its most basic, a vector represents a position in 3D space, and is often times thought of as the endpoint of an arrow from the position (0, 0, 0) to that position. Vectors can be created with the <em>ByCoordinates</em> constructor, taking the x, y, and z position of the newly created Vector object. Note that Vector objects are not geometric objects, and dont appear in the Dynamo window. However, information about a newly created or modified vector can be printed in the console window:</p>
<p><img src="8_coding_in_dynamo/8-2_geometry-with-design-script/../images/8-2/3/vectormath01.jpg" alt="" /></p>
<pre><code class="language-js">// construct a Vector object
v = Vector.ByCoordinates(1, 2, 3);

s = v.X + &quot; &quot; + v.Y + &quot; &quot; + v.Z;
</code></pre>
<p>A set of mathematical operations are defined on Vector objects, allowing you to add, subtract, multiply, and otherwise move objects in 3D space as you would move real numbers in 1D space on a number line.</p>
<h3 id="vector-addition"><a class="header" href="#vector-addition">Vector Addition</a></h3>
<p>Vector addition is defined as the sum of the components of two vectors, and can be thought of as the resulting vector if the two component vector arrows are placed tip to tail. Vector addition is performed with the <em>Add</em> method, and is represented by the diagram on the left.</p>
<p><img src="8_coding_in_dynamo/8-2_geometry-with-design-script/../images/8-2/3/VectorMath_02.png" alt="" /></p>
<pre><code class="language-js">a = Vector.ByCoordinates(5, 5, 0);
b = Vector.ByCoordinates(4, 1, 0);

// c has value x = 9, y = 6, z = 0
c = a.Add(b);
</code></pre>
<h3 id="vector-subtraction"><a class="header" href="#vector-subtraction">Vector Subtraction</a></h3>
<p>Similarly, two Vector objects can be subtracted from each other with the <em>Subtract</em> method. Vector subtraction can be thought of as the direction from first vector to the second vector.</p>
<p><img src="8_coding_in_dynamo/8-2_geometry-with-design-script/../images/8-2/3/VectorMath_03.png" alt="" /></p>
<pre><code class="language-js">a = Vector.ByCoordinates(5, 5, 0);
b = Vector.ByCoordinates(4, 1, 0);

// c has value x = 1, y = 4, z = 0
c = a.Subtract(b);
</code></pre>
<h3 id="vector-multiplication"><a class="header" href="#vector-multiplication">Vector Multiplication</a></h3>
<p>Vector multiplication can be thought of as moving the endpoint of a vector in its own direction by a given scale factor.</p>
<p><img src="8_coding_in_dynamo/8-2_geometry-with-design-script/../images/8-2/3/VectorMath_04.png" alt="" /></p>
<pre><code class="language-js">a = Vector.ByCoordinates(4, 4, 0);

// c has value x = 20, y = 20, z = 0
c = a.Scale(5);
</code></pre>
<h3 id="normalize-vector-length"><a class="header" href="#normalize-vector-length">Normalize Vector Length</a></h3>
<p>Often its desired when scaling a vector to have the resulting vectors length exactly equal to the scaled amount. This is easily achieved by first normalizing a vector, in other words setting the vectors length exactly equal to one.</p>
<p><img src="8_coding_in_dynamo/8-2_geometry-with-design-script/../images/8-2/3/vectormath05.jpg" alt="" /></p>
<pre><code class="language-js">a = Vector.ByCoordinates(1, 2, 3);
a_len = a.Length;

// set the a's length equal to 1.0
b = a.Normalized();
c = b.Scale(5);

// len is equal to 5
len = c.Length;
</code></pre>
<p>c still points in the same direction as a (1, 2, 3), though now it has length exactly equal to 5.</p>
<h3 id="cross-product-2"><a class="header" href="#cross-product-2">Cross Product</a></h3>
<p>Two additional methods exist in vector math which dont have clear parallels with 1D math, the cross product and dot product. The cross product is a means of generating a Vector which is orthogonal (at 90 degrees to) to two existing Vectors. For example, the cross product of the x and y axes is the z axis, though the two input Vectors dont need to be orthogonal to each other. A cross product vector is calculated with the <em>Cross</em> method.</p>
<p><img src="8_coding_in_dynamo/8-2_geometry-with-design-script/../images/8-2/3/VectorMath_06.png" alt="" /></p>
<pre><code class="language-js">a = Vector.ByCoordinates(1, 0, 1);
b = Vector.ByCoordinates(0, 1, 1);

// c has value x = -1, y = -1, z = 1
c = a.Cross(b);
</code></pre>
<h3 id="dot-product"><a class="header" href="#dot-product">Dot Product</a></h3>
<p>An additional, though somewhat more advanced function of vector math is the dot product. The dot product between two vectors is a real number (not a Vector object) that relates to, but is not exactly, the angle between two vectors. One useful properties of the dot product is that the dot product between two vectors will be 0 if and only if they are perpendicular. The dot product is calculated with the <em>Dot</em> method.</p>
<p><img src="8_coding_in_dynamo/8-2_geometry-with-design-script/../images/8-2/3/vectormath07.jpg" alt="" /></p>
<pre><code class="language-js">a = Vector.ByCoordinates(1, 2, 1);
b = Vector.ByCoordinates(5, -8, 4);

// d has value -7
d = a.Dot(b);
</code></pre>
<div style="break-before: page; page-break-before: always;"></div><h1 id="curves-interpolated-and-control-points"><a class="header" href="#curves-interpolated-and-control-points">Curves: Interpolated and Control Points</a></h1>
<p>There are two fundamental ways to create free-form curves in Dynamo: specifying a collection of Points and having Dynamo interpolate a smooth curve between them, or a more low-level method by specifying the underlying control points of a curve of a certain degree. Interpolated curves are useful when a designer knows exactly the form a line should take, or if the design has specific constraints for where the curve can and cannot pass through. Curves specified via control points are in essence a series of straight line segments which an algorithm smooths into a final curve form. Specifying a curve via control points can be useful for explorations of curve forms with varying degrees of smoothing, or when a smooth continuity between curve segments is required.</p>
<h3 id="interpolated-curve"><a class="header" href="#interpolated-curve">Interpolated Curve</a></h3>
<p>To create an interpolated curve, simply pass in a collection of Points to the <em>NurbsCurve.ByPoints</em> method.</p>
<p><img src="8_coding_in_dynamo/8-2_geometry-with-design-script/../images/8-2/4/Curves_01.png" alt="" /></p>
<pre><code class="language-js">num_pts = 6;

s = Math.Sin(0..360..#num_pts) * 4;

pts = Point.ByCoordinates(1..30..#num_pts, s, 0);

int_curve = NurbsCurve.ByPoints(pts);
</code></pre>
<p>The generated curve intersects each of the input points, beginning and ending at the first and last point in the collection, respectively. An optional periodic parameter can be used to create a periodic curve which is closed. Dynamo will automatically fill in the missing segment, so a duplicate end point (identical to the start point) isnt needed.</p>
<p><img src="8_coding_in_dynamo/8-2_geometry-with-design-script/../images/8-2/4/Curves_02.png" alt="" /></p>
<pre><code class="language-js">pts = Point.ByCoordinates(Math.Cos(0..350..#10),
    Math.Sin(0..350..#10), 0);

// create an closed curve
crv = NurbsCurve.ByPoints(pts, true);

// the same curve, if left open:
crv2 = NurbsCurve.ByPoints(pts.Translate(5, 0, 0),
    false);
</code></pre>
<h3 id="control-points-curve"><a class="header" href="#control-points-curve">Control Points Curve</a></h3>
<p>NurbsCurves are generated in much the same way, with input points represent the endpoints of a straight line segment, and a second parameter specifying the amount and type of smoothing the curve undergoes, called the degree.* A curve with degree 1 has no smoothing; it is a polyline.</p>
<p><img src="8_coding_in_dynamo/8-2_geometry-with-design-script/../images/8-2/4/Curves_03.png" alt="" /></p>
<pre><code class="language-js">num_pts = 6;

pts = Point.ByCoordinates(1..30..#num_pts,
    Math.Sin(0..360..#num_pts) * 4, 0);

// a B-Spline curve with degree 1 is a polyline
ctrl_curve = NurbsCurve.ByControlPoints(pts, 1);
</code></pre>
<p>A curve with degree 2 is smoothed such that the curve intersects and is tangent to the midpoint of the polyline segments:</p>
<p><img src="8_coding_in_dynamo/8-2_geometry-with-design-script/../images/8-2/4/Curves_04.png" alt="" /></p>
<pre><code class="language-js">num_pts = 6;

pts = Point.ByCoordinates(1..30..#num_pts,
    Math.Sin(0..360..#num_pts) * 4, 0);

// a B-Spline curve with degree 2 is smooth
ctrl_curve = NurbsCurve.ByControlPoints(pts, 2);
</code></pre>
<p>Dynamo supports NURBS (Non-uniform rational B-spline) curves up to degree 20, and the following script illustrates the effect increasing levels of smoothing has on the shape of a curve:</p>
<p><img src="8_coding_in_dynamo/8-2_geometry-with-design-script/../images/8-2/4/Curves_05.png" alt="" /></p>
<pre><code class="language-js">num_pts = 6;

pts = Point.ByCoordinates(1..30..#num_pts,
    Math.Sin(0..360..#num_pts) * 4, 0);

def create_curve(pts : Point[], degree : int)
{
	return = NurbsCurve.ByControlPoints(pts,
        degree);
}

ctrl_crvs = create_curve(pts, 1..11);
</code></pre>
<p>Note that you must have at least one more control point than the degree of the curve.</p>
<p>Another benefit of constructing curves by control vertices is the ability to maintain tangency between individual curve segments. This is done by extracting the direction between the last two control points, and continuing this direction with the first two control points of the following curve. The following example creates two separate NURBS curves which are nevertheless as smooth as one curve:</p>
<p><img src="8_coding_in_dynamo/8-2_geometry-with-design-script/../images/8-2/4/Curves_06.png" alt="" /></p>
<pre><code class="language-js">pts_1 = {};

pts_1[0] = Point.ByCoordinates(0, 0, 0);
pts_1[1] = Point.ByCoordinates(1, 1, 0);
pts_1[2] = Point.ByCoordinates(5, 0.2, 0);
pts_1[3] = Point.ByCoordinates(9, -3, 0);
pts_1[4] = Point.ByCoordinates(11, 2, 0);

crv_1 = NurbsCurve.ByControlPoints(pts_1, 3);

pts_2 = {};

pts_2[0] = pts_1[4];
end_dir = pts_1[4].Subtract(pts_1[3].AsVector());

pts_2[1] = Point.ByCoordinates(pts_2[0].X + end_dir.X,
    pts_2[0].Y + end_dir.Y, pts_2[0].Z + end_dir.Z);

pts_2[2] = Point.ByCoordinates(15, 1, 0);
pts_2[3] = Point.ByCoordinates(18, -2, 0);
pts_2[4] = Point.ByCoordinates(21, 0.5, 0);

crv_2 = NurbsCurve.ByControlPoints(pts_2, 3);
</code></pre>
<p>{% hint style=&quot;info&quot; %}
*This is a very simplified description of NURBS curve geometry, for a more accurate and detailed discussion see Pottmann, et al, 2007, in the references.
{% endhint %}</p>
<div style="break-before: page; page-break-before: always;"></div><h1 id="translation-rotation-and-other-transformations"><a class="header" href="#translation-rotation-and-other-transformations">Translation, Rotation, and Other Transformations</a></h1>
<p>Certain geometry objects can be created by explicitly stating x, y, and z coordinates in three-dimensional space. More often, however, geometry is moved into its final position using geometric transformations on the object itself or on its underlying CoordinateSystem.</p>
<h3 id="translation"><a class="header" href="#translation">Translation</a></h3>
<p>The simplest geometric transformation is a translation, which moves an object a specified number of units in the x, y, and z directions.</p>
<p><img src="8_coding_in_dynamo/8-2_geometry-with-design-script/../images/8-2/5/Transformations_01.png" alt="" /></p>
<pre><code class="language-js">// create a point at x = 1, y = 2, z = 3
p = Point.ByCoordinates(1, 2, 3);

// translate the point 10 units in the x direction,
// -20 in y, and 50 in z
// p2s new position is x = 11, y = -18, z = 53
p2 = p.Translate(10, -20, 50);
</code></pre>
<h3 id="rotation"><a class="header" href="#rotation">Rotation</a></h3>
<p>While all objects in Dynamo can be translated by appending the <em>.Translate</em> method to the end of the objects name, more complex transformations require transforming the object from one underlying CoordinateSystem to a new CoordinateSystem. For instance, to rotate an object 45 degrees around the x axis, we would transform the object from its existing CoordinateSystem with no rotation, to a CoordinateSystem which had been rotated 45 degrees around the x axis with the <em>.Transform</em> method:</p>
<p><img src="8_coding_in_dynamo/8-2_geometry-with-design-script/../images/8-2/5/Transformations_02.png" alt="" /></p>
<pre><code class="language-js">cube = Cuboid.ByLengths(CoordinateSystem.Identity(),
    10, 10, 10);

new_cs = CoordinateSystem.Identity();
new_cs2 = new_cs.Rotate(Point.ByCoordinates(0, 0),
    Vector.ByCoordinates(1,0,0.5), 25);

// get the existing coordinate system of the cube
old_cs = CoordinateSystem.Identity();

cube2 = cube.Transform(old_cs, new_cs2);
</code></pre>
<h3 id="scale"><a class="header" href="#scale">Scale</a></h3>
<p>In addition to being translated and rotated, CoordinateSystems can also be created scaled or sheared. A CoordinateSystem can be scaled with the <em>.Scale</em> method:</p>
<p><img src="8_coding_in_dynamo/8-2_geometry-with-design-script/../images/8-2/5/Transformations_03.png" alt="" /></p>
<pre><code class="language-js">cube = Cuboid.ByLengths(CoordinateSystem.Identity(),
    10, 10, 10);

new_cs = CoordinateSystem.Identity();
new_cs2 = new_cs.Scale(20);

old_cs = CoordinateSystem.Identity();

cube2 = cube.Transform(old_cs, new_cs2);
</code></pre>
<p>Sheared CoordinateSystems are created by inputting non-orthogonal vectors into the CoordinateSystem constructor.</p>
<p><img src="8_coding_in_dynamo/8-2_geometry-with-design-script/../images/8-2/5/Transformations_04.png" alt="" /></p>
<pre><code class="language-js">new_cs = CoordinateSystem.ByOriginVectors(
    Point.ByCoordinates(0, 0, 0),
	Vector.ByCoordinates(-1, -1, 1),
	Vector.ByCoordinates(-0.4, 0, 0));

old_cs = CoordinateSystem.Identity();

cube = Cuboid.ByLengths(CoordinateSystem.Identity(),
    5, 5, 5);

new_curves = cube.Transform(old_cs, new_cs);
</code></pre>
<p>Scaling and shearing are comparatively more complex geometric transformations than rotation and translation, so not every Dynamo object can undergo these transformations. The following table outlines which Dynamo objects can have non-uniformly scaled CoordinateSystems, and sheared CoordinateSystems.</p>
<div class="table-wrapper"><table><thead><tr><th>Class</th><th>Non-Uniformly Scaled CoordinateSystem</th><th>Sheared CoordinateSystem</th></tr></thead><tbody>
<tr><td>Arc</td><td>No</td><td>No</td></tr>
<tr><td>NurbsCurve</td><td>Yes</td><td>Yes</td></tr>
<tr><td>NurbsSurface</td><td>No</td><td>No</td></tr>
<tr><td>Circle</td><td>No</td><td>No</td></tr>
<tr><td>Line</td><td>Yes</td><td>Yes</td></tr>
<tr><td>Plane</td><td>No</td><td>No</td></tr>
<tr><td>Point</td><td>Yes</td><td>Yes</td></tr>
<tr><td>Polygon</td><td>No</td><td>No</td></tr>
<tr><td>Solid</td><td>No</td><td>No</td></tr>
<tr><td>Surface</td><td>No</td><td>No</td></tr>
<tr><td>Text</td><td>No</td><td>No</td></tr>
</tbody></table>
</div><div style="break-before: page; page-break-before: always;"></div><h1 id="surfaces-interpolated-control-points-loft-revolve"><a class="header" href="#surfaces-interpolated-control-points-loft-revolve">Surfaces: Interpolated, Control Points, Loft, Revolve</a></h1>
<p>The two-dimensional analog to a NurbsCurve is the NurbsSurface, and like the freeform NurbsCurve, NurbsSurfaces can be constructed with two basic methods: inputting a set of base points and having Dynamo interpolate between them, and explicitly specifying the control points of the surface. Also like freeform curves, interpolated surfaces are useful when a designer knows precisely the shape a surface needs to take, or if a design requires the surface to pass through constraint points. On the other hand, Surfaces created by control points can be more useful for exploratory designs across various smoothing levels.</p>
<h3 id="interpolated-surface"><a class="header" href="#interpolated-surface">Interpolated Surface</a></h3>
<p>To create an interpolated surface, simply generate a two-dimensional collection of points approximating the shape of a surface. The collection must be rectangular, that is, not jagged. The method <em>NurbsSurface.ByPoints</em> constructs a surface from these points.</p>
<p><img src="8_coding_in_dynamo/8-2_geometry-with-design-script/../images/8-2/6/Surfaces_01.png" alt="" /></p>
<pre><code class="language-js">// python_points_1 is a set of Points generated with
// a Python script found in Chapter 12, Section 10

surf = NurbsSurface.ByPoints(python_points_1);
</code></pre>
<h3 id="control-points-surface"><a class="header" href="#control-points-surface">Control Points Surface</a></h3>
<p>Freeform NurbsSurfaces can also be created by specifying underlying control points of a surface. Like NurbsCurves, the control points can be thought of as representing a quadrilateral mesh with straight segments, which, depending on the degree of the surface, is smoothed into the final surface form. To create a NurbsSurface by control points, include two additional parameters to <em>NurbsSurface.ByPoints</em>, indicating the degrees of the underlying curves in both directions of the surface.</p>
<p><img src="8_coding_in_dynamo/8-2_geometry-with-design-script/../images/8-2/6/Surfaces_02.png" alt="" /></p>
<pre><code class="language-js">// python_points_1 is a set of Points generated with
// a Python script found in Chapter 12, Section 10

// create a surface of degree 2 with smooth segments
surf = NurbsSurface.ByPoints(python_points_1, 2, 2);
</code></pre>
<p>We can increase the degree of the NurbsSurface to change the resulting surface geometry:</p>
<p><img src="8_coding_in_dynamo/8-2_geometry-with-design-script/../images/8-2/6/Surfaces_03.png" alt="" /></p>
<pre><code class="language-js">// python_points_1 is a set of Points generated with
// a Python script found in Chapter 12, Section 10

// create a surface of degree 6
surf = NurbsSurface.ByPoints(python_points_1, 6, 6);
</code></pre>
<h3 id="loft-surface"><a class="header" href="#loft-surface">Loft Surface</a></h3>
<p>Just as Surfaces can be created by interpolating between a set of input points, they can be created by interpolating between a set of base curves. This is called lofting. A lofted curve is created using the <em>Surface.ByLoft</em> constructor, with a collection of input curves as the only parameter.</p>
<p><img src="8_coding_in_dynamo/8-2_geometry-with-design-script/../images/8-2/6/Surfaces_04.png" alt="" /></p>
<pre><code class="language-js">// python_points_2, 3, and 4 are generated with
// Python scripts found in Chapter 12, Section 10

c1 = NurbsCurve.ByPoints(python_points_2);
c2 = NurbsCurve.ByPoints(python_points_3);
c3 = NurbsCurve.ByPoints(python_points_4);

loft = Surface.ByLoft([c1, c2, c3]);
</code></pre>
<h3 id="revolve-surface"><a class="header" href="#revolve-surface">Revolve Surface</a></h3>
<p>Surfaces of revolution are an additional type of surface created by sweeping a base curve around a central axis. If interpolated surfaces are the two-dimensional analog to interpolated curves, then surfaces of revolution are the two-dimensional analog to circles and arcs.</p>
<p>Surfaces of revolution are specified by a base curve, representing the edge of the surface; an axis origin, the base point of the surface; an axis direction, the central core direction; a sweep start angle; and a sweep end angle. These are used as the input to the <em>Surface.Revolve</em> constructor.</p>
<p><img src="8_coding_in_dynamo/8-2_geometry-with-design-script/../images/8-2/6/Surfaces_05.png" alt="" /></p>
<pre><code class="language-js">pts = {};
pts[0] = Point.ByCoordinates(4, 0, 0);
pts[1] = Point.ByCoordinates(3, 0, 1);
pts[2] = Point.ByCoordinates(4, 0, 2);
pts[3] = Point.ByCoordinates(4, 0, 3);
pts[4] = Point.ByCoordinates(4, 0, 4);
pts[5] = Point.ByCoordinates(5, 0, 5);
pts[6] = Point.ByCoordinates(4, 0, 6);
pts[7] = Point.ByCoordinates(4, 0, 7);

crv = NurbsCurve.ByPoints(pts);

axis_origin = Point.ByCoordinates(0, 0, 0);
axis = Vector.ByCoordinates(0, 0, 1);

surf = Surface.ByRevolve(crv, axis_origin, axis, 0,
    360);
</code></pre>
<div style="break-before: page; page-break-before: always;"></div><h1 id="geometric-parameterization"><a class="header" href="#geometric-parameterization">Geometric Parameterization</a></h1>
<p>In computational designs, curves and surfaces are frequently used as the underlying scaffold to construct subsequent geometry. In order for this early geometry to be used as a foundation for later geometry, the script must be able to extract qualities such as position and orientation across the entire area of the object. Both curves and surfaces support this extraction, and it is called parameterization.</p>
<p>All of the points on a curve can be thought of as having a unique parameter ranging from 0 to 1. If we were to create a NurbsCurve based off of several control or interpolated points, the first point would have the parameter 0, and the last point would have the parameter 1. Its impossible to know in advance what the exact parameter is any intermediate point is, which may sound like a severe limitation though is mitigated by a series of utility functions. Surfaces have a similar parameterization as curves, though with two parameters instead of one, called u and v. If we were to create a surface with the following points:</p>
<pre><code class="language-js">pts = [ [p1, p2, p3],
        [p4, p5, p6],
        [p7, p8, p9] ];
</code></pre>
<p>p1 would have parameter u = 0 v = 0, while p9 would have parameters u = 1 v = 1.</p>
<p>Parameterization isnt particularly useful when determining points used to generate curves, its main use is to determine the locations if intermediate points generated by NurbsCurve and NurbsSurface constructors.</p>
<p>Curves have a method <em>PointAtParameter</em>, which takes a single double argument between 0 and 1, and returns the Point object at that parameter. For instance, this script finds the Points at parameters 0, .1, .2, .3, .4, .5, .6, .7, .8, .9, and 1:</p>
<p><img src="8_coding_in_dynamo/8-2_geometry-with-design-script/../images/8-2/7/GeometricParameterization_01.png" alt="" /></p>
<pre><code class="language-js">pts = {};
pts[0] = Point.ByCoordinates(4, 0, 0);
pts[1] = Point.ByCoordinates(6, 0, 1);
pts[2] = Point.ByCoordinates(4, 0, 2);
pts[3] = Point.ByCoordinates(4, 0, 3);
pts[4] = Point.ByCoordinates(4, 0, 4);
pts[5] = Point.ByCoordinates(3, 0, 5);
pts[6] = Point.ByCoordinates(4, 0, 6);

crv = NurbsCurve.ByPoints(pts);

pts_at_param = crv.PointAtParameter(0..1..#11);

// draw Lines to help visualize the points
lines = Line.ByStartPointEndPoint(pts_at_param,
    Point.ByCoordinates(4, 6, 0));
</code></pre>
<p>Similarly, Surfaces have a method <em>PointAtParameter</em> which takes two arguments, the u and v parameter of the generated Point.</p>
<p>While extracting individual points on a curve and surface can be useful, scripts often require knowing the particular geometric characteristics at a parameter, such as what direction the Curve or Surface is facing. The method <em>CoordinateSystemAtParameter</em> finds not only the position but an oriented CoordinateSystem at the parameter of a Curve or Surface. For instance, the following script extracts oriented CoordinateSystems along a revolved Surface, and uses the orientation of the CoordinateSystems to generate lines which are sticking off normal to the surface:</p>
<p><img src="8_coding_in_dynamo/8-2_geometry-with-design-script/../images/8-2/7/GeometricParameterization_02.png" alt="" /></p>
<pre><code class="language-js">pts = {};
pts[0] = Point.ByCoordinates(4, 0, 0);
pts[1] = Point.ByCoordinates(3, 0, 1);
pts[2] = Point.ByCoordinates(4, 0, 2);
pts[3] = Point.ByCoordinates(4, 0, 3);
pts[4] = Point.ByCoordinates(4, 0, 4);
pts[5] = Point.ByCoordinates(5, 0, 5);
pts[6] = Point.ByCoordinates(4, 0, 6);
pts[7] = Point.ByCoordinates(4, 0, 7);

crv = NurbsCurve.ByPoints(pts);

axis_origin = Point.ByCoordinates(0, 0, 0);
axis = Vector.ByCoordinates(0, 0, 1);

surf = Surface.ByRevolve(crv, axis_origin, axis, 90,
    140);

cs_array = surf.CoordinateSystemAtParameter(
    (0..1..#7)&lt;1&gt;, (0..1..#7)&lt;2&gt;);

def make_line(cs : CoordinateSystem) {
	lines_start = cs.Origin;
    lines_end = cs.Origin.Translate(cs.ZAxis, -0.75);

    return = Line.ByStartPointEndPoint(lines_start,
        lines_end);
}

lines = make_line(Flatten(cs_array));
</code></pre>
<p>As mentioned earlier, parameterization is not always uniform across the length of a Curve or a Surface, meaning that the parameter 0.5 doesnt always correspond to the midpoint, and 0.25 doesnt always correspond to the point one quarter along a curve or surface. To get around this limitation, Curves have an additional set of parameterization commands which allow you to find a point at specific lengths along a Curve.</p>
<div style="break-before: page; page-break-before: always;"></div><h1 id="intersection-and-trim"><a class="header" href="#intersection-and-trim">Intersection and Trim</a></h1>
<p>Many of the examples so far have focused on the construction of higher dimensional geometry from lower dimensional objects. Intersection methods allow this higher dimensional geometry to generate lower dimensional objects, while the trim and select trim commands allow script to heavily modify geometric forms after theyve been created.</p>
<p>The <em>Intersect</em> method is defined on all pieces of geometry in Dynamo, meaning that in theory any piece of geometry can be intersected with any other piece of geometry. Naturally some intersections are meaningless, such as intersections involving Points, as the resulting object will always be the input Point itself. The other possible combinations of intersections between objects are outlined in the following chart. The following chart outlines the result of various intersection operations:</p>
<h3 id="intersect-1"><a class="header" href="#intersect-1"><strong>Intersect</strong></a></h3>
<div class="table-wrapper"><table><thead><tr><th><em>With:</em></th><th>Surface</th><th>Curve</th><th>Plane</th><th>Solid</th></tr></thead><tbody>
<tr><td><strong>Surface</strong></td><td>Curve</td><td>Point</td><td>Point, Curve</td><td>Surface</td></tr>
<tr><td><strong>Curve</strong></td><td>Point</td><td>Point</td><td>Point</td><td>Curve</td></tr>
<tr><td><strong>Plane</strong></td><td>Curve</td><td>Point</td><td>Curve</td><td>Curve</td></tr>
<tr><td><strong>Solid</strong></td><td>Surface</td><td>Curve</td><td>Curve</td><td>Solid</td></tr>
</tbody></table>
</div>
<p>The following very simple example demonstrates the intersection of a plane with a NurbsSurface. The intersection generates a NurbsCurve array, which can be used like any other NurbsCurve.</p>
<p><img src="8_coding_in_dynamo/8-2_geometry-with-design-script/../images/8-2/8/IntersectionAndTrim_01.png" alt="" /></p>
<pre><code class="language-js">// python_points_5 is a set of Points generated with
// a Python script found in Chapter 12, Section 10

surf = NurbsSurface.ByPoints(python_points_5, 3, 3);

WCS = CoordinateSystem.Identity();

pl = Plane.ByOriginNormal(WCS.Origin.Translate(0, 0,
    0.5), WCS.ZAxis);

// intersect surface, generating three closed curves
crvs = surf.Intersect(pl);

crvs_moved = crvs.Translate(0, 0, 10);
</code></pre>
<p>The <em>Trim</em> method is very similar to the Intersect method, in that it is defined for almost every piece of geometry. However, there are far more limitations on <em>Trim</em> than on <em>Intersect</em>.</p>
<h3 id="trim"><a class="header" href="#trim"><strong>Trim</strong></a></h3>
<div class="table-wrapper"><table><thead><tr><th></th><th><em>Using:</em> Point</th><th>Curve</th><th>Plane</th><th>Surface</th><th>Solid</th></tr></thead><tbody>
<tr><td><em>On:</em> Curve</td><td>Yes</td><td>No</td><td>No</td><td>No</td><td>No</td></tr>
<tr><td>Polygon</td><td>-</td><td>No</td><td>Yes</td><td>No</td><td>No</td></tr>
<tr><td>Surface</td><td>-</td><td>Yes</td><td>Yes</td><td>Yes</td><td>Yes</td></tr>
<tr><td>Solid</td><td>-</td><td>-</td><td>Yes</td><td>Yes</td><td>Yes</td></tr>
</tbody></table>
</div>
<p>Something to note about <em>Trim</em> methods is the requirement of a select point, a point which determines which geometry to discard, and which pieces to keep. Dynamo finds and discards the trimmed geometry closest to the select point.</p>
<p><img src="8_coding_in_dynamo/8-2_geometry-with-design-script/../images/8-2/8/IntersectionAndTrim_02.png" alt="" /></p>
<pre><code class="language-js">// python_points_5 is a set of Points generated with
// a Python script found in Chapter 12, Section 10

surf = NurbsSurface.ByPoints(python_points_5, 3, 3);

tool_pts = Point.ByCoordinates((-10..20..10)&lt;1&gt;,
    (-10..20..10)&lt;2&gt;, 1);

tool = NurbsSurface.ByPoints(tool_pts);

pick_point = Point.ByCoordinates(8, 1, 3);

result = surf.Trim(tool, pick_point);
</code></pre>
<div style="break-before: page; page-break-before: always;"></div><h1 id="geometric-booleans"><a class="header" href="#geometric-booleans">Geometric Booleans</a></h1>
<p><em>Intersect</em>, <em>Trim</em>, and <em>SelectTrim</em> are primarily used on lower-dimensional geometry such as Points, Curves, and Surfaces. Solid geometry on the other hand, has an additional set of methods for modifying form after their construction, both by subtracting material in a manner similar to <em>Trim</em> and combining elements together to form a larger whole.</p>
<h3 id="union"><a class="header" href="#union">Union</a></h3>
<p>The <em>Union</em> method takes two solid objects and creates a single solid object out of the space covered by both objects. The overlapping space between objects is combined into the final form. This example combines a Sphere and a Cuboid into a single solid Sphere-Cube shape:</p>
<p><img src="8_coding_in_dynamo/8-2_geometry-with-design-script/../images/8-2/9/GeometricBooleans_01.png" alt="" /></p>
<pre><code class="language-js">s1 = Sphere.ByCenterPointRadius(
    CoordinateSystem.Identity().Origin, 6);

s2 = Sphere.ByCenterPointRadius(
    CoordinateSystem.Identity().Origin.Translate(4, 0,
    0), 6);

combined = s1.Union(s2);
</code></pre>
<h3 id="difference"><a class="header" href="#difference">Difference</a></h3>
<p>The <em>Difference</em> method, like <em>Trim</em>, subtracts away the contents of the input tool solid from the base solid. In this example we carve out a small indentation out of a sphere:</p>
<p><img src="8_coding_in_dynamo/8-2_geometry-with-design-script/../images/8-2/9/GeometricBooleans_02.png" alt="" /></p>
<pre><code class="language-js">s = Sphere.ByCenterPointRadius(
    CoordinateSystem.Identity().Origin, 6);

tool = Sphere.ByCenterPointRadius(
    CoordinateSystem.Identity().Origin.Translate(10, 0,
    0), 6);

result = s.Difference(tool);
</code></pre>
<h3 id="intersect-2"><a class="header" href="#intersect-2">Intersect</a></h3>
<p>The <em>Intersect</em> method returns the overlapping Solid between two solid Inputs. In the following example, <em>Difference</em> has been changed to <em>Intersect</em>, and the resulting Solid is the missing void initially carved out:</p>
<p><img src="8_coding_in_dynamo/8-2_geometry-with-design-script/../images/8-2/9/GeometricBooleans_03.png" alt="" /></p>
<pre><code class="language-js">s = Sphere.ByCenterPointRadius(
    CoordinateSystem.Identity().Origin, 6);

tool = Sphere.ByCenterPointRadius(
    CoordinateSystem.Identity().Origin.Translate(10, 0,
    0), 6);

result = s.Intersect(tool);
</code></pre>
<div style="break-before: page; page-break-before: always;"></div><h1 id="python-point-generators"><a class="header" href="#python-point-generators">Python Point Generators</a></h1>
<p>The following Python scripts generate point arrays for several examples. They should be pasted into a Python Script node as follows:</p>
<p><img src="8_coding_in_dynamo/8-2_geometry-with-design-script/../images/8-2/10/pythonpoints01.jpg" alt="" /></p>
<p><strong>python_points_1</strong></p>
<pre><code class="language-python">out_points = []

for i in range(11):
	sub_points = []
	for j in range(11):
		z = 0
		if (i == 5 and j == 5):
			z = 1
		elif (i == 8 and j == 2):
			z = 1
		sub_points.append(Point.ByCoordinates(i, j, z))
	out_points.append(sub_points)

OUT = out_points
</code></pre>
<p><strong>python_points_2</strong></p>
<pre><code class="language-python">out_points = []

for i in range(11):
	z = 0
	if (i == 2):
		z = 1
	out_points.append(Point.ByCoordinates(i, 0, z))

OUT = out_points
</code></pre>
<p><strong>python_points_3</strong></p>
<pre><code class="language-python">out_points = []

for i in range(11):
	z = 0
	if (i == 7):
		z = -1
	out_points.append(Point.ByCoordinates(i, 5, z))

OUT = out_points
</code></pre>
<p><strong>python_points_4</strong></p>
<pre><code class="language-python">out_points = []

for i in range(11):
	z = 0
	if (i == 5):
		z = 1
	out_points.append(Point.ByCoordinates(i, 10, z))

OUT = out_points
</code></pre>
<p><strong>python_points_5</strong></p>
<pre><code class="language-python">out_points = []

for i in range(11):
	sub_points = []
	for j in range(11):
		z = 0
		if (i == 1 and j == 1):
			z = 2
		elif (i == 8 and j == 1):
			z = 2
		elif (i == 2 and j == 6):
			z = 2
		sub_points.append(Point.ByCoordinates(i, j, z))
	out_points.append(sub_points)

OUT = out_points
</code></pre>
<div style="break-before: page; page-break-before: always;"></div><h1 id="python"><a class="header" href="#python">Python</a></h1>
<p>Python is a widely-used programming language whose popularity has a lot to do with its style of syntax. It's highly readable, which makes it easier to learn than many other languages. Python supports modules and packages and can be embedded into existing applications. For information about how to get up and running with Python, a good resource is the <a href="https://www.python.org/about/gettingstarted/">&quot;Getting Started&quot;</a> page on <a href="https://www.python.org">Python.org</a></p>
<p><img src="https://files.gitbook.com/v0/b/gitbook-x-prod.appspot.com/o/spaces%2FY5ZuHF3yuXFWp1C46ZSo%2Fuploads%2Fgit-blob-6bd72c745aa81df1f25c09989fa19f672c631e59%2Fpythonlogo.jpg?alt=media" alt="" /></p>
<div style="break-before: page; page-break-before: always;"></div><h1 id="python-nodes"><a class="header" href="#python-nodes">Python Nodes</a></h1>
<p>Why would you use textual programming in Dynamo's visual programming environment? <a href="8_coding_in_dynamo/8-3_python/../../a_appendix/visual-programming-and-dynamo.html">Visual programming</a> has many advantages. It allows you to create programs without learning special syntax in an intuitive visual interface. However, a visual program can become cluttered, and can at times fall short in functionality. For example, Python offers much more achievable methods for writing conditional statements (if/then) and looping. Python is a powerful tool that can extend the capabilities of Dynamo and allow you to replace many nodes with a few concise lines of code.</p>
<p><strong>Visual Program:</strong></p>
<p><img src="8_coding_in_dynamo/8-3_python/../images/8-3/1/pythonnode-visualvstextualprogramming.jpg" alt="" /></p>
<p><strong>Textual Program:</strong></p>
<pre><code class="language-py">import clr
clr.AddReference('ProtoGeometry')
from Autodesk.DesignScript.Geometry import *

solid = IN[0]
seed = IN[1]
xCount = IN[2]
yCount = IN[3]

solids = []

yDist = solid.BoundingBox.MaxPoint.Y-solid.BoundingBox.MinPoint.Y
xDist = solid.BoundingBox.MaxPoint.X-solid.BoundingBox.MinPoint.X

for i in xRange:
	for j in yRange:
		fromCoord = solid.ContextCoordinateSystem
		toCoord = fromCoord.Rotate(solid.ContextCoordinateSystem.Origin,Vector.ByCoordinates(0,0,1),(90*(i+j%val)))
		vec = Vector.ByCoordinates((xDist*i),(yDist*j),0)
		toCoord = toCoord.Translate(vec)
		solids.append(solid.Transform(fromCoord,toCoord))

OUT = solids
</code></pre>
<h3 id="the-python-node"><a class="header" href="#the-python-node">The Python Node</a></h3>
<p>Like code blocks, Python nodes are a scripting interface within a visual programming environment. The Python node can be found under Script&gt;Editor&gt;Python Script in the library.</p>
<p><img src="8_coding_in_dynamo/8-3_python/../images/8-3/1/pythonnode-thepythonnode01.jpg" alt="" /></p>
<p>Double clicking the node opens the python script editor (you can also right click on the node and select <em>Edit...</em>). Youll notice some boilerplate text at the top, which is meant to help you reference the libraries youll need. Inputs are stored in the IN array. Values are returned to Dynamo by assigning them to the OUT variable</p>
<p><img src="8_coding_in_dynamo/8-3_python/../images/8-3/1/pythonnode-thepythonnode02.jpg" alt="" /></p>
<p>The Autodesk.DesignScript.Geometry library allows you to use dot notation similar to Code Blocks. For more information on Dynamo syntax, refer to <a href="8_coding_in_dynamo/8-3_python/../../coding-in-dynamo/7_code-blocks-and-design-script/7-2_design-script-syntax.html" title="mention">7-2_design-script-syntax.md</a> as well as the <a href="https://dynamobim.org/wp-content/links/DesignScriptGuide.pdf">DesignScript Guide</a> (To download this PDF doc, please right-click on link and choose &quot;Save link as...&quot;). Typing a geometry type such as 'Point.' will bring up a list of methods for creating and querying points.</p>
<p><img src="8_coding_in_dynamo/8-3_python/../images/8-3/1/pythonnode-thepythonnode03.jpg" alt="" /></p>
<blockquote>
<p>Methods include constructors such as <em>ByCoordinates</em>, actions like <em>Add</em>, and queries like <em>X</em>, <em>Y</em> and <em>Z</em> coordinates.</p>
</blockquote>
<h2 id="exercise-custom-node-with-python-script-for-creating-patterns-from-solid-module"><a class="header" href="#exercise-custom-node-with-python-script-for-creating-patterns-from-solid-module">Exercise: Custom Node with Python Script for Creating Patterns from Solid Module</a></h2>
<h3 id="part-i-setting-up-python-script"><a class="header" href="#part-i-setting-up-python-script">Part I: Setting Up Python Script</a></h3>
<blockquote>
<p>Download the example file by clicking on the link below.</p>
<p>A full list of example files can be found in the Appendix.</p>
</blockquote>
<p>{% file src=&quot;../datasets/8-2/1/Python_Custom-Node.dyn&quot; %}</p>
<p>In this example, we will write a python script that creates patterns from a solid module, and turn it into a custom node. First, lets create our solid module using Dynamo nodes.</p>
<p><img src="8_coding_in_dynamo/8-3_python/../images/8-3/1/pythonnode-exerciseptI-01.jpg" alt="" /></p>
<blockquote>
<ol>
<li><strong>Rectangle.ByWidthLength:</strong> Create a rectangle that will be the base of our solid.</li>
<li><strong>Surface.ByPatch:</strong> Connect the rectangle to the <em>closedCurve</em> input to create the bottom surface.</li>
</ol>
</blockquote>
<p><img src="8_coding_in_dynamo/8-3_python/../images/8-3/1/pythonnode-exerciseptI-02.jpg" alt="" /></p>
<blockquote>
<ol>
<li><strong>Geometry.Translate:</strong> Connect the rectangle to the <em>geometry</em> input to move it up, using a code block to specify the base thickness of our solid.</li>
<li><strong>Polygon.Points:</strong> Query the translated rectangle to extract the corner points.</li>
<li><strong>Geometry.Translate:</strong> Use a code block to create a list of four values corresponding to the four points, translating one corner of the solid up.</li>
<li><strong>Polygon.ByPoints:</strong> Use the translated points to reconstruct the top polygon.</li>
<li><strong>Surface.ByPatch:</strong> Connect the polygon to create the top surface.</li>
</ol>
</blockquote>
<p>Now that we have our top and bottom surfaces, lets loft between the two profiles to create the sides of the solid.</p>
<p><img src="8_coding_in_dynamo/8-3_python/../images/8-3/1/pythonnode-exerciseptI-03.jpg" alt="" /></p>
<blockquote>
<ol>
<li><strong>List.Create:</strong> Connect the bottom rectangle and the top polygon to the index inputs.</li>
<li><strong>Surface.ByLoft:</strong> Loft the two profiles to create the sides of the solid.</li>
<li><strong>List.Create:</strong> Connect the top, side, and bottom surfaces to the index inputs to create a list of surfaces.</li>
<li><strong>Solid.ByJoinedSurfaces:</strong> Join the surfaces to create the solid module.</li>
</ol>
</blockquote>
<p>Now that we have our solid, lets drop a Python Script node onto the workspace.</p>
<p><img src="8_coding_in_dynamo/8-3_python/../images/8-3/1/pythonnode-exerciseptI-04.jpg" alt="" /></p>
<blockquote>
<ol>
<li>To add additional inputs to the node, click the + icon on the node. The inputs are named IN[0], IN[1], etc. to indicate that they represent items in a list.</li>
</ol>
</blockquote>
<p>Lets start by defining our inputs and output. Double click the node to open the python editor. Follow the code below to modify the code in the editor.</p>
<p><img src="8_coding_in_dynamo/8-3_python/../images/8-3/1/pythonnode-exerciseptI-05.jpg" alt="" /></p>
<pre><code class="language-py"># Load the Python Standard and DesignScript Libraries
import sys
import clr
clr.AddReference('ProtoGeometry')
from Autodesk.DesignScript.Geometry import *

# The inputs to this node will be stored as a list in the IN variables.
#The solid module to be arrayed
solid = IN[0]

#A Number that determines which rotation pattern to use
seed = IN[1]

#The number of solids to array in the X and Y axes
xCount = IN[2]
yCount = IN[3]

#Create an empty list for the arrayed solids
solids = []

# Place your code below this line


# Assign your output to the OUT variable.
OUT = solids
</code></pre>
<p>This code will make more sense as we progress in the exercise. Next we need to think about what information is required in order to array our solid module. First, we will need to know the dimensions of the solid to determine the translation distance. Due to a bounding box bug, we will have to use the edge curve geometry to create a bounding box.</p>
<p><img src="8_coding_in_dynamo/8-3_python/../images/8-3/1/python07.png" alt="" /></p>
<blockquote>
<p>Take a look at the Python node in Dynamo. Notice that we're using the same syntax as we see in the titles of the nodes in Dynamo. Check out the commented code below.</p>
</blockquote>
<pre><code class="language-py"># Load the Python Standard and DesignScript Libraries
import sys
import clr
clr.AddReference('ProtoGeometry')
from Autodesk.DesignScript.Geometry import *

# The inputs to this node will be stored as a list in the IN variables.
#The solid module to be arrayed
solid = IN[0]

#A Number that determines which rotation pattern to use
seed = IN[1]

#The number of solids to array in the X and Y axes
xCount = IN[2]
yCount = IN[3]

#Create an empty list for the arrayed solids
solids = []
#Create an empty list for the edge curves
crvs = []

# Place your code below this line
#Loop through edges an append corresponding curve geometry to the list
for edge in solid.Edges:
    crvs.append(edge.CurveGeometry)

#Get the bounding box of the curves
bbox = BoundingBox.ByGeometry(crvs)

#Get the x and y translation distance based on the bounding box
yDist = bbox.MaxPoint.Y-bbox.MinPoint.Y
xDist = bbox.MaxPoint.X-bbox.MinPoint.X

# Assign your output to the OUT variable.
OUT = solids
</code></pre>
<p>Since we will be both translating and rotating the solid modules, lets use the Geometry.Transform operation. By looking at the Geometry.Transform node, we know that we will need a source coordinate system and a target coordinate system to transform the solid. The source is the context coordinate system of our solid, while the target will be a different coordinate system for each arrayed module. That means we will have to loop through the x and y values to transform the coordinate system differently each time.</p>
<p><img src="8_coding_in_dynamo/8-3_python/../images/8-3/1/pythonnode-exerciseptI-06.jpg" alt="" /></p>
<pre><code class="language-py"># Load the Python Standard and DesignScript Libraries
import sys
import clr
clr.AddReference('ProtoGeometry')
from Autodesk.DesignScript.Geometry import *

# The inputs to this node will be stored as a list in the IN variables.
#The solid module to be arrayed
solid = IN[0]

#A Number that determines which rotation pattern to use
seed = IN[1]

#The number of solids to array in the X and Y axes
xCount = IN[2]
yCount = IN[3]

#Create an empty list for the arrayed solids
solids = []
#Create an empty list for the edge curves
crvs = []

# Place your code below this line
#Loop through edges an append corresponding curve geometry to the list
for edge in solid.Edges:
    crvs.append(edge.CurveGeometry)

#Get the bounding box of the curves
bbox = BoundingBox.ByGeometry(crvs)

#Get the x and y translation distance based on the bounding box
yDist = bbox.MaxPoint.Y-bbox.MinPoint.Y
xDist = bbox.MaxPoint.X-bbox.MinPoint.X

#Get the source coordinate system
fromCoord = solid.ContextCoordinateSystem

#Loop through x and y
for i in range(xCount):
    for j in range(yCount):
        #Rotate and translate the coordinate system
        toCoord = fromCoord.Rotate(solid.ContextCoordinateSystem.Origin, Vector.ByCoordinates(0,0,1), (90*(i+j%seed)))
        vec = Vector.ByCoordinates((xDist*i),(yDist*j),0)
        toCoord = toCoord.Translate(vec)
        #Transform the solid from the source coord syste, to the target coord system and append to the list
        solids.append(solid.Transform(fromCoord,toCoord))

# Assign your output to the OUT variable.
OUT = solids
</code></pre>
<p>Click Run then Save the code. Connect the Python node with our existing script as following.</p>
<p><img src="8_coding_in_dynamo/8-3_python/../images/8-3/1/pythonnode-exerciseptI-07.jpg" alt="" /></p>
<blockquote>
<ol>
<li>Connect the output from <strong>Solid.ByJoinedSurfaces</strong> as the first input for the Python Node and use a Code Block to define the other inputs.</li>
<li>Create a <strong>Topology.Edges</strong> node and use the output from Python node as its input.</li>
<li>Finally, create an <strong>Edge.CurveGeometry</strong> node and use the output from Topology.Edges as its input.</li>
</ol>
</blockquote>
<p>Try changing the seed value to create different patterns. You can also change the parameters of the solid module itself for different effects.</p>
<p><img src="8_coding_in_dynamo/8-3_python/../images/8-3/1/python10.png" alt="" /></p>
<h3 id="part-ii-turn-your-python-script-node-into-custom-node"><a class="header" href="#part-ii-turn-your-python-script-node-into-custom-node">Part II: Turn Your Python Script Node into Custom Node</a></h3>
<p>Now that we have created a useful python script, lets save it as a custom node. Select the python script node, right-click on Workspace and select Create Custom Node.</p>
<p><img src="8_coding_in_dynamo/8-3_python/../images/8-3/1/pythonnode-exerciseptII-01.jpg" alt="" /></p>
<p>Assign a name, description and category.</p>
<p><img src="8_coding_in_dynamo/8-3_python/../images/8-3/1/pythonnode-exerciseptII-02.jpg" alt="" /></p>
<p>This will open a new workspace in which to edit the custom node.</p>
<p><img src="8_coding_in_dynamo/8-3_python/../images/8-3/1/pythonnode-exerciseptII-03.jpg" alt="" /></p>
<blockquote>
<ol>
<li><strong>Inputs:</strong> Change the input names to be more descriptive and add data types and default values.</li>
<li><strong>Output:</strong> Change the output name</li>
</ol>
</blockquote>
<p>Save the node as a .dyf file and you should see the custom node reflects the changes we just made.</p>
<p><img src="8_coding_in_dynamo/8-3_python/../images/8-3/1/pythonnode-exerciseptII-04.jpg" alt="" /></p>
<div style="break-before: page; page-break-before: always;"></div><h1 id="python-and-revit"><a class="header" href="#python-and-revit">Python and Revit</a></h1>
<h3 id="python-and-revit-1"><a class="header" href="#python-and-revit-1">Python and Revit</a></h3>
<p>Now that we've demonstrated how to use Python scripts in Dynamo, let's take a look at connecting Revit libraries into the scripting environment. Remember, we imported Python Standard and our Dynamo core nodes with the first four lines in the block of code below. To import the Revit nodes, Revit elements, and the Revit document manager, we only have to add a few more lines:</p>
<pre><code class="language-py">import sys
import clr
clr.AddReference('ProtoGeometry')
from Autodesk.DesignScript.Geometry import *

# Import RevitNodes
clr.AddReference(&quot;RevitNodes&quot;)
import Revit

# Import Revit elements
from Revit.Elements import *

# Import DocumentManager
clr.AddReference(&quot;RevitServices&quot;)
import RevitServices
from RevitServices.Persistence import DocumentManager

import System
</code></pre>
<p>This gives us access to the Revit API and offers custom scripting for any Revit task. By combining the process of visual programming with Revit API scripting, collaboration and tool development improve significantly. For example, a BIM manager and a schematic designer can work together on the same graph. In this collaboration, they can improve design and execution of the model.</p>
<p><img src="8_coding_in_dynamo/8-3_python/../images/8-3/2/python&amp;revit-01.jpg" alt="" /></p>
<h3 id="platform-specific-apis"><a class="header" href="#platform-specific-apis">Platform Specific APIs</a></h3>
<p>The plan behind the Dynamo Project is to widen the scope of platform implementation. As Dynamo adds more programs to the docket, users will gain access to platform-specific APIs from the Python scripting environment. While Revit is the case study for this section, we can anticipate more chapters in the future which offer comprehensive tutorials on scripting in other platforms. Additionally, there are many <a href="http://ironpython.net">IronPython</a> libraries accessible now which can be imported into Dynamo!</p>
<p>The examples below demonstrate ways to implement Revit-specific operations from Dynamo using Python. For a more detailed review on Python's relationship to Dynamo and Revit, refer to the <a href="https://github.com/DynamoDS/Dynamo/wiki/Python-0.6.3-to-0.7.x-Migration">Dynamo Wiki page</a>. Another useful resource for Python and Revit is the <a href="https://github.com/architecture-building-systems/revitpythonshell">Revit Python Shell </a>Project.</p>
<h2 id="exercise-1"><a class="header" href="#exercise-1">Exercise 1</a></h2>
<blockquote>
<p>Create a new Revit Project.</p>
<p>Download the example file by clicking on the link below.</p>
<p>A full list of example files can be found in the Appendix.</p>
</blockquote>
<p>{% file src=&quot;../datasets/8-2/2/Revit-Doc.dyn&quot; %}</p>
<p>In these exercises, we'll explore elementary Python scripts in Dynamo for Revit. The exercise will focus on dealing with Revit files and elements, as well as the communication between Revit and Dynamo.</p>
<p>This is a cut and dry method for retrieving the <em>doc</em>, <em>uiapp</em>, and <em>app</em> of the Revit file linked to your Dynamo sesson. Programmers who have worked in the Revit API before may notice the items in the watch list. If these items do not look familiar, that's okay; we'll be using other examples in the exercises below.</p>
<p>Here is how we're importing Revit Services and retrieving the document data in Dynamo.</p>
<p><img src="8_coding_in_dynamo/8-3_python/../images/8-3/2/python&amp;revit-exercise01-01.jpg" alt="" /></p>
<p>Take a look at the Python node in Dynamo. You can also find the code from below:</p>
<pre><code class="language-py"># Load the Python Standard and DesignScript Libraries
import sys
import clr

#Import DocumentManager
clr.AddReference(&quot;RevitServices&quot;)
import RevitServices
from RevitServices.Persistence import DocumentManager

#Place your code below this line
doc = DocumentManager.Instance.CurrentDBDocument
uiapp = DocumentManager.Instance.CurrentUIApplication
app = uiapp.Application

#Assign your output to the OUT variable
OUT = [doc,uiapp,app]
</code></pre>
<h2 id="exercise-2"><a class="header" href="#exercise-2">Exercise 2</a></h2>
<blockquote>
<p>Download the example file by clicking on the link below.</p>
<p>A full list of example files can be found in the Appendix.</p>
</blockquote>
<p>{% file src=&quot;../datasets/8-2/2/Revit-ReferenceCurve.dyn&quot; %}</p>
<p>In this exercise, we'll make a simple Model Curve in Revit using the Dynamo Python node.</p>
<p>Begin by creating a new Conceptual Mass family in Revit.</p>
<p><img src="8_coding_in_dynamo/8-3_python/../images/8-3/2/python&amp;revit-exercise02-01.jpg" alt="" /></p>
<p>Open the <em>Conceptual Mass Folder</em> and use the <em>Metric Mass.rft</em> template file.</p>
<p><img src="8_coding_in_dynamo/8-3_python/../images/8-3/2/python&amp;revit-exercise02-02.jpg" alt="" /></p>
<p>In Revit, use the keyboard shortcut <strong><code>un</code></strong> to bring up the Project Unit settings, change the length unit to meters.</p>
<p><img src="8_coding_in_dynamo/8-3_python/../images/8-3/2/python&amp;revit-exercise02-03.jpg" alt="" /></p>
<p>Launch Dynamo and create the set of nodes in the image below. We'll first create two reference points in Revit from Dynamo nodes.</p>
<p><img src="8_coding_in_dynamo/8-3_python/../images/8-3/2/python&amp;revit-exercise02-04.jpg" alt="" /></p>
<blockquote>
<ol>
<li>Create a <strong>Code Block</strong> and give it a value of <code>&quot;0;&quot;</code></li>
<li>Plug this value into a <strong>ReferencePoint.ByCoordinates</strong> node for X,Y, and Z inputs.</li>
<li>Create three sliders, ranging from -100 to 100 with a step size of 1.</li>
<li>Connect each slider to a <strong>ReferencePoint.ByCoordinates</strong> node.</li>
<li>Add a <strong>Python</strong> node to the workspace, click the &quot;+&quot; button on the node to add another input and plug the two references points into each input. Open the <strong>Python</strong> node.</li>
</ol>
</blockquote>
<p>Take a look at the Python node in Dynamo. Find the full code at the below.</p>
<p><img src="8_coding_in_dynamo/8-3_python/../images/8-3/2/python&amp;revit-exercise02-05.jpg" alt="" /></p>
<blockquote>
<ol>
<li><strong>System.Array:</strong> Revit needs a <strong>System Array</strong> as an input (rather than a Python list). This is just one more line of code, but paying attention to argument types will facilitate Python programming in Revit.</li>
</ol>
</blockquote>
<pre><code class="language-py">import sys
import clr

# Import RevitNodes
clr.AddReference(&quot;RevitNodes&quot;)
import Revit
#Import Revit elements
from Revit.Elements import *
import System

#define inputs
startRefPt = IN[0]
endRefPt = IN[1]

#define system array to match with required inputs
refPtArray = System.Array[ReferencePoint]([startRefPt, endRefPt])

#create curve by reference points in Revit
OUT = CurveByPoints.ByReferencePoints(refPtArray)
</code></pre>
<p>In Dynamo, we've created two reference points with a line connecting them using Python. Let's take this a little further in the next exercise.</p>
<p><img src="8_coding_in_dynamo/8-3_python/../images/8-3/2/python&amp;revit-exercise02-06.jpg" alt="" /></p>
<h2 id="exercise-3"><a class="header" href="#exercise-3">Exercise 3</a></h2>
<blockquote>
<p>Download the example file by clicking on the link below.</p>
<p>A full list of example files can be found in the Appendix.</p>
</blockquote>
<p>{% file src=&quot;../datasets/8-2/2/Revit-StructuralFraming.zip&quot; %}</p>
<p>This exercise keeps it simple, but drives home the topics of connecting data and geometry from Revit to Dynamo and back. Let's begin by opening Revit-StructuralFraming.rvt. Once opened, launch Dynamo and open the file Revit-StructuralFraming.dyn.</p>
<p><img src="8_coding_in_dynamo/8-3_python/../../.gitbook/assets/python&amp;revit-exercise03-01.jpg" alt="" /></p>
<p>This Revit file is about as basic as it gets. Two reference curves: one drawn on Level 1 and the other drawn on Level 2. We want to get these curves into Dynamo and maintain a live link.</p>
<p>In this file we have a set of nodes plugging into five inputs of a Python node.</p>
<p><img src="8_coding_in_dynamo/8-3_python/../images/8-3/2/python&amp;revit-exercise03-02.jpg" alt="" /></p>
<blockquote>
<ol>
<li><strong>Select Model Element Nodes:</strong> Hit the select button for each and select a corresponding curve in Revit.</li>
<li><strong>Code Block:</strong> using the syntax <code>0..1..#x;</code><em>,</em> connect an integer slider ranging from 0 to 20 into the <em>x</em> input. This designates the number of beams to draw between the two curves.</li>
<li><strong>Structural Framing Types:</strong> We'll choose the default W12x26 beam here from the dropdown menu.</li>
<li><strong>Levels:</strong> select &quot;Level 1&quot;.</li>
</ol>
</blockquote>
<p>This code in Python is a little more dense, but the comments within the code describe what's happening in the process</p>
<p><img src="8_coding_in_dynamo/8-3_python/../images/8-3/2/python&amp;revit-exercise03-03.jpg" alt="" /></p>
<pre><code class="language-py">import clr
#import Dynamo Geometry
clr.AddReference('ProtoGeometry')
from Autodesk.DesignScript.Geometry import *
# Import RevitNodes
clr.AddReference(&quot;RevitNodes&quot;)
import Revit
# Import Revit elements
from Revit.Elements import *
import System

#Query Revit elements and convert them to Dynamo Curves
crvA=IN[0].Curves[0]
crvB=IN[1].Curves[0]

#Define input Parameters
framingType=IN[3]
designLevel=IN[4]

#Define &quot;out&quot; as a list
OUT=[]

for val in IN[2]:
	#Define Dynamo Points on each curve
	ptA=Curve.PointAtParameter(crvA,val)
	ptB=Curve.PointAtParameter(crvB,val)
	#Create Dynamo line
	beamCrv=Line.ByStartPointEndPoint(ptA,ptB)
	#create Revit Element from Dynamo Curves
	beam = StructuralFraming.BeamByCurve(beamCrv,designLevel,framingType)
	#convert Revit Element into list of Dynamo Surfaces
	OUT.append(beam.Faces)
</code></pre>
<p>In Revit, we have an array of beams spanning the two curves as structural elements. Note: this isn't a realistic example...the structural elements are used as an example for native Revit instances created from Dynamo.</p>
<p>In Dynamo, we can see the results as well. The beams in the <strong>Watch3D</strong> node refer to the geometry queried from the Revit elements.</p>
<p><img src="8_coding_in_dynamo/8-3_python/../images/8-3/2/python&amp;revit-exercise03-05.jpg" alt="" /></p>
<p>Notice that we have a continuous process of translating data from the Revit Environment to the Dynamo Environment. In summary, here's how the process plays out:</p>
<ol>
<li>Select Revit element</li>
<li>Convert Revit element to Dynamo Curve</li>
<li>Divide Dynamo curve into a series of Dynamo points</li>
<li>Use the Dynamo points between two curves to create Dynamo lines</li>
<li>Create Revit beams by referencing Dynamo lines</li>
<li>Output Dynamo surfaces by querying the geometry of Revit beams</li>
</ol>
<p>This may sound a little heavy handed, but the script makes it as simple as editing the curve in Revit and re-running the solver (although you may have to delete the previous beams when doing so). <em>This is due to the fact that we are placing beams in python, thus breaking the association that OOTB nodes have.</em></p>
<p>With an update to the reference curves in Revit, we get a new array of beams.</p>
<p><img src="8_coding_in_dynamo/8-3_python/../images/8-3/2/python&amp;revit-ex03-06.gif" alt="" /></p>
<div style="break-before: page; page-break-before: always;"></div><h1 id="setup-your-own-python-template"><a class="header" href="#setup-your-own-python-template">Setup Your Own Python Template</a></h1>
<p>With Dynamo 2.0 we have the ability to specify a default template <code>(.py extension)</code> to use when opening the python window for the first time. This has been a long-desired request as this expedites the usage of Python within Dynamo. Having the ability to use a template allows us to have default imports ready to go when we want to develop a custom Python script.</p>
<p>The location for this template is in the <code>APPDATA</code> location for your Dynamo install.</p>
<p>This is typically as follows <code>( %appdata%\Dynamo\Dynamo Core\{version}\ )</code>.</p>
<p><img src="8_coding_in_dynamo/8-3_python/../images/8-3/3/pythontemplates-appdatafolderlocation.jpg" alt="" /></p>
<h3 id="setting-up-the-template"><a class="header" href="#setting-up-the-template">Setting Up The Template</a></h3>
<p>In order to utilize this functionality we need to add the following line in our <code>DynamoSettings.xml</code> file. <em>(Edit in notepad)</em></p>
<p><img src="8_coding_in_dynamo/8-3_python/../images/8-3/3/pythontemplates-dynamosettingsxmlfile.png" alt="" /></p>
<p>Where we see <code>&lt;PythonTemplateFilePath /&gt;</code>, we can simply replace this with the following:</p>
<pre><code>&lt;PythonTemplateFilePath&gt;
&lt;string&gt;C:\Users\CURRENTUSER\AppData\Roaming\Dynamo\Dynamo Core\2.0\PythonTemplate.py&lt;/string&gt;
&lt;/PythonTemplateFilePath&gt;
</code></pre>
<p>{% hint style=&quot;warning&quot; %}
<em>Note: replace CURRENTUSER with your username</em>
{% endhint %}</p>
<p>Next we need to build a template with the functionality that we want to use built-in. In our case lets embed the Revit related imports and some of the other typical items when working with Revit.</p>
<p>You can start a blank notepad document and paste the following code inside:</p>
<pre><code class="language-py">import clr

clr.AddReference('RevitAPI')
from Autodesk.Revit.DB import *
from Autodesk.Revit.DB.Structure import *

clr.AddReference('RevitAPIUI')
from Autodesk.Revit.UI import *

clr.AddReference('System')
from System.Collections.Generic import List

clr.AddReference('RevitNodes')
import Revit
clr.ImportExtensions(Revit.GeometryConversion)
clr.ImportExtensions(Revit.Elements)

clr.AddReference('RevitServices')
import RevitServices
from RevitServices.Persistence import DocumentManager
from RevitServices.Transactions import TransactionManager

doc = DocumentManager.Instance.CurrentDBDocument
uidoc=DocumentManager.Instance.CurrentUIApplication.ActiveUIDocument

#Preparing input from dynamo to revit
element = UnwrapElement(IN[0])

#Do some action in a Transaction
TransactionManager.Instance.EnsureInTransaction(doc)

TransactionManager.Instance.TransactionTaskDone()

OUT = element
</code></pre>
<p>Once that is done, save this file as <code>PythonTemplate.py</code> in the <code>APPDATA</code> location.</p>
<h3 id="python-script-behavior-after"><a class="header" href="#python-script-behavior-after">Python Script Behavior After</a></h3>
<p>A_f_ter the python template is defined, Dynamo will look for this each time a Python node is placed. If it is not found it will look like the default Python window.</p>
<p><img src="8_coding_in_dynamo/8-3_python/../images/8-3/3/pythontemplates-beforesetuptemplate.jpg" alt="" /></p>
<p>If the Python template is found (like our Revit one for example) you will see all of the default items you built in.</p>
<p><img src="8_coding_in_dynamo/8-3_python/../images/8-3/3/pythontemplates-aftersetuptemplate.jpg" alt="" /></p>
<p>Additional information regarding this great addition (by Radu Gidei) can be found here. https://github.com/DynamoDS/Dynamo/pull/8122</p>
<div style="break-before: page; page-break-before: always;"></div><h1 id="best-practices"><a class="header" href="#best-practices">Best Practices</a></h1>
<p>This part of the primer is organized in the spirit of a journal of best practices. It sheds light on several strategies that we have learned, through experience and research, to be most conducive to quality parametric workflows. As designers and programmers, our metric for quality is primarily concerned with the maintainability, dependability, usability, and efficiency of our tools. While these best practices have specific examples for either visual or text-based scripting, the principles are applicable to all programming environments and can inform many computational workflows.</p>
<p><img src="9_best_practices/./images/bestPractices.png" alt="" /></p>
<div style="break-before: page; page-break-before: always;"></div><h1 id="graph-strategies"><a class="header" href="#graph-strategies">Graph Strategies</a></h1>
<p>Prior to this chapter, the Primer has covered how to implement the powerful visual-scripting capabilities of Dynamo. A good understanding of these capabilities is a solid foundation and the first step in building robust visual programs. When we use our visual programs in the field, share them with colleagues, troubleshoot errors, or test limits we have additional issues to deal with. If someone else will be using your program or you are expecting to open it six months from now, it needs to have an immediate graphic and logical clarity. Dynamo has many tools to manage the complexity of your program, and this chapter will give guidelines on when to use them.</p>
<p><img src="9_best_practices/images/1/cad-chart-visual.jpg" alt="groups" /></p>
<h2 id="reduce-complexity"><a class="header" href="#reduce-complexity">Reduce Complexity</a></h2>
<p>As you develop your Dynamo graph and test ideas, it can quickly grow in size and complexity. While it is important that you create a functioning program, it is equally important to make it as simple as possible. Not only will your graph run faster and more predictably, you along with other users will understand its logic later on. The following are several ways that will help you clarify the logic of your graph.</p>
<h3 id="modularize-with-groups"><a class="header" href="#modularize-with-groups"><strong>Modularize with Groups</strong></a></h3>
<ul>
<li>Groups allow you to <strong>create functionally distinct parts</strong> as you build a program</li>
<li>Groups allow you to <strong>move large parts of the program</strong> around while maintaining modularity and alignment</li>
<li>You can change the <strong>color of the group to differentiate</strong> what Groups are doing (inputs vs functions)</li>
<li>You can use groups to start <strong>organizing your graph to streamline Custom Node creation</strong></li>
</ul>
<p><img src="9_best_practices/images/1/graphstrategy2.png" alt="" /></p>
<blockquote>
<p>The colors in this program identify the purpose of each group. This strategy can be used to create hierarchy in any graphic standards or templates you develop.</p>
<ol>
<li>Function group (blue)</li>
<li>Input group (orange)</li>
<li>Script group (green)</li>
</ol>
<p>For how to use Groups, refer to <a href="http://primer.dynamobim.org/en/03_Anatomy-of-a-Dynamo-Definition/3-4_best_practices.html">Managing Your Program</a>.</p>
</blockquote>
<h3 id="develop-efficiently-with-code-blocks"><a class="header" href="#develop-efficiently-with-code-blocks"><strong>Develop efficiently with Code Blocks</strong></a></h3>
<ul>
<li>At times, you can use a Code Block to <strong>type a number or node method faster than searching</strong> (Point.ByCoordinates, Number, String, Formula)</li>
<li>Code Blocks are useful <strong>when you want to define custom functions in DesignScript to reduce the number of nodes in a graph</strong></li>
</ul>
<p><img src="9_best_practices/images/1/graphstrategy3(1).png" alt="" /></p>
<blockquote>
<p>Both 1 and 2 perform the same function. It was much faster to write a few lines of code than it was to search for and add each node individually. The code block is also far more concise.</p>
<ol>
<li>Design Script written in Code Block</li>
<li>Equivalent program in nodes</li>
</ol>
<p>For how to use Code Block, refer to <a href="9_best_practices/../coding-in-dynamo/7_code-blocks-and-design-script/7-1_what-is-a-code-block.html">What's a Code Block</a>.</p>
</blockquote>
<h3 id="condense-with-node-to-code"><a class="header" href="#condense-with-node-to-code"><strong>Condense with Node to Code</strong></a></h3>
<ul>
<li>You can <strong>reduce the complexity of a graph by using Node to Code</strong> which will take a collection of simple nodes and write their corresponding DesignScript in a single Code Block</li>
<li>Node to Code can** condense code without eliminating the programs clarity**</li>
<li>The following are the <strong>pros</strong> of using Node to Code:
<ul>
<li>Easily condenses code into one component that is still editable</li>
<li>Can simplify a significant portion of the graph</li>
<li>Useful if the mini-program will not often be edited</li>
<li>Useful for incorporating other code block functionality, like functions</li>
</ul>
</li>
<li>The following are the <strong>cons</strong> of using Node to Code:
<ul>
<li>Generic naming makes it less legible</li>
<li>More difficult to understand for other users</li>
<li>No easy way to return to the visual programming version</li>
</ul>
</li>
</ul>
<p><img src="9_best_practices/images/1/graphstrategy3_1.png" alt="" /></p>
<blockquote>
<ol>
<li>Existing program</li>
<li>Code Block created from Node to Code</li>
</ol>
<p>For how to use Node to Code, refer to <a href="9_best_practices/../coding-in-dynamo/7_code-blocks-and-design-script/7-2_design-script-syntax.html#node-to-code">Design Script Syntax</a>.</p>
</blockquote>
<h3 id="access-data-flexibly-with-listlevel"><a class="header" href="#access-data-flexibly-with-listlevel"><strong>Access data flexibly with List@Level</strong></a></h3>
<ul>
<li>Using List@Level can help you <strong>reduce the complexity of your graph by replacing List.Map and List.Combine nodes</strong> which might occupy a considerable amount of canvas space</li>
<li>List@Level provides you with a** quicker way than List.Map/List.Combine to construct node logic** by allowing you to access data at any level in a list right from the input port of a node</li>
</ul>
<p><img src="9_best_practices/images/1/graphstrategy4(1)(1).png" alt="" /></p>
<blockquote>
<p>We can verify how many True values BoundingBox.Contains is returning and in which lists by activating List@Level for CountTrue's &quot;list&quot; input. List@Level allows the user to determine at which level the input will take data from. Using List@Level is flexible, efficient, and highly encouraged over other methods involving List.Map and List.Combine.</p>
<ol>
<li>Counting true values at List Level 2</li>
<li>Counting true values at List Level 3</li>
</ol>
<p>For how to use List@Level, refer to <a href="http://primer.dynamobim.org/en/06_Designing-with-Lists/6-3_lists-of-lists.html#list@level">Lists of Lists</a>.</p>
</blockquote>
<h2 id="maintain-readability"><a class="header" href="#maintain-readability">Maintain Readability</a></h2>
<p>In addition to making your graph as simple and efficient as possible, strive for graphic clarity. Despite your best efforts to make your graph intuitive with logical groupings, relationships might not be readily apparent. A simple Note inside of a Group or renaming a slider can save you or another user from unnecessary confusion or panning across the graph. The following are several ways that will help you apply graphic consistency within and across your graphs.</p>
<h3 id="visual-continuity-with-node-alignment"><a class="header" href="#visual-continuity-with-node-alignment"><strong>Visual continuity with Node Alignment</strong></a></h3>
<ul>
<li>To reduce your work after you finished building your graph, you should try to ensure the node layout is legible by <strong>aligning nodes often and as you go</strong></li>
<li>If others are going to be working with your graph, you should <strong>ensure that your node-wire layout flows easily before shipping</strong></li>
<li>To help you with alignment, <strong>use the &quot;Cleanup Node Layout&quot; feature to automatically align</strong> your graph, though less precisely than doing it yourself</li>
</ul>
<p><img src="9_best_practices/images/1/graphstrategy5(2)(1).png" alt="" /></p>
<blockquote>
<ol>
<li>Unorganized graph</li>
<li>Aligned graph</li>
</ol>
<p>For how to use Node Alignment, refer to <a href="9_best_practices/3-4_best_practices.html">Managing Your Program</a>.</p>
</blockquote>
<h3 id="descriptive-labeling-by-renaming"><a class="header" href="#descriptive-labeling-by-renaming"><strong>Descriptive labeling by renaming</strong></a></h3>
<ul>
<li>Renaming inputs can help others easily understand your graph, <strong>especially if what they plug into will be off the screen</strong></li>
<li><strong>Be wary of renaming nodes other than inputs.</strong> An alternative to this is creating a custom node from a node cluster and renaming that; it will be understood that it contains something else</li>
</ul>
<p><img src="9_best_practices/images/1/graphstrategy6.png" alt="" /></p>
<blockquote>
<ol>
<li>Inputs for surface manipulation</li>
<li>Inputs for architectural parameters</li>
<li>Inputs for drainage simulation script</li>
</ol>
<p>To rename a node, right click on its name and choose &quot;Rename Node...&quot;.</p>
</blockquote>
<h3 id="explain-with-notes"><a class="header" href="#explain-with-notes"><strong>Explain with Notes</strong></a></h3>
<ul>
<li>You should add a Note if something in the <strong>graph requires a plain language explanation</strong> that the nodes can not express</li>
<li>You should add a Note if a collection of <strong>nodes or a Group is too large or complex and cant be easily understood right away</strong></li>
</ul>
<p><img src="9_best_practices/images/1/graphstrategy7.png" alt="" /></p>
<blockquote>
<ol>
<li>A Note describing the portion of the program that returns raw translation distances</li>
<li>A Note describing the code that maps those values to a Sine wave</li>
</ol>
<p>For how to add a Note, refer to <a href="http://primer.dynamobim.org/en/03_Anatomy-of-a-Dynamo-Definition/3-4_best_practices.html">Managing Your Program</a>.</p>
</blockquote>
<h2 id="flex-continuously"><a class="header" href="#flex-continuously">Flex Continuously</a></h2>
<p>While building your visual-script, it is important to verify that what is being returned is what you expected. Not all errors or issues will cause the program to fail immediately, especially null or zero values that could affect something far downstream. This strategy is also discussed in the context of text-scripting in <a href="http://primer.dynamobim.org/en/12_Best-Practice/13-2_Scripting-Strategies.html">Scripting Strategies</a>. The following practice will help ensure that you are getting what you expected.</p>
<h3 id="monitor-data-with-watch-and-preview-bubbles"><a class="header" href="#monitor-data-with-watch-and-preview-bubbles"><strong>Monitor data with Watch and Preview Bubbles</strong></a></h3>
<ul>
<li>Use Watch or Preview Bubbles as you build the program to** verify that key outputs are returning what you expected**</li>
</ul>
<p><img src="9_best_practices/images/1/graphstrategy8.png" alt="" /></p>
<blockquote>
<p>The Watch nodes are being used to compare:</p>
<ol>
<li>The raw translation distances</li>
<li>The values passed through the Sine equation</li>
</ol>
<p>For how to use Watch, refer to <a href="http://primer.dynamobim.org/en/03_Anatomy-of-a-Dynamo-Definition/3-2_dynamo_libraries.html">Library</a>.</p>
</blockquote>
<h2 id="ensure-reusability"><a class="header" href="#ensure-reusability">Ensure Reusability</a></h2>
<p>It is highly likely that someone else will be opening your program at some point, even if you are working independently. They should be able to quickly understand what the program needs and produces from its inputs and outputs. This is especially important when developing a Custom Node to be shared with the Dynamo community and used in someone elses program. These practices lead to robust, reusable programs and nodes.</p>
<h3 id="manage-the-io"><a class="header" href="#manage-the-io"><strong>Manage the I/O</strong></a></h3>
<ul>
<li>To ensure legibility and scalability, you should try and <strong>minimize inputs and outputs as much as possible</strong></li>
<li>You should try to <strong>strategize how you are going to build the logic by first creating a rough outline</strong> of how the logic could work before you even add a single node to the canvas. As you develop the rough outline, you should keep track of which inputs and outputs will go into scripts</li>
</ul>
<h3 id="use-presets-to-embed-input-values"><a class="header" href="#use-presets-to-embed-input-values"><strong>Use Presets to embed input values</strong></a></h3>
<ul>
<li>If there are <strong>particular options or conditions that you want embedded in the graph</strong>, you should use Presets for quick access</li>
<li>You can also use Presets to <strong>reduce complexity by caching specific slider values</strong> in a graph with long run times</li>
</ul>
<blockquote>
<p>For how to use Presets, refer to <a href="http://primer.dynamobim.org/en/03_Anatomy-of-a-Dynamo-Definition/3-5_presets.html">Managing Your Data with Presets</a>.</p>
</blockquote>
<h3 id="contain-programs-with-custom-nodes"><a class="header" href="#contain-programs-with-custom-nodes"><strong>Contain programs with Custom Nodes</strong></a></h3>
<ul>
<li>You should use a Custom Node if your <strong>program can be collected into a single container</strong></li>
<li>You should use a a Custom Node <strong>when a portion of the graph will be reused often</strong> in other programs</li>
<li>You should use a Custom Node if you want to <strong>share a functionality with the Dynamo Community</strong></li>
</ul>
<p><img src="9_best_practices/images/1/graphstrategy9.png" alt="" /></p>
<blockquote>
<p>Collecting the point translation program into a Custom Node makes a robust, unique program portable and far easier to understand. Well named input ports will help other users understand how to use the node. Remember to add descriptions and required data types for each input.</p>
<ol>
<li>Existing attractor program</li>
<li>Custom Node that collects this program, PointGrid</li>
</ol>
<p>For how to use Custom Nodes, refer to <a href="http://primer.dynamobim.org/en/09_Custom-Nodes/9-1_Introduction.html">Custom Node Introduction</a>.</p>
</blockquote>
<h3 id="build-templates"><a class="header" href="#build-templates"><strong>Build templates</strong></a></h3>
<ul>
<li>You can build templates to <strong>establish graphic standards across your visual graphs to ensure collaborators have a standardized way of understanding graph</strong></li>
<li>When building a template, you can standardize <strong>group colors and font sizes</strong> to categorize types of workflows or data actions.</li>
<li>When building a template, you can even standardize how you want to <strong>label, color, or style the difference between front-end and back-end workflows</strong> in your graph.</li>
</ul>
<p><img src="9_best_practices/images/1/graphstrategy10(2).png" alt="" /></p>
<blockquote>
<ol>
<li>The UI, or front-end, of the program includes a project name, input sliders, and import geometry.</li>
<li>The back-end of the program.</li>
<li>Group color categories (the general design, inputs, Python scripting, imported geometry).</li>
</ol>
</blockquote>
<h2 id="exercise---architectural-roof"><a class="header" href="#exercise---architectural-roof">Exercise - Architectural Roof</a></h2>
<blockquote>
<p>Download the example file by clicking on the link below.</p>
<p>A full list of example files can be found in the Appendix.</p>
</blockquote>
<p>Now that we have established several best practices, lets apply them to a program that was put together quickly. Though the program succeeds in generating the roof, the state of the graph is a &quot;mind-map&quot; of the author. It lacks any organization or description of its use. We will walk through our best practices to organize, describe, and analyze the program so other users can understand how to use it.</p>
<p><img src="9_best_practices/images/1/graphstrategy11.png" alt="" /></p>
<blockquote>
<p>The program is functioning, but the graph is disorganized.</p>
</blockquote>
<p>Let's start by determining the data and geometry returned by the program.</p>
<p><img src="9_best_practices/images/1/graphstrategy12.png" alt="" /></p>
<blockquote>
<p>Understanding when major changes to the data occur is crucial to establishing logical divisions, or modularity. Try inspecting the rest of the program with Watch nodes to see if you can determine groups before moving on to the next step.</p>
<ol>
<li>This <strong>Code Block</strong> with a math equation looks like a crucial piece of the program. A <strong>Watch</strong> node displays that it is returning lists of translation distances.</li>
<li>The purpose of this area isn't readily obvious. The arrangement of True values at list level L2 from <strong>BoundingBox.Contains</strong> and the presence of <strong>List.FilterByBoolMask</strong> suggests we are sampling a portion of the point grid.</li>
</ol>
</blockquote>
<p>Once we understand the elemental parts of the program, let's put them in Groups.</p>
<p><img src="9_best_practices/images/1/graphstrategy13.png" alt="" /></p>
<blockquote>
<p>Groups allow the user to visually differentiate the parts of the program.</p>
<ol>
<li>Import 3D site model</li>
<li>Translate point grid based on Sine equation</li>
<li>Sample portion of point grid</li>
<li>Create architectural roof surface</li>
<li>Create glass curtain wall</li>
</ol>
</blockquote>
<p>With Groups established, align the nodes to create visual continuity across the graph.</p>
<p><img src="9_best_practices/images/1/graphstrategy14.png" alt="" /></p>
<blockquote>
<p>Visual continuity helps the user to see the program flow and implicit relationships between nodes.</p>
</blockquote>
<p>Make the program more accessible by adding another layer of graphic improvements. Add notes to describe how a specific area of the program works, give inputs custom names, and assign colors to different types of groups.</p>
<p><img src="9_best_practices/images/1/graphstrategy15(1).png" alt="" /></p>
<blockquote>
<p>These graphic improvements tell the user more about what the program is doing. The different group colors help to distinguish inputs from functions.</p>
<ol>
<li>Notes</li>
<li>Inputs with descriptive names</li>
</ol>
</blockquote>
<p>Before we start to condense the program, let's find a strategic location to introduce the Python script drainage simulator. Plug the output of the first scaled roof surface into the respective scripting input.</p>
<p><img src="9_best_practices/images/1/graphstrategy16.png" alt="" /></p>
<blockquote>
<p>We've chosen to integrate scripting at this point in the program so the drainage simulation can be run on the original, single roof surface. That specific surface is not being previewed, but it saves us from having to choose the top surface of the chamfered Polysurface.</p>
<ol>
<li>Source geometry for script input</li>
<li>Python node</li>
<li>Input sliders</li>
<li>On/off &quot;switch&quot;</li>
</ol>
</blockquote>
<p>Let's simplify the graph now that everything is in place.</p>
<p><img src="9_best_practices/images/1/graphstrategy17.png" alt="" /></p>
<blockquote>
<p>Condensing our program with Node to Code and Custom Node has greatly reduced the size of the graph. The groups that create the roof surface and walls have been converted to code since they are very specific to this program. The point translation group is contained in a Custom Node as it could be used in another program. In the example file, create your own custom node from the translate points group.</p>
<ol>
<li>Custom Node to contain the &quot;translate point grid&quot; group</li>
<li>Node to Code to condense the &quot;create architectural roof surface and curtain wall&quot; groups</li>
</ol>
</blockquote>
<p>As a final step, create presets for exemplary roof forms.</p>
<p><img src="9_best_practices/images/1/graphstrategy18.png" alt="" /></p>
<blockquote>
<p>These inputs are the primary drivers of the roof form and will help users see the potential of the program.</p>
</blockquote>
<p>Our program with views of two presets.</p>
<p><img src="9_best_practices/images/1/graphstrategy19.png" alt="" /></p>
<p><img src="9_best_practices/images/1/graphstrategy20.png" alt="" /></p>
<blockquote>
<p>The roof drainage patterns give the user an analytical view of the respective presets.</p>
</blockquote>
<div style="break-before: page; page-break-before: always;"></div><h1 id="scripting-strategies"><a class="header" href="#scripting-strategies">Scripting Strategies</a></h1>
<p>Text-based scripting within the visual-scripting environment enables powerful and visual relationships using DesignScript, Python, and ZeroTouch (C#). The user can expose elements such as input sliders, condense large operations into DesignScript, and access powerful tools and libraries through Python or C# all within the same workspace. If managed effectively, combining these strategies can lend a great deal of customization, clarity, and efficiency to the overall program. The following are a set of guidelines to help you augment your visual-script with text-script.</p>
<p><img src="9_best_practices/./images/2/cad-chart-textual.jpg" alt="" /></p>
<h3 id="know-when-to-script"><a class="header" href="#know-when-to-script">Know When to Script</a></h3>
<p>Text-scripting can establish relationships of a higher complexity than visual programming, yet their capabilities also overlap significantly. This makes sense because nodes are effectively pre-packaged code, and we could probably write an entire Dynamo program in DesignScript or Python. However, we use visual-scripting because the interface of nodes and wires creates an intuitive flow of graphic information. Knowing where text-scripting's capabilities go beyond visual-scripting will give you major clues to when it should be used without foregoing the intuitive nature of nodes and wires. The following are guidelines on when to script and which language to use.</p>
<p><strong>Use text-scripting for:</strong></p>
<ul>
<li>Looping</li>
<li>Recursion</li>
<li>Accessing external libraries</li>
</ul>
<p><strong>Choose a language:</strong></p>
<div class="table-wrapper"><table><thead><tr><th></th><th></th><th></th><th></th><th></th><th></th></tr></thead><tbody>
<tr><td></td><td><strong>Looping</strong></td><td><strong>Recursion</strong></td><td><strong>Condense Nodes</strong></td><td><strong>Ext. Libraries</strong></td><td><strong>Shorthand</strong></td></tr>
<tr><td><strong>DesignScript</strong></td><td>Yes</td><td>Yes</td><td>Yes</td><td>No</td><td>Yes</td></tr>
<tr><td><strong>Python</strong></td><td>Yes</td><td>Yes</td><td>Partially</td><td>Yes</td><td>No</td></tr>
<tr><td><strong>ZeroTouch (C#)</strong></td><td>No</td><td>No</td><td>No</td><td>Yes</td><td>No</td></tr>
</tbody></table>
</div>
<p>{% hint style=&quot;info&quot; %}
Refer to <a href="9_best_practices/13-3_scripting-reference.html">Scripting Reference</a> for a list of what each Dynamo library gives you access to.
{% endhint %}</p>
<h3 id="think-parametrically"><a class="header" href="#think-parametrically">Think Parametrically</a></h3>
<p>When scripting in Dynamo, an inevitably parametric environment, it is wise to structure your code relative to the framework of nodes and wires it will be living in. Consider the node containing your text-script as though it is any other node in the program with a few specific inputs, a function, and an expected output. This immediately gives your code inside the node a small set of variables from which to work, the key to a clean parametric system. Here are some guidelines for better integrating code into a visual program.</p>
<p><strong>Identify the external variables:</strong></p>
<ul>
<li>Try to determine the given parameters in your design problem so that you can construct a model that directly builds off that data.</li>
<li>Before writing code, identify the variables:
<ul>
<li>A minimal set of inputs</li>
<li>The intended output</li>
<li>Constants</li>
</ul>
</li>
</ul>
<p><img src="9_best_practices/./images/2/thinkparametrically01.jpg" alt="" /></p>
<blockquote>
<p>Several variables have been established prior to writing code.</p>
<ol>
<li>The surface we will simulate rainfall on.</li>
<li>The number of rain drops (agents) we want.</li>
<li>How far we want the rain drops to travel.</li>
<li>Toggle between descending the steepest path versus traversing the surface.</li>
<li>Python Node with the respective number of inputs.</li>
<li>A Code Block to make the returned curves blue.</li>
</ol>
</blockquote>
<p><strong>Design the internal relationships:</strong></p>
<ul>
<li>Parametricism allows for certain parameters or variables to be edited in order to manipulate or alter the end result of an equation or system.</li>
<li>Whenever entities in your script are logically related, aim to define them as functions of each other. This way when one is modified, the other can update proportionally.</li>
<li>Minimize number of inputs by only exposing key parameters:
<ul>
<li>If a set of parameters can be derived from more parent parameters, only expose the parent parameters as script inputs. This increases the usability of your script by reducing the complexity of its interface.</li>
</ul>
</li>
</ul>
<p><img src="9_best_practices/./images/2/thinkparametrically02.jpg" alt="" /></p>
<blockquote>
<p>The code &quot;modules&quot; from the example in <a href="http://primer.dynamobim.org/en/09_Custom-Nodes/9-4_Python.html">Python Node</a>.</p>
<ol>
<li>Inputs.</li>
<li>Variables internal to the script.</li>
<li>A loop that uses these inputs and variables to perform its function.</li>
</ol>
</blockquote>
<p>{% hint style=&quot;info&quot; %}
Tip: Place as much emphasis on the process as you do on the solution.
{% endhint %}</p>
<h3 id="dont-repeat-yourself-the-dry-principle"><a class="header" href="#dont-repeat-yourself-the-dry-principle"><strong>Don't repeat yourself (the DRY principle):</strong></a></h3>
<ul>
<li>When you have multiple ways to express the same thing in your script, at some point the duplicate representations will fall out of sync which can lead to maintenance nightmares, poor factoring, and internal contradictions.</li>
<li>The DRY principle is stated as &quot;Every piece of knowledge must have a single, unambiguous, authoritative representation within a system&quot;:
<ul>
<li>When this principle is successfully applied, all the related elements in your script change predictably and uniformly and all the unrelated elements do not have logical consequences on each other.</li>
</ul>
</li>
</ul>
<pre><code>### BAD
for i in range(4):
  for j in range(4):
    point = Point.ByCoordinates(3*i, 3*j, 0)
    points.append(point)
</code></pre>
<pre><code>### GOOD
count = IN[0]
pDist = IN[1]

for i in range(count):
  for j in range(count):
    point = Point.ByCoordinates(pDist*i, pDist*j, 0)
    points.append(point)
</code></pre>
<p>{% hint style=&quot;info&quot; %}
Tip: Before duplicating entities in your script (such as constant in the example above), ask yourself if you can link to the source instead.
{% endhint %}</p>
<h3 id="structure-modularly"><a class="header" href="#structure-modularly">Structure Modularly</a></h3>
<p>As your code gets longer and more complex the big idea, or overarching algorithm becomes increasingly illegible. It also becomes more difficult to keep track of what (and where) specific things happen, find bugs when things go wrong, integrate other code, and assign development tasks. To avoid these headaches its wise to write code in modules, an organizational strategy that breaks up code based on the task it executes. Here are some tips for making your scripts more manageable by way of modularization.</p>
<p><strong>Write code in modules:</strong></p>
<ul>
<li>A &quot;module&quot; is a group of code that performs a specific task, similar to a Dynamo Node in the workspace.</li>
<li>This can be anything that should be visually separated from adjacent code (a function, a class, a group of inputs, or the libraries you are importing).</li>
<li>Developing code in modules harnesses the visual, intuitive quality of Nodes as well as the complex relationships that only text-scripting can achieve.</li>
</ul>
<p><img src="9_best_practices/./images/2/thinkparametrically02.jpg" alt="" /></p>
<blockquote>
<p>These loops call a class named &quot;agent&quot; that we will develop in the exercise.</p>
<ol>
<li>A code module that defines the start point of each agent.</li>
<li>A code module that updates the agent.</li>
<li>A code module that draws a trail for the agent's path.</li>
</ol>
</blockquote>
<p><strong>Spotting code re-use:</strong></p>
<ul>
<li>If you find that your code does the same (or very similar) thing in more than once place, find ways to cluster it into a function that can be called.</li>
<li>&quot;Manager&quot; functions control program flow and primarily contain calls to &quot;Worker&quot; functions that handle low-level details, like moving data between structures.</li>
</ul>
<p>This example creates spheres with radii and color based on the Z value of the center points.</p>
<p><img src="9_best_practices/./images/2/spotcoderesuse.jpg" alt="" /></p>
<blockquote>
<ol>
<li>Two &quot;worker&quot; parent functions: one that creates spheres with radii and display colors based the centerpoint's Z value.</li>
<li>A &quot;manager&quot; parent function that combines the two worker functions. Calling this will call both functions inside it.</li>
</ol>
</blockquote>
<p><strong>Only show what needs to be seen:</strong></p>
<ul>
<li>A module interface expresses the elements that are provided and required by the module.</li>
<li>Once the interfaces between the units have been defined, the detailed design of each unit can proceed separately.</li>
</ul>
<p><strong>Separability/Replaceability:</strong></p>
<ul>
<li>Modules dont know or care about each other.</li>
</ul>
<p><strong>General forms of modularization:</strong></p>
<ul>
<li>
<p>Code Grouping:</p>
<pre><code># IMPORT LIBRARIES
import random
import math
import clr
clr.AddReference('ProtoGeometry')
from Autodesk.DesignScript.Geometry import *

# DEFINE PARAMETER INPUTS
surfIn = IN[0]
maxSteps = IN[1]
</code></pre>
</li>
<li>
<p>Functions:</p>
<pre><code>def get_step_size():
  area = surfIn.Area
  stepSize = math.sqrt(area)/100
  return stepSize

stepSize = get_step_size()
</code></pre>
</li>
<li>
<p>Classes:</p>
<pre><code>class MyClass:
  i = 12345

  def f(self):
    return 'hello world'

numbers = MyClass.i
greeting = MyClass.f
</code></pre>
</li>
</ul>
<h3 id="flex-continuously-1"><a class="header" href="#flex-continuously-1">Flex Continuously</a></h3>
<p>While developing text-scripts in Dynamo, it is wise to constantly make sure that what is actually being created is in line with what you are expecting. This will ensure that unforeseen events-- syntax errors, logical discrepancies, value inaccuracies, anomalous outputs etc.-- are quickly discovered and dealt with as they surface rather than all at once at the end. Because text-scripts live inside nodes on the canvas, they are already integrated into the data flow of your visual program. This makes the successive monitoring of your script as simple as assigning data to be outputted, running the program, and evaluating what flows out of the script using a Watch Node. Here are some tips for continuously inspecting your scripts as you construct them.</p>
<p><strong>Test as you go:</strong></p>
<ul>
<li>Whenever you complete a cluster of functionality:
<ul>
<li>Step back and inspect your code.</li>
<li>Be critical. Could a collaborator understand what this is doing? Do I need to do this? Can this function be done more efficiently? Am I creating unnecessary duplicates or dependencies?</li>
<li>Quickly test to make sure it is returning data that makes sense.</li>
</ul>
</li>
<li>Assign the most recent data you are working with in your script as the output so that the node is always outputting relevant data when the script updates:</li>
</ul>
<p><img src="9_best_practices/./images/2/flexcontinuously.jpg" alt="" /></p>
<blockquote>
<ol>
<li>Check that all edges of the solid are being returned as curves to create a bounding box around.</li>
<li>Check that our Count inputs are successfully being converted to Ranges.</li>
<li>Check that coordinate systems have been properly translated and rotated in this loop.</li>
</ol>
</blockquote>
<p><strong>Anticipate edge cases:</strong></p>
<ul>
<li>While scripting, crank your input parameters to the minimum and maximum values of their allotted domain to check if the program still functions under extreme conditions.</li>
<li>Even if the program is functioning at its extremes, check if it is returning unintended null/empty/zero values.</li>
<li>Sometimes bugs and errors that reveal some underlying problem with your script will only surface during these edge cases.
<ul>
<li>Understand what is causing the error and then decide if it needs to be fixed internally or if a parameter domain needs to be redefined to avoid the problem.</li>
</ul>
</li>
</ul>
<p>{% hint style=&quot;info&quot; %}
Tip: Always assume the that the user will use every combination of every input value that has been exposed to him/her. This will help eliminate unwanted surprises.
{% endhint %}</p>
<h3 id="debug-efficiently"><a class="header" href="#debug-efficiently">Debug Efficiently</a></h3>
<p>Debugging is the process of eliminating &quot;bugs&quot; from your script. Bugs can be errors, inefficiencies, inaccuracies, or any unintended results. Addressing a bug can be as simple as correcting a misspelled variable name to more pervasive, structural problems with your script. Ideally, flexing your script as you build it will help to catch these potential issues early, though this is no guarantee of it being bug-free. The following is a review of several best practices from above to help you address bugs systematically.</p>
<p><strong>Use the watch bubble:</strong></p>
<ul>
<li>Check the data returned at different places in the code by assigning it to the OUT variable, similar to the concept of flexing the program.</li>
</ul>
<p><strong>Write meaningful comments:</strong></p>
<ul>
<li>A module of code will be much easier to debug if its intended outcome is clearly described.</li>
</ul>
<pre><code class="language-py"># Loop through X and Y
for i in range(xCount):
  for j in range(yCount):

    # Rotate and translate the coordinate system
    toCoord = fromCoord.Rotate(solid.ContextCoordinateSystem.Origin,Vector.ByCoordinates(0,0,1),(90*(i+j%seed)))
    vec = Vector.ByCoordinates((xDist*i),(yDist*j),0)
    toCoord = toCoord.Translate(vec)

    # Transform the solid from the source coord system to the target coord system and append to the list
    solids.append(solid.Transform(fromCoord,toCoord))
</code></pre>
<blockquote>
<p>Normally this would be an excessive amount of commenting and blank lines, but when debugging it can be useful to break things down into manageable pieces.</p>
</blockquote>
<p><strong>Leverage the code's modularity:</strong></p>
<ul>
<li>The source of an issue can be isolated to certain modules.</li>
<li>Once the faulty module has been identified, fixing the problem is considerably simpler.</li>
<li>When a program must be modified, code that has been developed in modules will be much easier to change:
<ul>
<li>You can insert new or debugged modules into an existing program with the confidence that the rest of the program will not change.</li>
</ul>
</li>
</ul>
<p><img src="9_best_practices/./images/2/leveragecode&#x27;smodularity.jpg" alt="" /></p>
<blockquote>
<p>Debugging the example file from <a href="http://primer.dynamobim.org/en/09_Custom-Nodes/9-4_Python.html">Python Node</a>.</p>
<ol>
<li>The input geometry is returning a bounding box larger that itself, as we can see from assigning xDist and yDist to OUT.</li>
<li>The edge curves of the input geometry return an appropriate bounding box with correct distances for xDist and yDist.</li>
<li>The code &quot;module&quot; we've inserted to address the xDist and yDist value issue.</li>
</ol>
</blockquote>
<h2 id="exercise-steepest-path"><a class="header" href="#exercise-steepest-path">Exercise: Steepest Path</a></h2>
<blockquote>
<p>Download the example file by clicking on the link below.</p>
<p>A full list of example files can be found in the Appendix.</p>
</blockquote>
<p>{% file src=&quot;./datasets/9/2/SteepestPath.dyn&quot; %}</p>
<p>With our best practices for text-scripting in mind, let's write a rain simulation script. While we were able to apply best practices to a disorganized visual program in Graph Strategies, it is far more difficult to do that with text-scripting. Logical relationships established in text-scripting are less visible and can be almost impossible to untangle in messy code. With the power of text-scripting comes a larger responsibility in organization. We will walk through each step and apply best practices along the way.</p>
<p>Our script applied to an attractor-deformed surface.</p>
<p><img src="9_best_practices/./images/2/scriptingstrategies-exercise-01.jpg" alt="" /></p>
<p>The first thing we need to do is import the necessary Dynamo libraries. Doing this first will give global access to Dynamo functionality in Python.</p>
<p>All the libraries we intend on using need to be imported here.</p>
<p><img src="9_best_practices/./images/2/scriptingstrategies-exercise-02.jpg" alt="" /></p>
<p>Next we need to define the script's inputs and output, which will display as input ports on the node. These external inputs are the foundation for our script and the key to establishing a parametric environment.</p>
<p>We need to define inputs that correspond to variables in the Python script and determine a desired output:</p>
<p><img src="9_best_practices/./images/2/scriptingstrategies-exercise-03.jpg" alt="" /></p>
<blockquote>
<ol>
<li>The surface we want to walk down.</li>
<li>The number of agents we want to walk.</li>
<li>The maximum number of steps the agents are allowed to take.</li>
<li>An option to take the shortest path down the surface or traverse it.</li>
<li>The Python Node with input identifiers that correspond to inputs in the script (IN[0], IN[1]).</li>
<li>Output curves that can be displayed with a different color.</li>
</ol>
</blockquote>
<p>Now let's employ the practice of modularity and create the body of our script. Simulating the shortest path down a surface for multiple start points is a significant task that will require several functions. Rather than call the different functions throughout the script, we can modularize our code by collecting them into a single class, our agent. The different functions of this class or &quot;module&quot; can be called with different variables or even reused in another script.</p>
<p>We will need to define a class, or blueprint, for an agent with the intention of walking down a surface by choosing to travel in the steepest possible direction each time it takes a step:</p>
<p><img src="9_best_practices/./images/2/scriptingstrategies-exercise-04.jpg" alt="" /></p>
<blockquote>
<ol>
<li>Name.</li>
<li>Global attributes that all the agents share.</li>
<li>Instance attributes that are unique to each agent.</li>
<li>A function for taking a step.</li>
<li>A function for cataloging the position of each step to a trail list.</li>
</ol>
</blockquote>
<p>Let's initialize the agents by defining their start location. This is a good opportunity to flex our script and make sure the agent class is working.</p>
<p>We will need to instantiate all the agents we want to observe walk down the surface and define their initial attributes:</p>
<p><img src="9_best_practices/./images/2/scriptingstrategies-exercise-05.jpg" alt="" /></p>
<blockquote>
<ol>
<li>A new empty trail list.</li>
<li>Where they will start their journey on the surface.</li>
<li>We've assigned the agents list as the output to check what the script is returning here. The correct number of agents is being returned, but we'll need to flex the script again later on to verify the geometry it returns.</li>
</ol>
</blockquote>
<p>Update each agent at each step. We will then need to enter a nested loop where for each agent and for each step, we update and record their position into their trail list. At each step we will also make sure the agent hasnt reached a point on the surface where it cannot take another step which will allow it to descend. If that condition is met, we will end that agent's trip.</p>
<p><img src="9_best_practices/./images/2/scriptingstrategies-exercise-06.jpg" alt="" /></p>
<p>Now that our agents have been fully updated, let's return geometry that represents them. After all the agents have either reached their limit of descent or their maximum number of steps we will create a polycurve through the points in their trail list and output the polycurve trails.</p>
<p><img src="9_best_practices/./images/2/scriptingstrategies-exercise-07.jpg" alt="" /></p>
<p>Our script for finding the steepest paths.</p>
<p><img src="9_best_practices/./images/2/scriptingstrategies-exercise-08.jpg" alt="" /></p>
<blockquote>
<ol>
<li>A preset that simulates rainfall on the underlying surface.</li>
<li>Rather than finding the steepest path, the agents can be toggled to traverse the underlying surface.</li>
</ol>
</blockquote>
<p>The full Python text-script.</p>
<pre><code>### STEEPEST PATH ALGORITHM

# IMPORT LIBRARIES
import sys
sys.path.append('C:\Program Files (x86)\IronPython 2.7\Lib')
import random
import math
import clr
clr.AddReference('ProtoGeometry')
from Autodesk.DesignScript.Geometry import *

# DEFINE PARAMETER INPUTS
surfIn = IN[0]
numAgents = IN[1]
maxSteps = IN[2]
decendBoo = IN[3]


# DEFINE AGENT CLASS
class Agent(object):
    def get_step_size():
        area = surfIn.Area
        stepSize = math.sqrt(area)/100
        return stepSize

    zVec = Vector.ZAxis()
    stepSize = get_step_size()
    dupTol = 0.001


    def __init__(self,u,v):
        self.endBoo = False
        self.U = u
        self.V = v
        self.Z = None
        self.trailPts = []
        self.update_trail()

    def update(self):
        if not self.endBoo:
            positionPt01 = self.trailPts[-1]
            normalVec = surfIn.NormalAtParameter(self.U,self.V)
            gradientVec = Vector.Cross(self.zVec, normalVec)
            if decendBoo:
            	gradientVec = gradientVec.Rotate(normalVec,-90)

            gradientVec = gradientVec.Normalized()
            gradientVec = gradientVec.Scale(self.stepSize)
            positionPt02 = positionPt01.Add(gradientVec)
            newPt = surfIn.ClosestPointTo(positionPt02)
            newUV = surfIn.UVParameterAtPoint(newPt)
            newU, newV = newUV.U, newUV.V
            newZ = newPt.Z

            if decendBoo and (self.Z &lt;= newZ):
            	self.endBoo = True
            else:
	            if ((abs(self.U-newU) &lt;= self.dupTol) and (abs(self.V-newV) &lt;= self.dupTol)):
	                self.endBoo = True
	            else:
	                self.U, self.V = newU, newV
	                self.update_trail()

    def update_trail(self):
        trailPt = surfIn.PointAtParameter(self.U,self.V)
        self.trailPts.append(trailPt)
        self.Z = trailPt.Z


# INITIALIZE AGENTS
agents = []
for i in range(numAgents):
	u = float(random.randrange(1000))/1000
	v = float(random.randrange(1000))/1000
	agent = Agent(u,v)
	agents.append(agent)


# UPDATE AGENTS
for i in range(maxSteps):
	for eachAgent in agents:
		eachAgent.update()

# DRAW TRAILS
trails = []
for eachAgent in agents:
	trailPts = eachAgent.trailPts
	if (len(trailPts) &gt; 1):
		trail = PolyCurve.ByPoints(trailPts)
		trails.append(trail)

# OUTPUT TRAILS
OUT = trails
</code></pre>
<div style="break-before: page; page-break-before: always;"></div><h1 id="scripting-reference"><a class="header" href="#scripting-reference">Scripting Reference</a></h1>
<p>This reference page extends the best practices covered in Scripting Strategies with greater detail on code libraries, labeling, and styling. We will be using Python to illustrate the concepts below, but the same principles would apply in Python and C#(Zerotouch) but in different syntax.</p>
<h2 id="which-libraries-to-use"><a class="header" href="#which-libraries-to-use">Which Libraries to Use</a></h2>
<p>Standard libraries are external to Dynamo and are present in the programming languages Python and C# (Zerotouch). Dynamo also has its own set of libraries that directly correspond to it's node hierarchy, enabling the user to build anything in code that could be made with nodes and wires. The following is a guide for what each Dynamo library gives access to and when to use a standard one.</p>
<p><img src="9_best_practices/./images/3/textual-programming.jpg" alt="" /></p>
<p><strong>Standard Libraries and Dynamo Libraries</strong></p>
<ul>
<li>Standard libraries from Python and C# can be used to build advanced data and flow structures in the Dynamo environment.</li>
<li>Dynamo libraries directly correspond to the node hierarchy for creating geometry and other Dynamo objects.</li>
</ul>
<p><strong>Dynamo Libraries</strong></p>
<ol>
<li>
<p>ProtoGeometry*</p>
<ul>
<li>Functionality: Arc, Bounding Box, Circle, Cone, Coordinate System, Cuboid, Curve, Cylinder, Edge, Ellipse, Ellipse Arc ,Face, Geometry, Helix, Index Group, Line, Mesh, Nurbs Curve, Nurbs Surface, Plane, Point, Polygon, Rectangle, Solid, Sphere, Surface, Topology, TSpline, UV, Vector, Vertex.</li>
<li>How to import: <code>import Autodesk.DesignScript.Geometry</code></li>
</ul>
<p>``</p>
</li>
<li>
<p>DSCoreNodes</p>
<ul>
<li>Functionality: Color, Color Range 2D, Date Time, Time Span, IO, Formula, Logic, List, Math, Quadtree, String, Thread.</li>
<li>How to import: <code>import DSCore</code></li>
</ul>
</li>
<li>
<p>Tessellation</p>
<ul>
<li>Functionality: Convex Hull, Delaunay, Voronoi.</li>
<li>How to import: <code>import Tessellation</code></li>
</ul>
</li>
<li>
<p>DSOffice</p>
<ul>
<li>Functionality: Excel.</li>
<li>How to import: <code>import DSOffice</code></li>
</ul>
</li>
</ol>
<p>{% hint style=&quot;warning&quot; %}
*Note: When using <strong>ProtoGeometry</strong> through Python or C#, you are creating unmanaged objects, which need have their memory managed manually - please see section below: <strong>Unmanaged Objects</strong>, for more info.
{% endhint %}</p>
<h2 id="label-carefully"><a class="header" href="#label-carefully">Label Carefully</a></h2>
<p>While scripting, we are constantly using identifiers to denote things like variables, types, functions, and other entities. Through this system of symbolic notation, while building algorithms we can conveniently refer to information by way of labels --usually made up of a sequence of characters. Naming things well plays a significant role in writing code that can be easily read and understood by others as well as your future self! Here are some tips to keep in mind while naming things in your script:</p>
<p><strong>Its OK to use abbreviations, but explain the abbreviation with a comment:</strong></p>
<pre><code>### BAD
csfX = 1.6
csfY= 1.3
csfZ = 1.0
</code></pre>
<pre><code>### GOOD
# column scale factor (csf)
csfX = 1.6
csfY= 1.3
csfZ = 1.0
</code></pre>
<p><strong>Avoid redundant labeling:</strong></p>
<pre><code>### BAD
import car
seat = car.CarSeat()
tire = car.CarTire()
</code></pre>
<pre><code>### GOOD
import car
seat = car.Seat()
tire = car.Tire()
</code></pre>
<p><strong>Use positive logic for your variable names instead of negative logic:</strong></p>
<pre><code>### BAD
if 'mystring' not in text:
    print 'not found'
else:
    print 'found'
    print 'processing'
</code></pre>
<pre><code>### GOOD
if 'mystring' in text:
    print 'found'
    print 'processing'
else:
    print 'not found'
</code></pre>
<p><strong>Prefer reverse notation:</strong></p>
<pre><code>### BAD
agents = 
active_agents = 
dead_agents ...
</code></pre>
<pre><code>### GOOD
agents = 
agents_active = 
agents_dead = ...
</code></pre>
<blockquote>
<p>Its more sensible, in structural terms.</p>
</blockquote>
<p><strong>Aliases should be used to shorten overly long and often repeated chains:</strong></p>
<pre><code>### BAD
from RevitServices.Persistence import DocumentManager

DocumentManager = DM

doc = DM.Instance.CurrentDBDocument
uiapp = DM.Instance.CurrentUIApplication
</code></pre>
<pre><code>### GOOD
from RevitServices.Persistence import DocumentManager as DM

doc = DM.Instance.CurrentDBDocument
uiapp = DM.Instance.CurrentUIApplication
</code></pre>
<blockquote>
<p>Aliasing can quickly lead to very confusing and non-standard programs.</p>
</blockquote>
<p><strong>Only use necessary words:</strong></p>
<pre><code>### BAD
rotateToCoord = rotateFromCoord.Rotate(solid.ContextCoordinateSystem.Origin,Vector.ByCoordinates(0,0,1),5)
</code></pre>
<pre><code>### GOOD
toCoord = fromCoord.Rotate(solid.ContextCoordinateSystem.Origin,Vector.ByCoordinates(0,0,1),5)
</code></pre>
<blockquote>
<p>Everything should be made as simple as possible, but not simpler.  Albert Einstein</p>
</blockquote>
<h2 id="style-consistently"><a class="header" href="#style-consistently">Style Consistently</a></h2>
<p>Generally speaking there is more than one way to program just about anything, therefore your personal style of scripting is the result of the countless small decisions you choose to make (or not make) along the way. That said, the readability and maintainability of your code is a direct result of its internal consistency as well as its adherence to general stylistic conventions. As a rule of thumb, code that looks the same in two places should work the same, too. Here are a few tips for writing clear and consistent code.</p>
<p><strong>Naming conventions:</strong> (Choose one of the conventions below for each type of entity in your code and stick to it!)</p>
<ul>
<li>Variables, functions, methods, packages, modules:<br />
<code>lower_case_with_underscores</code></li>
<li>Classes and Exceptions:<br />
<code>CapWords</code></li>
<li>Protected methods and internal functions:<br />
<code>_single_leading_underscore(self, ...)</code></li>
<li>Private methods:<br />
<code>__double_leading_underscore(self, ...)</code></li>
<li>Constants:<br />
<code>ALL_CAPS_WITH_UNDERSCORES</code></li>
</ul>
<blockquote>
<p>Tip: Avoid one-letter variables (esp. l, O, I) except in very short blocks, when the meaning is clearly visible from the immediate context.</p>
</blockquote>
<p><strong>Use of blank lines:</strong></p>
<ul>
<li>Surround top-level function and class definitions with two blank lines.
<ul>
<li>Method definitions inside a class are surrounded by a single blank line.</li>
<li>Extra blank lines may be used (sparingly) to separate groups of related functions.</li>
</ul>
</li>
</ul>
<p><strong>Avoid extraneous whitespace:</strong></p>
<ul>
<li>
<p>Immediately inside parentheses, brackets or braces:</p>
<pre><code>### BAD
function( apples[ 1 ], { oranges: 2 } )
</code></pre>
<pre><code>### GOOD:
function(apples[1], {oranges: 2})
</code></pre>
</li>
<li>
<p>Immediately before a comma, semicolon, or colon:</p>
<pre><code>### BAD
 if x == 2 : print x , y ; x , y = y , x
</code></pre>
<pre><code>### GOOD
  if x == 2: print x, y; x, y = y, x
</code></pre>
</li>
<li>
<p>Immediately before the open parenthesis that starts the argument list of a function call:</p>
<pre><code>### BAD
function (1)
</code></pre>
<pre><code>### GOOD
function(1)
</code></pre>
</li>
<li>
<p>Immediately before the open parenthesis that starts an indexing or slicing:</p>
<pre><code>### BAD
dict ['key'] = list [index]
</code></pre>
<pre><code>### GOOD
dict['key'] = list[index]
</code></pre>
</li>
<li>
<p>Always surround these binary operators with a single space on either side:</p>
<pre><code>assignment ( = )
augmented assignment ( += , -= etc.)
comparisons ( == , &lt; , &gt; , != , &lt;&gt; , &lt;= , &gt;= , in , not in , is , is not )
Booleans ( and , or , not )
</code></pre>
</li>
</ul>
<p><strong>Watch line length:</strong></p>
<ul>
<li>Don't stress over it ~ 79 characters.</li>
<li>Limiting the required editor window width makes it possible to have several files open side-by-side, and works well when using code review tools that present the two versions in adjacent columns.</li>
<li>Long lines can be broken over multiple lines by wrapping expressions in parentheses:</li>
</ul>
<p><strong>Avoid obvious and redundant comments:</strong></p>
<ul>
<li>
<p>Sometimes fewer comments makes for more readable code. Especially if it forces you to use meaningful symbol names instead.</p>
</li>
<li>
<p>Adopting good coding habits reduces dependence on comments:</p>
<pre><code>### BAD
  # get the country code
  country_code = get_country_code(address)

  # if country code is US
  if (country_code == 'US'):
    # display the form input for state
    print form_input_state()
</code></pre>
<pre><code>### GOOD
  # display state selection for US users
  country_code = get_country_code(address)
  if (country_code == 'US'):
    print form_input_state()
</code></pre>
</li>
</ul>
<blockquote>
<p>Tip: Comments tell you why, Code tells you how.</p>
</blockquote>
<p><strong>Check out open source code:</strong></p>
<ul>
<li>Open Source projects are built on the collaborative efforts of many developers. These projects need to maintain a high level of code readability so that the team can work together as efficiently as possible. Therefore, it is a good idea to browse through the source code of these projects to observe what these developers are doing.</li>
<li>Improve your conventions:
<ul>
<li>Question whether or not each convention is working for the needs at hand.</li>
<li>Is functionality/efficiency being compromised?</li>
</ul>
</li>
</ul>
<h2 id="c-zerotouch-standards"><a class="header" href="#c-zerotouch-standards">C# (Zerotouch) Standards</a></h2>
<p><strong>Check out these wiki pages for guidance on writing C# for Zerotouch and contributing to Dynamo:</strong></p>
<ul>
<li>This wiki covers some general coding standards for documenting and testing your code: <a href="https://github.com/DynamoDS/Dynamo/wiki/Coding-Standards">https://github.com/DynamoDS/Dynamo/wiki/Coding-Standards</a></li>
<li>This wiki specifically covers naming standards for libraries, categories, node names, port names, and abbreviations: <a href="https://github.com/DynamoDS/Dynamo/wiki/Naming-Standards">https://github.com/DynamoDS/Dynamo/wiki/Naming-Standards</a></li>
</ul>
<p><strong>Unmanaged Objects:</strong></p>
<p>When using Dynamo's Geometry library <em>(ProtoGeometry)</em> from Python or C# geometry objects that you create will not be managed by the virtual machine, and the memory of many of these objects will need to be cleaned up manually. To cleanup native or unmanaged objects you can use the <strong>Dispose</strong> method or the <strong>using</strong> keyword. See this wiki entry for an overview: <a href="https://github.com/DynamoDS/Dynamo/wiki/Zero-Touch-Plugin-Development#dispose--using-statement">https://github.com/DynamoDS/Dynamo/wiki/Zero-Touch-Plugin-Development#dispose--using-statement</a>.</p>
<p>You only need to dispose unmanaged resources that you don't return into the graph or store a reference to. For the rest of this section, we'll refer to these objects as <em>intermediate geometry</em>. You can see an example of this class of object in the code example below. This zero touch C# function <strong>singleCube</strong> returns a single cube, but creates 10000 extra cubes during its execution. We can pretend this other geometry was used as some intermediate construction geometry.</p>
<p><strong>This zero touch function will most likely crash Dynamo.</strong> Since we created 10000 solids, but only stored one of them, and only returned that one. We should instead, dispose all of our intermediate cubes, except the one that we return. We don't want to dipose what we return, as it will be propogated into the graph and used by other nodes.</p>
<pre><code>public Cuboid singleCube(){

  var output = Cuboid.ByLengths(1,1,1);

  for(int i = 0; i&lt;10000;i++){
    output = Cuboid.ByLengths(1,1,1);
  }
  return output;
}
</code></pre>
<p>The fixed code would look something like:</p>
<pre><code> public Cuboid singleCube(){

   var output = Cuboid.ByLengths(1,1,1);
   var toDispose = new List&lt;Geometry&gt;();

   for(int i = 0; i&lt;10000;i++){
     toDispose.Add(Cuboid.ByLengths(1,1,1));
   }

   foreach(IDisposable item in toDispose ){
     item.Dispose();
   }

   return output;
 }
</code></pre>
<p>In general you only need to dispose geometry like <code>Surfaces</code>, <code>Curves</code>, and <code>Solids</code>. To be safe though, you can dispose all geometry types (<code>Vectors</code>, <code>Points</code>, <code>CoordinateSystems</code>).</p>
<div style="break-before: page; page-break-before: always;"></div><h1 id="managing-your-program"><a class="header" href="#managing-your-program">Managing Your Program</a></h1>
<p>Working within a Visual Programming process can be a powerful creative activity, but very quickly the Program Flow and key user inputs can be obscured by complexity and/or layout of the Workspace. Let's review some best practices for managing your program.</p>
<h3 id="alignment"><a class="header" href="#alignment">Alignment </a></h3>
<p>Once we have added more than a few Nodes to the Workspace, we may want to re-organize the layout of the Nodes for clarity's sake. By selecting more than one Node and right-clicking on the Workspace, the pop up window includes an <strong>Align Selection</strong> menu with justification and distribution options in X and Y.</p>
<p><img src="9_best_practices/./images/4/managingyourprogram-alignment.jpg" alt="" /></p>
<blockquote>
<ol>
<li>Select more than one Node</li>
<li>Right-click on the Workspace</li>
<li>Use the <strong>Align Selection</strong> options</li>
</ol>
</blockquote>
<h3 id="notes"><a class="header" href="#notes">Notes </a></h3>
<p>With some experience, we may be able to &quot;read&quot; the Visual Program by reviewing the Node Names and following the Program Flow. For users of all experience levels, it is also good practice to include plain language labels and descriptions. Dynamo has a <strong>Notes</strong> Node with an editable text field to do so. We can add Notes to the Workspace in two ways:</p>
<p><img src="9_best_practices/./images/4/managingyourprogram-notes.jpg" alt="" /></p>
<blockquote>
<ol>
<li>Browse to the menu Edit &gt; Create Note</li>
<li>Use the keyboard shortcut Ctrl+W</li>
</ol>
</blockquote>
<p>Once the Note is added to the Workspace a text field will pop up allowing us to edit the text in the Note. After they are created, we can edit the Note by double-clicking or right-clicking the Note Node.</p>
<p><img src="9_best_practices/./images/4/managingyourprogram-notes02.jpg" alt="" /></p>
<h3 id="grouping"><a class="header" href="#grouping">Grouping </a></h3>
<p>When our Visual Program gets big, it is helpful to identify the larger steps that will be executed. We can highlight larger collections of Nodes with a <strong>Group</strong> to label them with a colored rectangle in the background and a title. There are three ways to make a Group with more than one Node selected:</p>
<p><img src="9_best_practices/./images/4/managingyourprogram-grouping01.jpg" alt="" /></p>
<blockquote>
<ol>
<li>Browse to the menu Edit &gt; Create Group</li>
<li>Use the keyboard shortcut Ctrl+G</li>
<li>Right-click on the Workspace and select &quot;Create Group&quot;</li>
</ol>
</blockquote>
<p>Once a Group is created we can edit its settings, such as the title and color. </p>
<p><img src="9_best_practices/./images/4/managingyourprogram-grouping02.jpg" alt="" /></p>
<p>{% hint style=&quot;info&quot; %}
Tip: Using both Notes and Groups is an effective way to annotate your file and increase readability.
{% endhint %}</p>
<p>Here's an example of program from with Notes and Groups added:</p>
<p><img src="9_best_practices/./images/4/managingyourprogram-grouping03.jpg" alt="" /></p>
<blockquote>
<ol>
<li>Note: &quot;Grid Parameters&quot;</li>
<li>Note: &quot;Grid Points&quot;</li>
<li>Group: &quot;Create a Grid of Points&quot;</li>
<li>Group: &quot;Create an Attractor Point&quot;</li>
<li>Note: &quot;Calibrate Distance Values&quot;</li>
<li>Note: &quot;Variable Grid of Circles&quot;</li>
</ol>
</blockquote>
<div style="break-before: page; page-break-before: always;"></div><h1 id="sample-workflows"><a class="header" href="#sample-workflows">Sample Workflows</a></h1>
<p>This section will explore a series of workflows that will guide you through using Dynamo.</p>
<p>The following sample workflows are available:</p>
<p><strong>Getting Started Workflows</strong></p>
<ul>
<li><a href="10_sample_workflow/10-1_getting-started-workflows/1-parametric-vase.html">Parametric Vase</a></li>
<li><a href="10_sample_workflow/10-1_getting-started-workflows/2-attractor-points.html">Attractor Points</a></li>
</ul>
<p>You can also locate concepts introduced in workflows using the <a href="10_sample_workflow/table-of-summary-for-some-concept-used-in-previous-exercises.html">concept index</a></p>
<div style="break-before: page; page-break-before: always;"></div><h1 id="getting-started-workflows"><a class="header" href="#getting-started-workflows">Getting Started Workflows</a></h1>
<p>This section has simple workflows to get you started using Dynamo. </p>
<p><img src="10_sample_workflow/10-1_getting-started-workflows/../images/10-1/sampleWorkflows.gif" alt="" /></p>
<div style="break-before: page; page-break-before: always;"></div><hr />
<h2 id="description-suggested-exercise"><a class="header" href="#description-suggested-exercise">description: suggested exercise</a></h2>
<h1 id="parametric-vase"><a class="header" href="#parametric-vase">Parametric Vase</a></h1>
<p>Creating a parametric vase is a great way to start learning Dynamo.</p>
<p>This workflow will teach you how to:</p>
<ul>
<li>Use number sliders to control variables in your design.</li>
<li>Create and modify geometric elements using nodes.</li>
<li>Visualize design results in real-time.</li>
</ul>
<p><img src="10_sample_workflow/10-1_getting-started-workflows/../images/10-1/1/vase1(3).gif" alt="" /></p>
<h2 id="defining-our-objectives"><a class="header" href="#defining-our-objectives">Defining Our Objectives</a></h2>
<p>Before jumping into dynamo let's conceptually design our vase.</p>
<p>Let's say we are going to design a clay vase that takes into account manufacturing practices used by ceramists. Ceramists normally use a pottery wheel to fabricate cylindrical vases. Then, by applying pressure on various heights of the vase they can alter the shape of the vase and create varied designs.</p>
<p>We would use a similar methodology to define our vase. We will create 4 circles at different heights and radii and we will then create a surface by lofting those circles.</p>
<p><img src="10_sample_workflow/10-1_getting-started-workflows/../images/10-1/1/vase2.png" alt="" /></p>
<h2 id="getting-started"><a class="header" href="#getting-started">Getting Started</a></h2>
<blockquote>
<p>Download the example file by clicking on the link below.</p>
<p>A full list of example files can be found in the Appendix.</p>
</blockquote>
<p>{% file src=&quot;../datasets/10-1/1/DynamoSampleWorkflow-vase.dyn&quot; %}</p>
<p>We need the nodes that will represent the sequence of actions Dynamo will execute. Since we know we are trying to create a circle, let's start by locating a node that does so. Use the <strong>Search field</strong> or browse through the <strong>Library</strong> to find the <strong>Circle.ByCenterPointRadius</strong> node and add it to the Workspace</p>
<p><img src="10_sample_workflow/10-1_getting-started-workflows/../images/10-1/1/vase8.png" alt="" /></p>
<blockquote>
<ol>
<li>Search &gt; &quot;Circle...&quot;</li>
<li>Select &gt; &quot;ByCenterPointRadius&quot;</li>
<li>Node will appear in workspace</li>
</ol>
</blockquote>
<p>Let's take a closer look at this node. On the left side, you have the node's inputs (<em>centerPoint</em> and <em>radius</em>) and on the right side, you have the node's output (Circle). Notice that the outputs have a light blue line. This means that the input has a default value. To get more information about the input hover over its name. The <em>radius</em> input needs a double input and has a default value of 1.</p>
<p><img src="10_sample_workflow/10-1_getting-started-workflows/../images/10-1/1/vase10.png" alt="" /></p>
<p>We will leave the default value of <em>centerPoint</em> but add a <strong>Number Slider</strong> to control the radius. As we did with the <strong>Circle.ByCenterPointRadius</strong> node, use the library to search for <strong>Number Slider</strong> and add it to your graph.</p>
<p>This node is a bit different than our previous node as it contains a slider. You can use the interface to change the output value of the slider.</p>
<p><img src="10_sample_workflow/10-1_getting-started-workflows/../images/10-1/1/vase13(1).gif" alt="" /></p>
<p>The slider can be configured using the dropdown button at the left of the node. Let's limit the slider to a maximum value of 15.</p>
<p><img src="10_sample_workflow/10-1_getting-started-workflows/../images/10-1/1/vase11.png" alt="" /></p>
<p>Let's place it on the left of our <strong>Circle.ByCenterPointRadius</strong> node and connect both nodes by selecting the <strong>Number Slider</strong> output and connecting it to the Radius input.</p>
<p><img src="10_sample_workflow/10-1_getting-started-workflows/../images/10-1/1/vase12.png" alt="" /></p>
<p>Let's also change the Number Slider name to &quot;Top Radius&quot; by double-clicking on the node's name.</p>
<p><img src="10_sample_workflow/10-1_getting-started-workflows/../images/10-1/1/vase14.png" alt="" /></p>
<h2 id="next-steps"><a class="header" href="#next-steps">Next steps</a></h2>
<p>Let's continue adding some nodes and connections to our logic to define our vase.</p>
<h3 id="creating-circles-of-different-radii"><a class="header" href="#creating-circles-of-different-radii">Creating Circles of Different Radii</a></h3>
<p>Let's copy these nodes 4 times so that these circles define our surface, change the Number Slider's names as shown below.</p>
<p><img src="10_sample_workflow/10-1_getting-started-workflows/../images/10-1/1/vase4(1)(1).png" alt="" /></p>
<blockquote>
<ol>
<li>Circles are created by a center point and a radius</li>
</ol>
</blockquote>
<h3 id="moving-circles-through-the-vase-height"><a class="header" href="#moving-circles-through-the-vase-height">Moving Circles Through the Vase Height</a></h3>
<p>We are missing a key parameter to our vase, its height. In order to control the vase's height, we create another number slider. We also add a <strong>Code Block</strong> node. Code blocks can help as add personalized code snippets to our workflow. We will use the code block to multiply the height slider by different factors so that we can position our circles along the vase's height.</p>
<p><img src="10_sample_workflow/10-1_getting-started-workflows/../images/10-1/1/vase15(1).png" alt="" /></p>
<p>We then use a <strong>Geometry.Translate</strong> node to place circles at the desired height. Since we want to distribute our circles through the vase we use code blocks to multiply the height parameter by a factor.</p>
<p><img src="10_sample_workflow/10-1_getting-started-workflows/../images/10-1/1/vase5.png" alt="" /></p>
<blockquote>
<p>2. Circles are translated (moved) by a variable in the z axis.</p>
</blockquote>
<h3 id="creating-the-surface"><a class="header" href="#creating-the-surface">Creating the Surface</a></h3>
<p>In order to create a surface using the <strong>Surface.ByLoft</strong> node we need to combine all of our translated circles into a list. We use the <strong>List.Create</strong> to combine all of our circles into a single list, and then finally output this list to the <strong>Surface.ByLoft</strong> node to view results.</p>
<p>Let's also turn off the preview in other nodes to only display the Surface.ByLoft display.</p>
<p><img src="10_sample_workflow/10-1_getting-started-workflows/../images/10-1/1/vase6(1)(1).png" alt="" /></p>
<blockquote>
<p>3. A surface is created by lofting the translated circles.</p>
</blockquote>
<h2 id="results"><a class="header" href="#results">Results</a></h2>
<p>Our workflow is ready! We can now use the <strong>Number Sliders</strong> we defined in our script to create different vase designs.</p>
<p><img src="10_sample_workflow/10-1_getting-started-workflows/../images/10-1/1/vase1(3).gif" alt="" /></p>
<p><img src="10_sample_workflow/10-1_getting-started-workflows/../images/10-1/1/vase7.png" alt="" /></p>
<div style="break-before: page; page-break-before: always;"></div><h1 id="attractor-points"><a class="header" href="#attractor-points">Attractor Points</a></h1>
<p>Attractor points are great for experimenting with geometric patterns. They can be used to create gradual changes to objects based on their distance.</p>
<p>This workflow will teach you how to:</p>
<ul>
<li>Create, manage and edit lists.</li>
<li>Move points in the 3D preview using direct manipulation.</li>
<li>Change the executing mode.</li>
</ul>
<p><img src="10_sample_workflow/10-1_getting-started-workflows/../images/10-1/2/attractor1.gif" alt="" /></p>
<h2 id="defining-our-objectives-1"><a class="header" href="#defining-our-objectives-1">Defining our Objectives</a></h2>
<p>In this exercise, we want to create a circle (<em>Objective</em>) where the radius input is defined by a distance to a nearby point (<em>Relationship</em>).</p>
<p><img src="10_sample_workflow/10-1_getting-started-workflows/../images/10-1/2/00-Hand-Sketch-of-Circle.png" alt="Hand Sketch of Circle" /></p>
<blockquote>
<p>A point that defines a distance-based relationship is commonly referred to as an &quot;Attractor.&quot; Here the distance to our Attractor Point will be used to specify how big our circle should be.</p>
</blockquote>
<h2 id="next-steps-1"><a class="header" href="#next-steps-1">Next steps</a></h2>
<blockquote>
<p>Download the example file by clicking on the link below.</p>
<p>A full list of example files can be found in the Appendix.</p>
</blockquote>
<p>{% file src=&quot;../datasets/10-1/2/DynamoSampleWorkflow-Attractors.dyn&quot; %}</p>
<p>Now that we have our objectives and relationships sketched we can begin creating our graph. We need the Nodes that will represent the sequence of actions Dynamo will execute. Let's start by adding the following nodes: <strong>Number</strong>, <strong>Number Slider</strong>, <strong>Point.ByCoordinates</strong>, <strong>Geometry.DistanceTo, Circle.ByCenterPointRadius.</strong></p>
<p><img src="10_sample_workflow/10-1_getting-started-workflows/../images/10-1/2/attractor(2).png" alt="" /></p>
<blockquote>
<ol>
<li>Input &gt; Basic &gt; <strong>Number</strong></li>
<li>Input &gt; Basic &gt; <strong>Number Slider</strong></li>
<li>Geometry &gt; Points &gt; Point &gt; <strong>By Coordinates(x,y,z)</strong></li>
<li>Geometry &gt; Modifiers &gt; Geometry &gt; <strong>DistanceTo</strong></li>
<li>Geometry &gt; Curves &gt; Circle &gt; <strong>ByCenterPointRadius</strong></li>
</ol>
</blockquote>
<h3 id="connecting-nodes-with-wires"><a class="header" href="#connecting-nodes-with-wires">Connecting Nodes with Wires</a></h3>
<p>Now that we have a few Nodes, we need to connect the Ports of the Nodes with Wires. These connections will define the flow of data.</p>
<p><img src="10_sample_workflow/10-1_getting-started-workflows/../images/10-1/2/attractor(3).png" alt="" /></p>
<blockquote>
<ol>
<li><strong>Number</strong> to <strong>Point.ByCoordinates</strong></li>
<li><strong>Number Sliders</strong> to <strong>Point.ByCoordinates</strong></li>
<li><strong>Point.ByCoordinates</strong> (2) to <strong>DistanceTo</strong></li>
<li><strong>Point.ByCoordinates</strong> and <strong>DistanceTo</strong> to <strong>Circle.ByCenterPointRadius</strong></li>
</ol>
</blockquote>
<h3 id="executing-the-program"><a class="header" href="#executing-the-program">Executing the Program</a></h3>
<p>With our Program Flow defined, all we need to do is tell Dynamo to execute it. Once our program is executed (either Automatically or when we click Run in Manual Mode), data will pass through the Wires, and we should see the results in the 3d Preview.</p>
<p><img src="10_sample_workflow/10-1_getting-started-workflows/../images/10-1/2/attractor(4).png" alt="" /></p>
<blockquote>
<ol>
<li>(Click Run) - If the Execution Bar is in Manual Mode, we need to Click Run to execute the graph</li>
<li>Node Preview - Hovering your mouse over the box on the lower right corner of a Node will give you a pop-up of the results</li>
<li>3D Preview - If any of our Nodes create geometry, we will see it in the 3D Preview.</li>
<li>The output geometry on the creation node.</li>
</ol>
</blockquote>
<h3 id="adding-a-code-block"><a class="header" href="#adding-a-code-block">Adding <strong>a Code Block</strong></a></h3>
<p>If our program is working, we should see a circle in the 3D Preview that is passing through our Attractor Point. This is great, but we may want to add more detail or more controls. Let's adjust the input to the circle Node so that we can calibrate the influence on the radius. Add another <strong>Number Slider</strong> to the Workspace, then double click on a blank area of the Workspace to add a <strong>Code Block</strong> Node. Edit the field in the Code Block, specifying <code>X/Y</code>.</p>
<p><img src="10_sample_workflow/10-1_getting-started-workflows/../images/10-1/2/attractor(5).png" alt="" /></p>
<blockquote>
<ol>
<li><strong>Code Block</strong></li>
<li><strong>DistanceTo</strong> and <strong>Number Slider</strong> to <strong>Code Block</strong></li>
<li><strong>Code Block</strong> to <strong>Circle.ByCenterPointRadius</strong></li>
</ol>
</blockquote>
<h3 id="using-sequences"><a class="header" href="#using-sequences">Using Sequences</a></h3>
<p>Starting simple and building complexity is an effective way to incrementally develop our program. Once it is working for one circle, let's apply the power of the program to more than one circle. Instead of one center point, if we use a grid of points and accommodate the change in the resulting data structure, our program will now create many circles - each with a unique radius value defined by the calibrated distance to the Attractor Point.</p>
<p><img src="10_sample_workflow/10-1_getting-started-workflows/../images/10-1/2/attractor(6).png" alt="" /></p>
<blockquote>
<ol>
<li>Add a <strong>Number Sequence</strong> Node and replace the inputs of <strong>Point.ByCoordinates</strong> - Right Click Point.ByCoordinates and select Lacing &gt; Cross Reference</li>
<li>Add a <strong>Flatten</strong> Node after Point.ByCoordinates. To flatten a list completely, leave the <code>amt</code> input at the default of <code>-1</code></li>
<li>The 3D Preview will update with a grid of circles</li>
</ol>
</blockquote>
<h3 id="adjusting-with-direct-manipulation"><a class="header" href="#adjusting-with-direct-manipulation">Adjusting with Direct Manipulation</a></h3>
<p>Sometimes numerical manipulation isn't the right approach. Now you can manually push and pull Point geometry when navigating in the background 3D preview. We can also control other geometry that was constructed by a point. For example, <strong>Sphere.ByCenterPointRadius</strong> is capable of Direct Manipulation as well. We can control the location of a point from a series of X, Y, and Z values with <strong>Point.ByCoordinates</strong>. With the Direct Manipulation approach, however, you are able to update the values of the sliders by manually moving the point in the <strong>3D Preview Navigation</strong> mode. This offers a more intuitive approach to controlling a set of discrete values that identify a point's location.</p>
<p><img src="10_sample_workflow/10-1_getting-started-workflows/../images/10-1/2/attractor(7).png" alt="" /></p>
<blockquote>
<ol>
<li>To use <strong>Direct Manipulation</strong>, select the panel of the point to be moved  arrows will appear over the point selected.</li>
<li>Switch to <strong>3D Preview Navigation</strong> mode.</li>
</ol>
</blockquote>
<p><img src="10_sample_workflow/10-1_getting-started-workflows/../images/10-1/2/attractor(8).png" alt="" /></p>
<blockquote>
<ol>
<li>Hover over the point and the X, Y, and Z axes will appear.</li>
<li>Click and drag the colored arrow to move the corresponding axis, and the <strong>Number Slider</strong> values will update live with the manually moved point.</li>
</ol>
</blockquote>
<p><img src="10_sample_workflow/10-1_getting-started-workflows/../images/10-1/2/attractor(1).png" alt="" /></p>
<blockquote>
<ol>
<li>Note that before <strong>Direct Manipulation</strong> only one slider was plugged into the <strong>Point.ByCoordinates</strong> component. When we manually move the point in the X-direction, Dynamo will automatically generate a new <strong>Number Slider</strong> for the X input.</li>
</ol>
</blockquote>
<div style="break-before: page; page-break-before: always;"></div><hr />
<h2>description: &gt;-
The following list can be used to locate concepts introduced in the sample
workflows.</h2>
<h1 id="concept-index"><a class="header" href="#concept-index">Concept Index</a></h1>
<div class="table-wrapper"><table><thead><tr><th>Exercise list</th><th>Key concepts introduced in exercise</th><th>Link to further reading in later chapters</th></tr></thead><tbody>
<tr><td>Parametric Vase</td><td>Searching nodes throught the library</td><td><a href="10_sample_workflow/../3_user_interface/2-library.html">Library</a></td></tr>
<tr><td></td><td>Using nodes and wires</td><td><a href="10_sample_workflow/../4_nodes_and_wires/">Nodes and Wires</a></td></tr>
<tr><td></td><td>Creating curves and surfaces</td><td><a href="10_sample_workflow/../5_essential_nodes_and_concepts/5-2_geometry-for-computational-design/">Geometry for Computational Design</a></td></tr>
<tr><td></td><td>Using code blocks</td><td><a href="10_sample_workflow/../8_coding_in_dynamo/8-1_code-blocks-and-design-script/">Code Blocks and DesignScript</a></td></tr>
<tr><td>Attractor Points</td><td>Create manage and edit lists</td><td><a href="10_sample_workflow/../5_essential_nodes_and_concepts/5-4_designing-with-lists/">Designing with Lists</a></td></tr>
<tr><td></td><td>Changing preview modes</td><td><a href="10_sample_workflow/../3_user_interface/1-workspace.html#preview-mode">Preview Mode</a></td></tr>
<tr><td></td><td>Changing execution modes</td><td><a href="10_sample_workflow/../3_user_interface/#execution-bar">Execution Bar</a></td></tr>
</tbody></table>
</div><div style="break-before: page; page-break-before: always;"></div><h1 id="appendix"><a class="header" href="#appendix">Appendix</a></h1>
<p>In this section, you can find additional resources for taking your Dynamo game one step further. We've also added an index of important nodes, a collection of useful packages, and a repository of the example files in this primer. Please feel free to add to this section...remember, the <a href="https://github.com/DynamoDS/DynamoPrimer">Dynamo Primer</a> is open source!</p>
<p> </p>
<p><img src="a_appendix/./images/a-cover.png" alt="" /></p>
<div style="break-before: page; page-break-before: always;"></div><h1 id="visual-programming-and-dynamo"><a class="header" href="#visual-programming-and-dynamo">Visual Programming and Dynamo</a></h1>
<h4 id="what-is-visual-programming"><a class="header" href="#what-is-visual-programming">What is Visual Programming? <a href="a_appendix/a-1_visual-programming-and-dynamo.html#what-is-visual-programming" id="what-is-visual-programming"></a></a></h4>
<p>Designing frequently involves establishing visual, systemic, or geometric relationships between the parts of a design. More times than not, these relationships are developed by workflows that gets us from concept to result by way of rules. Perhaps without knowing it, we are working algorithmically - defining a step-by-step set of actions that follow a basic logic of input, processing, and output. Programming allows us to continue to work this way but by formalizing our algorithms.</p>
<h4 id="algorithms-in-hand"><a class="header" href="#algorithms-in-hand">Algorithms in Hand <a href="a_appendix/a-1_visual-programming-and-dynamo.html#algorithms-in-hand" id="algorithms-in-hand"></a></a></h4>
<p>While offering some powerful opportunities, the term <strong>Algorithm</strong> can carry some misconceptions with it. Algorithms can generate unexpected, wild, or cool things, but they are not magic. In fact, they are pretty plain, in and of themselves. Let's use a tangible example like an origami crane. We start with a square piece of paper (input), follow a series of folding steps (processing actions), and result in a crane (output).</p>
<p><img src="https://primer.dynamobim.org/01_Introduction/images/1-1/00-OrigamiCrane.png" alt="Origami Crane" /></p>
<p>So where is the Algorithm? It is the abstract set of steps, which we can represent in a couple of ways - either textually or graphically.</p>
<p><strong>Textual Instructions:</strong></p>
<ol>
<li>Start with a square piece of paper, colored side up. Fold in half and open. Then fold in half the other way.</li>
<li>Turn the paper over to the white side. Fold the paper in half, crease well and open, and then fold again in the other direction.</li>
<li>Using the creases you have made, Bring the top 3 corners of the model down to the bottom corner. Flatten model.</li>
<li>Fold top triangular flaps into the center and unfold.</li>
<li>Fold top of model downwards, crease well and unfold.</li>
<li>Open the uppermost flap of the model, bringing it upwards and pressing the sides of the model inwards at the same time. Flatten down, creasing well.</li>
<li>Turn model over and repeat Steps 4-6 on the other side.</li>
<li>Fold top flaps into the center.</li>
<li>Repeat on other side.</li>
<li>Fold both legs of model up, crease very well, then unfold.</li>
<li>Inside Reverse Fold the legs along the creases you just made.</li>
<li>Inside Reverse Fold one side to make a head, then fold down the wings.</li>
<li>You now have a crane.</li>
</ol>
<p><strong>Graphical Instructions:</strong></p>
<p><img src="https://primer.dynamobim.org/01_Introduction/images/1-1/01-OrigamiCraneInstructions.png" alt="Origami Crane instructions" /></p>
<h4 id="programming-defined"><a class="header" href="#programming-defined">Programming Defined <a href="a_appendix/a-1_visual-programming-and-dynamo.html#programming-defined" id="programming-defined"></a></a></h4>
<p>Using either of these sets of instructions should result in a crane, and if you followed along yourself, you've applied an algorithm. The only difference is the way in which we read the formalization of that set of instructions and that leads us to <strong>Programming</strong>. Programming, frequently shortened from <em>Computer Programming</em>, is the act of formalizing the processing of a series of actions into an executable program. If we turned the above instructions for a creating crane into a format our computer can read and execute, we are Programming.</p>
<p>The key to and first hurdle we will find in Programming, is that we have to rely on some form of abstraction to communicate effectively with our computer. That takes the form of any number of Programming Languages, such as JavaScript, Python, or C. If we can write out a repeatable set of instructions, like for the origami crane, we only need to translate it for the computer. We are on our way to having the computer be able to make a crane or even a multitude of different cranes where each one varies slightly. This is the power of Programming - the computer will repeatedly execute whatever task, or set of tasks, we assign to it, without delay and without human error.</p>
<p><strong>Visual Programming Defined</strong></p>
<blockquote>
<p>Download the example file by clicking on the link below.</p>
<p>A full list of example files can be found in the Appendix.</p>
</blockquote>
<p>{% file src=&quot;../.gitbook/assets/Visual Programming - Circle Through Point.dyn&quot; %}</p>
<p>If you were tasked with writing instructions for folding an origami crane, how would you go about it? Would you make them with graphics, text, or some combination of the two?</p>
<p>If your answer contained graphics, then <strong>Visual Programming</strong> is definitely for you. The process is essentially the same for both Programming and Visual Programming. They utilize the same framework of formalization; however, we define the instructions and relationships of our program through a graphical (or &quot;Visual&quot;) user interface. Instead of typing text bound by syntax, we connect pre-packaged nodes together. Here's a comparison of the same algorithm - &quot;draw a circle through a point&quot; - programmed with nodes versus code:</p>
<p><strong>Visual Program:</strong></p>
<p><img src="a_appendix/./images/a-1/visualProgramming(2).png" alt="" /></p>
<p><strong>Textual Program:</strong></p>
<pre><code>myPoint = Point.ByCoordinates(0.0,0.0,0.0);
x = 5.6;
y = 11.5;
attractorPoint = Point.ByCoordinates(x,y,0.0);
dist = myPoint.DistanceTo(attractorPoint);
myCircle = Circle.ByCenterPointRadius(myPoint,dist);
</code></pre>
<p>The results of our algorithm:</p>
<p><img src="a_appendix/./images/a-1/visualProgramming(1).png" alt="" /></p>
<p>The visual characteristic to programming in such a way lowers the barrier to entry and frequently speaks to designers. Dynamo falls in the Visual Programming paradigm, but as we will see later, we can still use textual programming in the application as well.</p>
<div style="break-before: page; page-break-before: always;"></div><h1 id="resources"><a class="header" href="#resources">Resources</a></h1>
<h2 id="dynamo"><a class="header" href="#dynamo"><strong>Dynamo</strong></a></h2>
<h3 id="dynamo-wiki"><a class="header" href="#dynamo-wiki"><strong>Dynamo Wiki</strong></a></h3>
<p>&quot;This wiki is for learning about development using the Dynamo API, supporting libraries and tools.&quot;</p>
<p><a href="https://github.com/DynamoDS/Dynamo/wiki">https://github.com/DynamoDS/Dynamo/wiki</a></p>
<h3 id="dynamo-blog"><a class="header" href="#dynamo-blog"><strong>Dynamo Blog</strong></a></h3>
<p>This blog is the most up-to-date collection of articles from the Dynamo team, discussing new features, workflows, and all things Dynamo.</p>
<p><a href="http://dynamobim.com/blog/">http://dynamobim.com/blog/</a></p>
<h3 id="designscript-guide"><a class="header" href="#designscript-guide"><strong>DesignScript Guide</strong></a></h3>
<p>Programming languages are created to express ideas, usually involving logic and calculation. In addition to these objectives, the Dynamo textual language (formerly DesignScript) has been created to express design intentions. It is generally recognized that computational designing is exploratory, and Dynamo tries to support this: we hope you find the language flexible and fast enough to take a design from concept, through design iterations, to your final form. This manual is structured to give a user with no knowledge of either programming or architectural geometry full exposure to a variety of topics in these two intersecting disciplines.</p>
<p><a href="http://dynamobim.org/wp-content/links/DesignScriptGuide.pdf">http://dynamobim.org/wp-content/links/DesignScriptGuide.pdf</a></p>
<h3 id="the-dynamo-primer-project-1"><a class="header" href="#the-dynamo-primer-project-1"><strong>The Dynamo Primer Project</strong></a></h3>
<p>The Dynamo Primer is an open source project, initiated by Matt Jezyk and the Dynamo Development team at Autodesk. The first version of the primer was developed by Mode Lab. To contribute, fork the repo, add your content, and submit a pull request.</p>
<p><a href="https://github.com/DynamoDS/DynamoPrimer">https://github.com/DynamoDS/DynamoPrimer</a></p>
<h3 id="zero-touch-plugin-development-for-dynamo"><a class="header" href="#zero-touch-plugin-development-for-dynamo"><strong>Zero Touch Plugin Development for Dynamo</strong></a></h3>
<p>This page outlines the process of developing a custom Dynamo node in C# using the &quot;Zero Touch&quot; interface. In most cases, C# static methods and Classes can be imported without modification. If your library only needs to call functions, and not construct new objects, this can be achieved very easily with static methods. When Dynamo loads your DLL, it will strip off the namespace of your classes, and expose all static methods as nodes.</p>
<p><a href="https://github.com/DynamoDS/Dynamo/wiki/Zero-Touch-Plugin-Development">https://github.com/DynamoDS/Dynamo/wiki/Zero-Touch-Plugin-Development</a></p>
<h2 id="external-resources"><a class="header" href="#external-resources"><strong>External Resources</strong></a></h2>
<h3 id="python-for-beginners"><a class="header" href="#python-for-beginners"><strong>Python for Beginners</strong></a></h3>
<p>Python is an interpreted, interactive, object-oriented programming language. It incorporates modules, exceptions, dynamic typing, very high level dynamic data types, and classes. Python combines remarkable power with very clear syntax. It has interfaces to many system calls and libraries, as well as to various window systems, and is extensible in C or C++. It is also usable as an extension language for applications that need a programmable interface. Finally, Python is portable: it runs on many Unix variants, on the Mac, and on Windows 2000 and later. The Beginners Guide to Python links to other introductory tutorials and resources for learning Python.</p>
<p><a href="https://www.python.org/about/gettingstarted">https://www.python.org/about/gettingstarted</a></p>
<h3 id="aforge"><a class="header" href="#aforge"><strong>AForge</strong></a></h3>
<p>AForge.NET is an open source C# framework designed for developers and researchers in the fields of Computer Vision and Artificial Intelligence - image processing, neural networks, genetic algorithms, fuzzy logic, machine learning, robotics, etc.</p>
<p><a href="http://www.aforgenet.com/framework/">http://www.aforgenet.com/framework/</a></p>
<h3 id="wolfram-mathworld"><a class="header" href="#wolfram-mathworld"><strong>Wolfram MathWorld</strong></a></h3>
<p>MathWorld is an online mathematics resource, assembled by Eric W. Weisstein with assistance from thousands of contributors. Since its contents first appeared online in 1995, MathWorld has emerged as a nexus of mathematical information in both the mathematics and educational communities. Its entries are extensively referenced in journals and books spanning all educational levels.</p>
<p><a href="http://mathworld.wolfram.com">http://mathworld.wolfram.com/</a></p>
<h2 id="revit-resources"><a class="header" href="#revit-resources">Revit Resources</a></h2>
<h3 id="buildz"><a class="header" href="#buildz"><strong>buildz</strong></a></h3>
<p>&quot;These posts are mainly about the Revit platform, with recommendations on how to enjoy it.&quot;</p>
<p><a href="http://buildz.blogspot.com">http://buildz.blogspot.com/</a></p>
<h3 id="nathans-revit-api-notebook"><a class="header" href="#nathans-revit-api-notebook"><strong>Nathan's Revit API Notebook</strong></a></h3>
<p>&quot;This notebook attempts to remedy a few 'resource deficiencies' in learning and applying the Revit API in the context of a design workflow&quot;</p>
<p><a href="http://wiki.theprovingground.org/revit-api">http://wiki.theprovingground.org/revit-api</a></p>
<h3 id="revit-python-shell"><a class="header" href="#revit-python-shell"><strong>Revit Python Shell</strong></a></h3>
<p>&quot;The RevitPythonShell adds an IronPython interpreter to Autodesk Revit and Vasari.&quot; This project pre-dates Dynamo and is a great reference for Python development. RPS Project: </p>
<p>https://github.com/architecture-building-systems/revitpythonshell </p>
<p>Developer's Blog: </p>
<p><a href="http://darenatwork.blogspot.com">http://darenatwork.blogspot.com/</a></p>
<h3 id="the-building-coder"><a class="header" href="#the-building-coder"><strong>The Building Coder</strong></a></h3>
<p>A robust catalog of Revit API workflows from one of the leading experts in BIM.</p>
<p><a href="http://thebuildingcoder.typepad.com">http://thebuildingcoder.typepad.com/</a></p>
<div style="break-before: page; page-break-before: always;"></div><h1 id="useful-packages"><a class="header" href="#useful-packages">Useful Packages</a></h1>
<p>Here are a list of some of the more popular packages in the Dynamo community. Developers, please add to the list! Remember, the <a href="https://github.com/DynamoDS/DynamoPrimer">Dynamo Primer</a> is open-source!</p>
<div class="table-wrapper"><table><thead><tr><th><img src="a_appendix/images/a-3/archilab_L.jpg" alt="" /><strong>ARCHI-LAB</strong></th><th><a href="http://archi-lab.net">Visit the Official archi-lab Site</a></th></tr></thead><tbody>
<tr><td>archi-lab is a collection of over 50+ custom packages that vastly extend Dynamo's ability to interact with Revit. Nodes contained in archi-lab package vary from basic list operations to advanced Analysis Visualization Framework nodes for Revit. archi-lab is available on the package manager</td><td><img src="a_appendix/images/a-3/archilabImage.png" alt="" /></td></tr>
</tbody></table>
</div><div class="table-wrapper"><table><thead><tr><th><img src="a_appendix/images/a-3/BimorphDigitalEngineeringBLogo.png" alt="" /> <strong>BIMORPH NODES</strong></th><th><a href="https://bimorph.com/bimorph-nodes/">Visit the BimorphNodes Dictionary</a></th></tr></thead><tbody>
<tr><td>BimorphNodes is a versatile collection of powerful utility nodes. The package highlights include ultra-efficient clash detection and geometry intersection nodes, ImportInstance (CAD) curve conversion nodes, and linked element collectors that resolve limitations in the Revit API. To learn about the full range of nodes available, visit the BimorphNodes dictionary. BimorphNodes is available on the package manager.</td><td><img src="a_appendix/images/a-3/Bimorph-Nodes-v2.2-Library-Catalog-header.jpg" alt="" /></td></tr>
</tbody></table>
</div><div class="table-wrapper"><table><thead><tr><th><img src="a_appendix/images/a-3/logo02.png" alt="" /> <strong>BUMBLEBEE FOR DYNAMO</strong></th><th><a href="http://archi-lab.net/bumblebee-dynamo-and-excel-interop/">Visit the Official BumbleBee Site</a></th></tr></thead><tbody>
<tr><td>Bumblebee is an Excel and Dynamo interoperability plugin that vastly improves Dynamos ability to read and write Excel files.</td><td><img src="a_appendix/images/a-3/screengrab02.png" alt="" /></td></tr>
</tbody></table>
</div><div class="table-wrapper"><table><thead><tr><th><img src="a_appendix/images/a-3/logo01.png" alt="" /><strong>CLOCKWORK FOR DYNAMO</strong></th><th><a href="https://github.com/CAAD-RWTH/ClockworkForDynamo">Visit the Clockwork For Dynamo GitHub</a></th></tr></thead><tbody>
<tr><td>Clockwork is a collection of custom nodes for the Dynamo visual programming environment. It contains many Revit-related nodes, but also lots of nodes for various other purposes such as list management, mathematical operations, string operations, unit conversions, geometric operations (mainly bounding boxes, meshes, planes, points, surfaces, UVs and vectors) and paneling.</td><td><img src="a_appendix/images/a-3/screengrab01.png" alt="" /></td></tr>
</tbody></table>
</div><div class="table-wrapper"><table><thead><tr><th><img src="a_appendix/images/a-3/DataShapes_L.png" alt="" /> <strong>DATA|SHAPES</strong></th><th><a href="https://github.com/MostafaElAyoubi/Data-shapes">Visit Data|Shapes on GitHub</a></th></tr></thead><tbody>
<tr><td>DataShapes is a package that aims to extend the user functionality of Dynamo scripts. This has a heavy focus on adding greater functionality to Dynamo player. For more infor visit https://data-shapes.net/. Want to create awesome Dynamo player workflows? Use this package.</td><td><img src="a_appendix/../.gitbook/assets/DataShapes_Image.png" alt="" /></td></tr>
</tbody></table>
</div><div class="table-wrapper"><table><thead><tr><th><img src="a_appendix/../.gitbook/assets/ds_L.png" alt="" /> <strong>DYNAMO SAP</strong></th><th><a href="http://core.thorntontomasetti.com/dynamosap-is-now-open-source/">Visit the DynamoSAP Project at Core Studio</a></th></tr></thead><tbody>
<tr><td>DynamoSAP is a parametric interface for SAP2000, built on top of Dynamo. The project enables designers and engineers to generatively author and analyze structural systems in SAP, using Dynamo to drive the SAP model. The project prescribes a few common workflows which are described in the included sample files, and provides a wide range of opportunities for automation of typical tasks in SAP.</td><td><img src="a_appendix/images/a-3/sapImage.png" alt="" /></td></tr>
</tbody></table>
</div><div class="table-wrapper"><table><thead><tr><th><img src="a_appendix/../.gitbook/assets/DynamoUnfold_L.png" alt="" /> <strong>DYNAMO UNFOLD</strong></th><th><a href="https://github.com/mjkkirschner/DynamoUnfold">Visit the DynamoUnfold GitHub</a></th></tr></thead><tbody>
<tr><td>This library extends Dynamo/Revit functionality by enabling users to unfold surface and poly-surface geometry. The library allows users to first translate surfaces into planar tessellated topology, then unfold them using Protogeometry tools in Dynamo. This package also includes some experimental nodes as well as a few basic sample files.</td><td><img src="a_appendix/../.gitbook/assets/DynamoUnfold_S.png" alt="" /></td></tr>
</tbody></table>
</div><div class="table-wrapper"><table><thead><tr><th><img src="a_appendix/images/a-3/Dynastrator_L.png" alt="" /> <strong>DYNASTRATOR</strong></th><th><a href="http://dynamopackages.com">Download Dynastrator at the Package Manager</a></th></tr></thead><tbody>
<tr><td>Import vector art from Illustrator or the web using .svg. This allows you to import manually created drawings into Dynamo for parametric operations.</td><td><img src="a_appendix/../.gitbook/assets/dynastratorImage.jpg" alt="" /></td></tr>
</tbody></table>
</div><div class="table-wrapper"><table><thead><tr><th><img src="a_appendix/../.gitbook/assets/ea_L.png" alt="" /> <strong>ENERGY ANALYSIS FOR DYNAMO</strong></th><th><a href="https://github.com/tt-acm/EnergyAnalysisForDynamo">Visit the Energy Analysis for Dynamo Project on GitHub</a></th></tr></thead><tbody>
<tr><td>Energy Analysis for Dynamo allows for parametric energy modeling and whole-building energy analysis workflows in Dynamo 0.8. Energy Analysis for Dynamo allows the user to configure the energy model from Autodesk Revit, submit to Green Building Studio for DOE2 energy analysis, and dig into the results returned from the analysis. The package is being developed by Thornton Tomasetti's CORE studio.</td><td><img src="a_appendix/images/a-3/eaImage.png" alt="" /></td></tr>
</tbody></table>
</div><div class="table-wrapper"><table><thead><tr><th><img src="a_appendix/images/a-3/Firefly_L.png" alt="" /> <strong>FIREFLY FOR DYNAMO</strong></th><th><a href="http://dynamopackages.com">Download Firefly at the Dynamo Package Manager</a></th></tr></thead><tbody>
<tr><td>Firefly is a collection of nodes which enable dynamo to talk to input/output devices, like the Arduino micro controller. Because the data flow happens live, Firefly opens up many opportunities for interactive prototyping between the digital and physical worlds through web cams, mobile phones, game controllers, sensors and more.</td><td><img src="a_appendix/images/a-3/Firefly_S.png" alt="" /></td></tr>
</tbody></table>
</div><div class="table-wrapper"><table><thead><tr><th><img src="a_appendix/images/a-3/geniuslocilogo.png" alt="" /> <strong>GENIUS LOCI</strong></th><th><a href="https://github.com/albandechasteigner/GeniusLociForDynamo">Visit the Genius Loci GitHub</a></th></tr></thead><tbody>
<tr><td>Genius Loci is a compilation of Nodes for Dynamo. It consists useful Nodes that benefits Revit users. Install the package to explore some of the features, such as interact easily with linked files and Revit Documents.</td><td><img src="a_appendix/images/a-3/geniuslocipackagesamplenodes.png" alt="" /></td></tr>
</tbody></table>
</div><div class="table-wrapper"><table><thead><tr><th><img src="a_appendix/images/a-3/mantisshrimpLogo.png" alt="" /> <strong>MANTIS SHRIMP</strong></th><th><a href="http://archi-lab.net/mantis-shrimp-getting-started/">Visit the official Mantis Shrimp site.</a></th></tr></thead><tbody>
<tr><td>Mantis Shrimp is an interoperability project that allows you to easily import Grasshopper and/or Rhino geometry into Dynamo.</td><td><img src="a_appendix/images/a-3/msImage.png" alt="" /></td></tr>
</tbody></table>
</div><div class="table-wrapper"><table><thead><tr><th><img src="a_appendix/../.gitbook/assets/MeshToolkit_L.png" alt="" /> <strong>MESH TOOLKIT</strong></th><th><a href="https://github.com/DynamoDS/Dynamo/wiki/Dynamo-Mesh-Toolkit">Visit the Dynamo Mesh Toolkit GitHub</a></th></tr></thead><tbody>
<tr><td>The Dynamo Mesh Toolkit provides many useful tools for working with mesh geometry. The functionality of this package includes the ability to import meshes from external file formats, generate meshes from pre-existing Dynamo geometry objects, and manually build meshes through vertices and connectivity information. Additionally, this toolkit includes tools to modify and repair mesh geometry.</td><td><img src="a_appendix/../.gitbook/assets/MeshToolkit_S.png" alt="" /></td></tr>
</tbody></table>
</div><div class="table-wrapper"><table><thead><tr><th> <strong>MONOCLE</strong></th><th><a href="https://github.com/johnpierson/MonocleForDynamo">Visit the Monocle GitHub</a></th></tr></thead><tbody>
<tr><td>Monocle is a View Extension for Dynamo 2.0.x. Monocle contains a set of useful tools for package identification, graph cleanup and more! Monocle aims to add functionality to the Dynamo UI in a seemless way that leaves you thinking, <em>&quot;is this built into dynamo?&quot;</em>. Monocle is available on the package manager.</td><td><img src="a_appendix/../.gitbook/assets/monocleImage.png" alt="" /></td></tr>
</tbody></table>
</div><div class="table-wrapper"><table><thead><tr><th><img src="a_appendix/../.gitbook/assets/Optimo_L.png" alt="" /> <strong>OPTIMO</strong></th><th><a href="https://github.com/BPOpt/Optimo/wiki/0_-Home">Visit the Optimo GitHub</a></th></tr></thead><tbody>
<tr><td>Optimo provides dynamo users with the capability to optimize self-defined design problems by using various evolutionary algorithms. Users can define the problem objective or set of objectives as well as specific fitness functions.</td><td><img src="a_appendix/images/a-3/Optimo_S.png" alt="" /></td></tr>
</tbody></table>
</div><div class="table-wrapper"><table><thead><tr><th><img src="a_appendix/../.gitbook/assets/Rhynamo_L.png" alt="" /> <strong>RHYNAMO</strong></th><th><a href="https://bitbucket.org/caseinc/rhynamo">Visit the Rhynamo Bitbucket</a></th></tr></thead><tbody>
<tr><td>The Rhynamo node library provides users with the ability to read and write Rhino 3DM files from within Dynamo. Rhynamo translates Rhino geometry into usable Dynamo geometry by using McNeels OpenNURBS library allowing for new workflows that can exchange geometry and data fluidly between Rhino and Revit. This package also contains some experimental nodes that allow for live access to the Rhino command line.</td><td><img src="a_appendix/images/a-3/Rhynamo_S.png" alt="" /></td></tr>
</tbody></table>
</div><div class="table-wrapper"><table><thead><tr><th><img src="a_appendix/images/a-3/Rhythm_L.png" alt="" /> <strong>RHYTHM</strong></th><th><a href="https://github.com/sixtysecondrevit/RhythmForDynamo">Visit Rhythm on GitHub</a></th></tr></thead><tbody>
<tr><td>Rhythm is a set of useful nodes to help your Revit project maintain a good rhythm with Dynamo. basically it does some pretty okay stuff. Rhythm is open source and primarily built in C#, and adds Revit nodes, core nodes and a view extension to your Dynamo. Rhythm is available on the package manager.</td><td><img src="a_appendix/images/a-3/Rhythm_Image.png" alt="" /></td></tr>
</tbody></table>
</div><div class="table-wrapper"><table><thead><tr><th><img src="a_appendix/../.gitbook/assets/Springs_L.png" alt="" /> <strong>Spring Nodes</strong></th><th><a href="https://github.com/dimven/SpringNodes">Visit Spring </a><a href="https://github.com/dimven/SpringNodes">Nodes on GitHub</a></th></tr></thead><tbody>
<tr><td>Spring nodes main focus is to improve Dynamo's interaction with Revit. The wider goal is to explore any and all means that can help accelerate BIM focused work-flows. Many of the nodes use either IronPython or DesignScript and can be a good starting point for learning the specific syntax and finer points of both. Spring nodes is available on the package manager.</td><td><img src="a_appendix/images/a-3/springNodes_image.jpg" alt="" /></td></tr>
</tbody></table>
</div><div style="break-before: page; page-break-before: always;"></div><h1 id="example-files-1"><a class="header" href="#example-files-1">Example Files</a></h1>
<h4 id="these-example-files-accompany-the-dynamo-primer-and-are-organized-according-to-chapter-and-section"><a class="header" href="#these-example-files-accompany-the-dynamo-primer-and-are-organized-according-to-chapter-and-section">These example files accompany the Dynamo Primer, and are organized according to Chapter and Section.</a></h4>
<h2 id="essential-nodes--concept"><a class="header" href="#essential-nodes--concept">Essential Nodes &amp; Concept</a></h2>
<h3 id="geometry-for-computational-design-1"><a class="header" href="#geometry-for-computational-design-1">Geometry for Computational Design</a></h3>
<h4 id="geometry-overview-1"><a class="header" href="#geometry-overview-1">Geometry Overview</a></h4>
<p>{% file src=&quot;../5_essential_nodes_and_concepts/datasets/5-2/1/Geometry for Computational Design - Geometry Overview.dyn&quot; %}</p>
<h4 id="vector-plane--coordinate-system-1"><a class="header" href="#vector-plane--coordinate-system-1">Vector, Plane &amp; Coordinate System</a></h4>
<p>{% file src=&quot;../5_essential_nodes_and_concepts/datasets/5-2/2/Geometry for Computational Design - Vectors.dyn&quot; %}</p>
<p>{% file src=&quot;../5_essential_nodes_and_concepts/datasets/5-2/2/Geometry for Computational Design - Plane.dyn&quot; %}</p>
<p>{% file src=&quot;../5_essential_nodes_and_concepts/datasets/5-2/2/Geometry for Computational Design - Coordinate System.dyn&quot; %}</p>
<h4 id="points-1"><a class="header" href="#points-1">Points</a></h4>
<p>{% file src=&quot;../5_essential_nodes_and_concepts/datasets/5-2/3/Geometry for Computational Design - Points.dyn&quot; %}</p>
<h4 id="curves-2"><a class="header" href="#curves-2">Curves</a></h4>
<p>{% file src=&quot;../5_essential_nodes_and_concepts/datasets/5-2/4/Geometry for Computational Design - Curves.dyn&quot; %}</p>
<h4 id="surface-2"><a class="header" href="#surface-2">Surface</a></h4>
<p>{% file src=&quot;../5_essential_nodes_and_concepts/datasets/5-2/5/Surfaces.zip&quot; %}</p>
<h4 id="solids-2"><a class="header" href="#solids-2">Solids</a></h4>
<p>{% file src=&quot;../5_essential_nodes_and_concepts/datasets/5-2/6/Geometry for Computational Design - Solids.dyn&quot; %}</p>
<h3 id="the-building-blocks-of-programs-1"><a class="header" href="#the-building-blocks-of-programs-1">The Building Blocks of Programs</a></h3>
<h4 id="data-1"><a class="header" href="#data-1">Data</a></h4>
<p>{% file src=&quot;../5_essential_nodes_and_concepts/datasets/5-3/1/Building Blocks of Programs - Data.dyn&quot; %}</p>
<h4 id="math-2"><a class="header" href="#math-2">Math</a></h4>
<p>{% file src=&quot;../5_essential_nodes_and_concepts/datasets/5-3/2/Building Blocks of Programs - Math.dyn&quot; %}</p>
<h4 id="logic-2"><a class="header" href="#logic-2">Logic</a></h4>
<p>{% file src=&quot;../5_essential_nodes_and_concepts/datasets/5-3/3/Building Blocks of Programs - Logic.dyn&quot; %}</p>
<h4 id="strings-1"><a class="header" href="#strings-1">Strings</a></h4>
<p>{% file src=&quot;../5_essential_nodes_and_concepts/datasets/5-3/4/Building Blocks of Programs - Strings.dyn&quot; %}</p>
<h4 id="color-2"><a class="header" href="#color-2">Color</a></h4>
<p>{% file src=&quot;../5_essential_nodes_and_concepts/datasets/5-3/5/Building Blocks of Programs - Color.dyn&quot; %}</p>
<p>{% file src=&quot;../5_essential_nodes_and_concepts/datasets/5-3/5/BuildingBlocks of Programs - ColorOnSurface.zip&quot; %}</p>
<h3 id="designing-with-lists-1"><a class="header" href="#designing-with-lists-1">Designing with Lists</a></h3>
<h4 id="whats-a-list-2"><a class="header" href="#whats-a-list-2">What's a List</a></h4>
<p>{% file src=&quot;../5_essential_nodes_and_concepts/datasets/5-4/1/Lacing.dyn&quot; %}</p>
<h4 id="working-with-lists-2"><a class="header" href="#working-with-lists-2">Working with Lists</a></h4>
<p>{% file src=&quot;../5_essential_nodes_and_concepts/datasets/5-4/2/List-Operations.dyn&quot; %}</p>
<p>{% file src=&quot;../5_essential_nodes_and_concepts/datasets/5-4/2/List-Count.dyn&quot; %}</p>
<p>{% file src=&quot;../5_essential_nodes_and_concepts/datasets/5-4/2/List-GetItemAtIndex.dyn&quot; %}</p>
<p>{% file src=&quot;../5_essential_nodes_and_concepts/datasets/5-4/2/List-Reverse.dyn&quot; %}</p>
<p>{% file src=&quot;../5_essential_nodes_and_concepts/datasets/5-4/2/List-ShiftIndices.dyn&quot; %}</p>
<p>{% file src=&quot;../5_essential_nodes_and_concepts/datasets/5-4/2/List-FilterByBooleanMask.dyn&quot; %}</p>
<h4 id="lists-of-lists-2"><a class="header" href="#lists-of-lists-2">Lists of Lists</a></h4>
<p>{% file src=&quot;../5_essential_nodes_and_concepts/datasets/5-4/3/Top-Down-Hierarchy.dyn&quot; %}</p>
<p>{% file src=&quot;../5_essential_nodes_and_concepts/datasets/5-4/3/Flatten.dyn&quot; %}</p>
<p>{% file src=&quot;../5_essential_nodes_and_concepts/datasets/5-4/3/Chop.dyn&quot; %}</p>
<p>{% file src=&quot;../5_essential_nodes_and_concepts/datasets/5-4/3/Map.dyn&quot; %}</p>
<p>{% file src=&quot;../5_essential_nodes_and_concepts/datasets/5-4/3/Listatlevel.dyn&quot; %}</p>
<p>{% file src=&quot;../5_essential_nodes_and_concepts/datasets/5-4/3/Transpose.dyn&quot; %}</p>
<p>{% file src=&quot;../5_essential_nodes_and_concepts/datasets/5-4/3/ReplaceItems.dyn&quot; %}</p>
<h4 id="n-dimensional-lists-1"><a class="header" href="#n-dimensional-lists-1">n-Dimensional Lists</a></h4>
<p>{% file src=&quot;../5_essential_nodes_and_concepts/datasets/5-4/4/n-Dimensional-Lists.zip&quot; %}</p>
<h3 id="dictionaries-in-dynamo-1"><a class="header" href="#dictionaries-in-dynamo-1">Dictionaries in Dynamo</a></h3>
<h4 id="revit-use-cases-1"><a class="header" href="#revit-use-cases-1">Revit Use-Cases</a></h4>
<p>{% file src=&quot;../5_essential_nodes_and_concepts/datasets/5-5/4/roomDictionary.dyn&quot; %}</p>
<h2 id="custom-nodes--packages-1"><a class="header" href="#custom-nodes--packages-1">Custom Nodes &amp; Packages</a></h2>
<h3 id="custom-nodes-2"><a class="header" href="#custom-nodes-2">Custom Nodes</a></h3>
<h4 id="creating-a-custom-node-1"><a class="header" href="#creating-a-custom-node-1">Creating a Custom Node</a></h4>
<p>{% file src=&quot;../6_custom_nodes_and_packages/datasets/6-1/2/UV-CustomNode.zip&quot; %}</p>
<h4 id="publishing-to-your-library-1"><a class="header" href="#publishing-to-your-library-1">Publishing to Your Library</a></h4>
<p>{% file src=&quot;../6_custom_nodes_and_packages/datasets/6-1/3/PointsToSurface.dyf&quot; %}</p>
<h3 id="packages-1"><a class="header" href="#packages-1">Packages</a></h3>
<h4 id="package-case-study---mesh-toolkit-1"><a class="header" href="#package-case-study---mesh-toolkit-1">Package Case Study - Mesh Toolkit</a></h4>
<p>{% file src=&quot;../6_custom_nodes_and_packages/datasets/6-2/2/MeshToolkit.zip&quot; %}</p>
<h4 id="publishing-a-package-1"><a class="header" href="#publishing-a-package-1">Publishing a Package</a></h4>
<p>{% file src=&quot;../6_custom_nodes_and_packages/datasets/6-2/4/MapToSurface.zip&quot; %}</p>
<h4 id="zero-touch-importing-1"><a class="header" href="#zero-touch-importing-1">Zero-Touch Importing</a></h4>
<p>{% file src=&quot;../6_custom_nodes_and_packages/datasets/6-2/5/ZeroTouchImages.zip&quot; %}</p>
<h2 id="dynamo-for-revit-1"><a class="header" href="#dynamo-for-revit-1">Dynamo for Revit</a></h2>
<h4 id="selecting-1"><a class="header" href="#selecting-1">Selecting</a></h4>
<p>{% file src=&quot;../7_dynamo_for_revit/datasets/2/Revit-Selecting.zip&quot; %}</p>
<h4 id="editing-1"><a class="header" href="#editing-1">Editing</a></h4>
<p>{% file src=&quot;../7_dynamo_for_revit/datasets/3/Revit-Editing.zip&quot; %}</p>
<h4 id="creating-1"><a class="header" href="#creating-1">Creating</a></h4>
<p>{% file src=&quot;../7_dynamo_for_revit/datasets/4/Revit-Creating-DirectShape.zip&quot; %}</p>
<h4 id="customizing-1"><a class="header" href="#customizing-1">Customizing</a></h4>
<p>{% file src=&quot;../7_dynamo_for_revit/datasets/5/Revit-Customizing.zip&quot; %}</p>
<h4 id="documenting-1"><a class="header" href="#documenting-1">Documenting</a></h4>
<p>{% file src=&quot;../7_dynamo_for_revit/datasets/6/Revit-Documenting.zip&quot; %}</p>
<h2 id="coding-in-dynamo-1"><a class="header" href="#coding-in-dynamo-1">Coding in Dynamo</a></h2>
<h3 id="code-blocks-and-designscript-1"><a class="header" href="#code-blocks-and-designscript-1">Code Blocks and DesignScript</a></h3>
<h4 id="designscript-syntax-1"><a class="header" href="#designscript-syntax-1">DesignScript Syntax</a></h4>
<p>{% file src=&quot;../8_coding_in_dynamo/datasets/8-1/2/Dynamo-Syntax_Attractor-Surface.dyn&quot; %}</p>
<h4 id="shorthand-2"><a class="header" href="#shorthand-2">Shorthand</a></h4>
<p>{% file src=&quot;../8_coding_in_dynamo/datasets/8-1/3/Obsolete-Nodes_Sine-Surface.dyn&quot; %}</p>
<h4 id="functions-1"><a class="header" href="#functions-1">Functions</a></h4>
<p>{% file src=&quot;../8_coding_in_dynamo/datasets/8-1/4/Functions_SphereByZ.dyn&quot; %}</p>
<h3 id="python-1"><a class="header" href="#python-1">Python</a></h3>
<h4 id="python-nodes-1"><a class="header" href="#python-nodes-1">Python Nodes</a></h4>
<p>{% file src=&quot;../8_coding_in_dynamo/datasets/8-2/1/Python_Custom-Node.dyn&quot; %}</p>
<h4 id="python-and-revit-2"><a class="header" href="#python-and-revit-2">Python and Revit</a></h4>
<p>{% file src=&quot;../8_coding_in_dynamo/datasets/8-2/2/Revit-Doc.dyn&quot; %}</p>
<p>{% file src=&quot;../8_coding_in_dynamo/datasets/8-2/2/Revit-ReferenceCurve.dyn&quot; %}</p>
<p>{% file src=&quot;../8_coding_in_dynamo/datasets/8-2/2/Revit-StructuralFraming.zip&quot; %}</p>
<h2 id="best-practices-1"><a class="header" href="#best-practices-1">Best Practices</a></h2>
<h3 id="graph-strategies-1"><a class="header" href="#graph-strategies-1">Graph Strategies</a></h3>
<p>{% file src=&quot;../9_best_practices/datasets/1/RoofDrainageSim.zip&quot; %}</p>
<h3 id="scripting-strategies-1"><a class="header" href="#scripting-strategies-1">Scripting Strategies</a></h3>
<p>{% file src=&quot;../.gitbook/assets/SteepestPath.dyn&quot; %}</p>
<h2 id="sample-workflows-1"><a class="header" href="#sample-workflows-1">Sample Workflows</a></h2>
<h3 id="getting-started-workflows-1"><a class="header" href="#getting-started-workflows-1">Getting Started Workflows</a></h3>
<h4 id="parametric-vase-1"><a class="header" href="#parametric-vase-1">Parametric Vase</a></h4>
<p>{% file src=&quot;../10_sample_workflow/datasets/10-1/1/DynamoSampleWorkflow-vase.dyn&quot; %}</p>
<h4 id="attractor-points-1"><a class="header" href="#attractor-points-1">Attractor Points</a></h4>
<p>{% file src=&quot;../10_sample_workflow/datasets/10-1/2/DynamoSampleWorkflow-Attractors.dyn&quot; %}</p>
<div style="break-before: page; page-break-before: always;"></div><h1 id="download-pdf"><a class="header" href="#download-pdf">Download PDF</a></h1>
<p>To access the information on this primer offline, download the pdf: </p>
<h2 id="releases"><a class="header" href="#releases">Releases:</a></h2>
<h4 id="dynamo-primer-v213"><a class="header" href="#dynamo-primer-v213">Dynamo Primer v2.13:</a></h4>
<p>{% file src=&quot;../.gitbook/assets/Dynamo-Primer-v1.2.pdf&quot; %}</p>

                    </main>

                    <nav class="nav-wrapper" aria-label="Page navigation">
                        <!-- Mobile navigation buttons -->


                        <div style="clear: both"></div>
                    </nav>
                </div>
            </div>

            <nav class="nav-wide-wrapper" aria-label="Page navigation">

            </nav>

        </div>




        <script type="text/javascript">
            window.playground_copyable = true;
        </script>


        <script src="elasticlunr.min.js" type="text/javascript" charset="utf-8"></script>
        <script src="mark.min.js" type="text/javascript" charset="utf-8"></script>
        <script src="searcher.js" type="text/javascript" charset="utf-8"></script>

        <script src="clipboard.min.js" type="text/javascript" charset="utf-8"></script>
        <script src="highlight.js" type="text/javascript" charset="utf-8"></script>
        <script src="book.js" type="text/javascript" charset="utf-8"></script>

        <!-- Custom JS scripts -->

        <script type="text/javascript">
        window.addEventListener('load', function() {
            window.setTimeout(window.print, 100);
        });
        </script>

    </body>
</html>
